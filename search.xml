<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[数据库系统分层优化]]></title>
      <url>http://justdoitlee.github.io/2017/02/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E4%BC%98%E5%8C%96/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>网上有丰富的数据库优化方案，但是大多都是零零碎碎，系统地介绍数据库优化的很少。笔者根据自己的经验，以及参考了其他高手的优化文章，整理一份系统的优化方案。</p>
<p>数据库优化的目的是提高DB的工作效率，减少响应时间。基于此，笔者认为应该从如下四个层次来优化数据库性能。<br><a id="more"></a></p>
<p><li>硬件层面优化</li></p>
<p><li>操作系统/DBMS层面优化</li></p>
<p><li>DB设计层面优化</li></p>
<p><li>程序设计层面的优化</li></p>
<blockquote>
<ol>
<li>硬件层面优化<br>该层面的优化是最底层的，包括内存、CPU、磁盘/磁盘阵列等硬件的优化。虽然可优化的点并不多，但是在整个数据库优化中不可或缺。</li>
<li>操作系统/DBMS层面的优化<br>包括DBMS的选择、缓存的设置、数据文件的存储位置及方法(连续存储/随机存储)、存储引擎的选择(MySQL里面会有多个引擎)、I/O优化(磁盘I/O、逻辑I/O)。该层面的优化内容相对不多，但是数据库优化的瓶颈一般都在这里。</li>
<li>DB设计层面优化<br>该层面可优化的点很多，包括数据库范式、数据表结构、数据类型、视图、索引、表/字段冗余、表分割(水平分割及垂直分割、分类分割)、表触发器、命名等多方面，而且每个方面又有很多的知识点，这是数据库优化的基础。</li>
<li>程序设计层面优化<br>这里由程序员控制层面的优化。包括SQL语句、存储过程、临时表、业务逻辑、算法设计、运算符、条件顺序、数据库函数。这层的知识点比较散，而且多。程序员应该下功夫的地方。</li>
</ol>
</blockquote>
]]></content>
      
        <categories>
            
            <category> 数据库那点事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 优化 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[希尔排序]]></title>
      <url>http://justdoitlee.github.io/2017/02/20/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>希尔排序，也称<strong>递减增量排序算法</strong>，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。<br>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<p><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率</li></p>
<p><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位<br><a id="more"></a><br>原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。之后对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。</li></p>
<p>希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。</p>
<p>假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。</p>
<p>一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用<code>i += step_size</code>而不是<code>i++</code>）。</p>
<p>例如，假设有这样一组数<code>[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]</code>，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样：</p>
<blockquote>
<p>13 14 94 33 82<br>25 59 94 65 23<br>45 27 73 25 39<br>10</p>
</blockquote>
<p>然后我们对每列进行排序：</p>
<blockquote>
<p>10 14 73 25 23<br>13 27 94 33 39<br>25 59 94 65 82<br>45</p>
</blockquote>
<p>将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序：</p>
<blockquote>
<p>10 14 73<br>25 23 13<br>27 94 33<br>39 25 59<br>94 65 82<br>45</p>
</blockquote>
<p>排序之后变为：</p>
<blockquote>
<p>10 14 13<br>25 23 33<br>27 25 59<br>39 65 73<br>45 94 82<br>94</p>
</blockquote>
<p>最后以1步长进行排序（此时就是简单的插入排序了）。</p>
<p>步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。</p>
<p>该算法最初建议步长选择为n/2并且对步长取半直到步长达到1。虽然这样取可以比O(n’2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。</p>
<p>比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。</p>
<p><strong>实现：</strong><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="keyword">int</span>[] arr)</span> </span>&#123;</div><div class="line">	<span class="keyword">int</span> gap = <span class="number">1</span>, i, j, len = arr.length;</div><div class="line">	<span class="keyword">int</span> temp;</div><div class="line">	<span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>)</div><div class="line">		gap = gap * <span class="number">3</span> + <span class="number">1</span>; <span class="comment">// 1, 4, 13, 40, 121, ...</span></div><div class="line">	<span class="keyword">for</span> (; gap &gt; <span class="number">0</span>; gap /= <span class="number">3</span>)</div><div class="line">		<span class="keyword">for</span> (i = gap; i &lt; len; i++) &#123;</div><div class="line">			temp = arr[i];</div><div class="line">			<span class="keyword">for</span> (j = i - gap; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap)</div><div class="line">				arr[j + gap] = arr[j];</div><div class="line">			arr[j + gap] = temp;</div><div class="line">		&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[数据库30条军规解读]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/58%E5%88%B0%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%BA%9330%E6%9D%A1%E5%86%9B%E8%A7%84%E8%A7%A3%E8%AF%BB/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>军规适用场景：并发量大、数据量大的互联网业务<br><br>军规：介绍内容<br><br>解读：讲解原因，解读比军规更重要<br> <a id="more"></a><br>一、基础规范</p>
<p>（1）必须使用InnoDB存储引擎</p>
<blockquote>
<p>解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高</p>
</blockquote>
<p><br>（2）必须使用UTF8字符集</p>
<blockquote>
<p>解读：万国码，无需转码，无乱码风险，节省空间</p>
</blockquote>
<p><br>（3）数据表、数据字段必须加入中文注释</p>
<blockquote>
<p>解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的</p>
</blockquote>
<p><br>（4）禁止使用存储过程、视图、触发器、Event</p>
<blockquote>
<p>解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧</p>
</blockquote>
<p><br>（5）禁止存储大文件或者大照片</p>
<blockquote>
<p>解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好</p>
</blockquote>
<p><br>二、命名规范</p>
<p>（6）只允许使用内网域名，而不是ip连接数据库</p>
<p>（7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范</p>
<blockquote>
<p>业务名称：xxx<br>线上环境：dj.xxx.db<br>开发环境：dj.xxx.rdb<br>测试环境：dj.xxx.tdb<br>从库在名称后加-s标识，备库在名称后加-ss标识<br>线上从库：dj.xxx-s.db<br>线上备库：dj.xxx-sss.db</p>
</blockquote>
<p><br>（8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用</p>
<p>（9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx</p>
<p>三、表设计规范</p>
<p>（10）单实例表数目必须小于500</p>
<p>（11）单表列数目必须小于30</p>
<p>（12）表必须有主键，例如自增主键</p>
<blockquote>
<p>解读：<br>a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用<br>b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率<br>c） 无主键的表删除，在row模式的主从架构，会导致备库夯住</p>
</blockquote>
<p><br>（13）禁止使用外键，如果有外键完整性约束，需要应用程序控制</p>
<blockquote>
<p>解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先</p>
</blockquote>
<p><br>四、字段设计规范</p>
<p><br>（14）必须把字段定义为NOT NULL并且提供默认值</p>
<blockquote>
<p>解读：<br>a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化<br>b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多<br>c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识<br>d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录</p>
</blockquote>
<p><br>（15）禁止使用TEXT、BLOB类型</p>
<blockquote>
<p>解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能</p>
</blockquote>
<p><br>（16）禁止使用小数存储货币</p>
<blockquote>
<p>解读：使用整数吧，小数容易导致钱对不上</p>
</blockquote>
<p><br>（17）必须使用varchar(20)存储手机号</p>
<blockquote>
<p>解读：<br>a）涉及到区号或者国家代号，可能出现+-()<br>b）手机号会去做数学运算么？<br>c）varchar可以支持模糊查询，例如：like“138%”</p>
</blockquote>
<p><br>（18）禁止使用ENUM，可使用TINYINT代替</p>
<blockquote>
<p>解读：<br>a）增加新的ENUM值要做DDL操作<br>b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？</p>
</blockquote>
<p><br>五、索引设计规范</p>
<p>（19）单表索引建议控制在5个以内</p>
<p>（20）单索引字段数不允许超过5个</p>
<blockquote>
<p>解读：字段超过5个时，实际已经起不到有效过滤数据的作用了</p>
</blockquote>
<p><br>（21）禁止在更新十分频繁、区分度不高的属性上建立索引</p>
<blockquote>
<p>解读：<br>a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能<br>b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似</p>
</blockquote>
<p><br>（22）建立组合索引，必须把区分度高的字段放在前面</p>
<blockquote>
<p>解读：能够更加有效的过滤数据</p>
</blockquote>
<p><br>六、SQL使用规范</p>
<p>（23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性</p>
<blockquote>
<p>解读：<br>a）读取不需要的列会增加CPU、IO、NET消耗<br>b）不能有效的利用覆盖索引<br>c）使用SELECT *容易在增加或者删除字段后出现程序BUG</p>
</blockquote>
<p><br>（24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性</p>
<blockquote>
<p>解读：容易在增加或者删除字段后出现程序BUG</p>
</blockquote>
<p><br>（25）禁止使用属性隐式转换</p>
<blockquote>
<p>解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次）</p>
</blockquote>
<p><br>（26）禁止在WHERE条件的属性上使用函数或者表达式</p>
<blockquote>
<p>解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描<br>正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’)</p>
</blockquote>
<p><br>（27）禁止负向查询，以及%开头的模糊查询</p>
<blockquote>
<p>解读：<br>a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描<br>b）%开头的模糊查询，会导致全表扫描</p>
</blockquote>
<p><br>（28）禁止大表使用JOIN查询，禁止大表使用子查询</p>
<blockquote>
<p>解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能</p>
</blockquote>
<p><br>（29）禁止使用OR条件，必须改为IN查询</p>
<blockquote>
<p>解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？</p>
</blockquote>
<p><br>（30）应用程序必须捕获SQL异常，并有相应处理</p>
<p>总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。<br>==【完】==</p>
]]></content>
      
        <categories>
            
            <category> 数据库那点事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 军规 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[apache poi操作(适用于word 2007)]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/apache-poi%E6%93%8D%E4%BD%9C-%E9%80%82%E7%94%A8%E4%BA%8Eword-2007/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>适用于word 2007 poi 版本 3.7<br><a id="more"></a><br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.io.FileOutputStream;</div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.<span class="keyword">HashMap</span>;</div><div class="line"><span class="keyword">import</span> java.util.Iterator;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"><span class="keyword">import</span> java.util.Map.Entry;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.apache.poi.POIXMLDocument;</div><div class="line"><span class="keyword">import</span> org.apache.poi.openxml4j.opc.OPCPackage;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFDocument;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFParagraph;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFRun;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTable;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTableCell;</div><div class="line"><span class="keyword">import</span> org.apache.poi.xwpf.usermodel.XWPFTableRow;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 适用于word 2007 poi 版本 3.7</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class WordPoiUtil &#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 根据指定的参数值、模板，生成 word 文档</div><div class="line">     * </div><div class="line">     * @param param</div><div class="line">     *            需要替换的变量</div><div class="line">     * @param template</div><div class="line">     *            模板</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> XWPFDocument generateWord(Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; param,</div><div class="line">            <span class="keyword">String</span> template) &#123;</div><div class="line">        XWPFDocument doc = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            OPCPackage pack = POIXMLDocument.openPackage(template);</div><div class="line">            doc = <span class="keyword">new</span> XWPFDocument(pack);</div><div class="line">            <span class="keyword">if</span> (param != <span class="keyword">null</span> &amp;&amp; param.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</div><div class="line"></div><div class="line">                <span class="comment">// 处理段落</span></div><div class="line">                List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs();</div><div class="line">                processParagraphs(paragraphList, param, doc);</div><div class="line"></div><div class="line">                <span class="comment">// 处理表格</span></div><div class="line">                Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator();</div><div class="line">                <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                    XWPFTable table = it.next();</div><div class="line">                    List&lt;XWPFTableRow&gt; rows = table.getRows();</div><div class="line">                    <span class="keyword">for</span> (XWPFTableRow row : rows) &#123;</div><div class="line">                        List&lt;XWPFTableCell&gt; cells = row.getTableCells();</div><div class="line">                        <span class="keyword">for</span> (XWPFTableCell cell : cells) &#123;</div><div class="line">                            List&lt;XWPFParagraph&gt; paragraphListTable = cell</div><div class="line">                                    .getParagraphs();</div><div class="line">                            processParagraphs(paragraphListTable, param, doc);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> doc;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 处理段落</div><div class="line">     * </div><div class="line">     * @param paragraphList</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> processParagraphs(List&lt;XWPFParagraph&gt; paragraphList,</div><div class="line">            Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; param, XWPFDocument doc) &#123;</div><div class="line">        <span class="keyword">if</span> (paragraphList != <span class="keyword">null</span> &amp;&amp; paragraphList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphList) &#123;</div><div class="line">                <span class="built_in">boolean</span> addReplace = <span class="keyword">false</span>;</div><div class="line">                List&lt;XWPFRun&gt; runs = paragraph.getRuns();</div><div class="line">                <span class="comment">//每个需要替换的key的run的位置的集合</span></div><div class="line">                List&lt;Integer&gt; replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="comment">//每个段落的所有的key run的集合</span></div><div class="line">                List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; runs.<span class="built_in">size</span>();i++)&#123;</div><div class="line">                    <span class="keyword">String</span> <span class="built_in">text</span> = runs.<span class="built_in">get</span>(i).getText(<span class="number">0</span>);</div><div class="line">                    <span class="keyword">if</span>(addReplace)&#123;</div><div class="line">                        replaceRuns.<span class="built_in">add</span>(i);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"#"</span>))&#123;</div><div class="line">                        addReplace = <span class="keyword">true</span>;</div><div class="line">                        replaceRuns.<span class="built_in">add</span>(i);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"&#125;"</span>))&#123;</div><div class="line">                        addReplace = <span class="keyword">false</span>;</div><div class="line">                        perReplaceRunList.<span class="built_in">add</span>(replaceRuns);</div><div class="line">                        replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;perReplaceRunList.<span class="built_in">size</span>();i++)&#123;</div><div class="line">                    List&lt;Integer&gt; runsList = perReplaceRunList.<span class="built_in">get</span>(i);</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"=========================="</span>);</div><div class="line">                    StringBuffer textSb = <span class="keyword">new</span> StringBuffer();</div><div class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============replace_runs"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</div><div class="line">                        textSb.<span class="built_in">append</span>(runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">String</span> replaceStr = textSb.toString();</div><div class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>; j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</div><div class="line">                        <span class="keyword">for</span> (Entry&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; entry : param.entrySet()) &#123;</div><div class="line">                            <span class="keyword">String</span> <span class="built_in">key</span> = entry.getKey();</div><div class="line">                            <span class="keyword">if</span> (replaceStr.indexOf(<span class="built_in">key</span>) != <span class="number">-1</span>) &#123;</div><div class="line">                                <span class="keyword">Object</span> value = entry.getValue();</div><div class="line">                                <span class="keyword">if</span> (value <span class="keyword">instanceof</span> <span class="keyword">String</span>) &#123;<span class="comment">// 文本替换</span></div><div class="line">                                    replaceStr = replaceStr.replace(<span class="built_in">key</span>, value.toString());</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"==========="</span>+replaceStr);</div><div class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</div><div class="line">                        <span class="keyword">if</span>(j == <span class="number">0</span>)&#123;</div><div class="line">                            runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).setText(replaceStr, <span class="number">0</span>);</div><div class="line">                        &#125;<span class="keyword">else</span>&#123;</div><div class="line">                            runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).setText(<span class="string">""</span>, <span class="number">0</span>);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============转换后"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getReplaceFields(<span class="keyword">String</span> template)&#123;</div><div class="line">        List&lt;<span class="keyword">String</span>&gt; replaceFields = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line">        XWPFDocument doc = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            OPCPackage pack = POIXMLDocument.openPackage(template);</div><div class="line">            doc = <span class="keyword">new</span> XWPFDocument(pack);</div><div class="line">            <span class="comment">// 处理段落</span></div><div class="line">            List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs();</div><div class="line">            replaceFields.addAll(getFields(paragraphList));</div><div class="line"></div><div class="line">            <span class="comment">// 处理表格</span></div><div class="line">            Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator();</div><div class="line">            <span class="keyword">while</span> (it.hasNext()) &#123;</div><div class="line">                XWPFTable table = it.next();</div><div class="line">                List&lt;XWPFTableRow&gt; rows = table.getRows();</div><div class="line">                <span class="keyword">for</span> (XWPFTableRow row : rows) &#123;</div><div class="line">                    List&lt;XWPFTableCell&gt; cells = row.getTableCells();</div><div class="line">                    <span class="keyword">for</span> (XWPFTableCell cell : cells) &#123;</div><div class="line">                        List&lt;XWPFParagraph&gt; paragraphListTable = cell</div><div class="line">                                .getParagraphs();</div><div class="line">                        replaceFields.addAll(getFields(paragraphListTable));</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> replaceFields;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取段落的需要替换的字段</div><div class="line">     * @param paragraphList</div><div class="line">     * @return</div><div class="line">     */</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;<span class="keyword">String</span>&gt; getFields(List&lt;XWPFParagraph&gt; paragraphList) &#123;</div><div class="line">        List&lt;<span class="keyword">String</span>&gt; fieldList = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line">        <span class="keyword">if</span> (paragraphList != <span class="keyword">null</span> &amp;&amp; paragraphList.<span class="built_in">size</span>() &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (XWPFParagraph paragraph : paragraphList) &#123;</div><div class="line">                <span class="built_in">boolean</span> addReplace = <span class="keyword">false</span>;</div><div class="line">                List&lt;XWPFRun&gt; runs = paragraph.getRuns();</div><div class="line">                <span class="comment">//每个需要替换的key的run的位置的集合</span></div><div class="line">                List&lt;Integer&gt; replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                <span class="comment">//每个段落的所有的key run的集合</span></div><div class="line">                List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = <span class="keyword">new</span> ArrayList&lt;List&lt;Integer&gt;&gt;();</div><div class="line">                <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i&lt; runs.<span class="built_in">size</span>();i++)&#123;</div><div class="line">                    <span class="keyword">String</span> <span class="built_in">text</span> = runs.<span class="built_in">get</span>(i).getText(<span class="number">0</span>);</div><div class="line">                    <span class="keyword">if</span>(addReplace)&#123;</div><div class="line">                        replaceRuns.<span class="built_in">add</span>(i);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"#"</span>))&#123;</div><div class="line">                        addReplace = <span class="keyword">true</span>;</div><div class="line">                        replaceRuns.<span class="built_in">add</span>(i);</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">if</span>(<span class="built_in">text</span> != <span class="keyword">null</span> &amp;&amp; <span class="built_in">text</span>.contains(<span class="string">"&#125;"</span>))&#123;</div><div class="line">                        addReplace = <span class="keyword">false</span>;</div><div class="line">                        perReplaceRunList.<span class="built_in">add</span>(replaceRuns);</div><div class="line">                        replaceRuns = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">for</span>(<span class="built_in">int</span> i=<span class="number">0</span>;i&lt;perReplaceRunList.<span class="built_in">size</span>();i++)&#123;</div><div class="line">                    List&lt;Integer&gt; runsList = perReplaceRunList.<span class="built_in">get</span>(i);</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"=========================="</span>);</div><div class="line">                    StringBuffer textSb = <span class="keyword">new</span> StringBuffer();</div><div class="line">                    <span class="keyword">for</span>(<span class="built_in">int</span> j = <span class="number">0</span>;j&lt;runsList.<span class="built_in">size</span>();j++)&#123;</div><div class="line">                        System.out.<span class="built_in">println</span>(<span class="string">"============replace_runs"</span>+runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</div><div class="line">                        textSb.<span class="built_in">append</span>(runs.<span class="built_in">get</span>(runsList.<span class="built_in">get</span>(j)).getText(<span class="number">0</span>));</div><div class="line">                    &#125;</div><div class="line">                    <span class="keyword">String</span> replaceStr = textSb.toString().<span class="built_in">trim</span>();</div><div class="line">                    System.out.<span class="built_in">println</span>(<span class="string">"====replaceStr="</span> + replaceStr.substring(replaceStr.indexOf(<span class="string">"#"</span>)+<span class="number">2</span>,replaceStr.length()<span class="number">-1</span>));</div><div class="line"><span class="comment">//                  System.out.println(replaceStr.substring(2,replaceStr.length()-1));</span></div><div class="line">                    fieldList.<span class="built_in">add</span>(replaceStr.substring(replaceStr.indexOf(<span class="string">"#"</span>)+<span class="number">2</span>,replaceStr.length()<span class="number">-1</span>));</div><div class="line"></div><div class="line">                &#125;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> fieldList;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[时间复杂度和空间复杂度详解]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>没有挤公交来上班过，就不知道生活的压力有多大。</p>
</blockquote>
<a id="more"></a>
<p>算法的时间复杂度和空间复杂度合称为算法的复杂度。<br><br>1.时间复杂度<br>（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。<br><br>（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。<br><br>     时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。<br><br>    按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。<br><br> （3）最坏时间复杂度和平均时间复杂度 　最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。<br><br>     在最坏情况下的时间复杂度为T(n)=0(n)，它表示对于任何输入实例,该算法的运行时间不可能大于0(n)。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。<br><br>    指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。<br><br>（4）求时间复杂度<br><br>【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。<br></p>
<blockquote>
<p>x=91; y=100;<br>while(y&gt;0) if(x&gt;100) {x=x-10;y–;} else x++;</p>
</blockquote>
<p>解答： T(n)=O(1)，<br>这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?<br>没。这段程序的运行是和n无关的，<br>就算它再循环一万年，我们也不管他，只是一个常数阶的函数</p>
<p>【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。</p>
<blockquote>
<p>x=1;<br>for(i=1;i&lt;=n;i++)<br>        for(j=1;j&lt;=i;j++)<br>           for(k=1;k&lt;=j;k++)<br>               x++; 　</p>
</blockquote>
<p>该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数：  则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3)</p>
<p>【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。<br>在数值A[0..n-1]中查找给定值K的算法大致如下： </p>
<blockquote>
<p>i=n-1;<br>while(i&gt;=0&amp;&amp;(A[i]!=k))<br>      i–;<br>return i;      </p>
</blockquote>
<p>此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。<br>（5）时间复杂度评价性能<br>有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。（1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。（2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。</p>
<p>2.空间复杂度<br>一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。　</p>
<p>（1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。<br><br>（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。<br><br>一个算法所需的存储空间用f(n)表示。S(n)=O(f(n))　　其中n为问题的规模，S(n)表示空间复杂度。</p>
]]></content>
      
        <categories>
            
            <category> 算法 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 时间复杂度 </tag>
            
            <tag> 空间复杂度 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2016年总结]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/2016%E5%B9%B4%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><h2>在2016这一年</h2>

<p>技术长进了。</p>
<p>Java:从SSH框架转到SSM，并且见识了基于Spring boot的威力，补了一下Java基础，正在接触算法。</p>
<p>Linux:记住了越来的越多的Linux命令，能独立维护并处理部分服务问题了。</p>
<p>Python:终于算是入门了，入门了却没看到出门在哪里。<br><a id="more"></a></p>
<p>JS&amp;HTML&amp;CSS3:这似乎不是我该关注的问题，能独立解决UI上的问题已经够了。</p>
<p>完成了至少三个项目，从pc端到web端到微信端到hybridApp。</p>
<p>项目是最好的导师，边学边做，边学边用，虽然不能用到最好，但这确实是很有效的学习途径，先实现再优化。</p>
<p>有毅力和活力，天生乐观派。认定了的事情一定要去完成，本职工作必须要做到尽职尽责。</p>
<p><strong>不足：</strong></p>
<p>发现的自己实力还是离自己的期望的差了很多。</p>
<p>纠结综合症。</p>
<p>强迫症。</p>
<h2>展望2017！</h2>

<p>有想法</p>
<p>想法一：继续补课</p>
<p>实习大半年后，发现在大学期间没有好好学习Java基础，也没有学的特别扎实！很多东西自己还不知道，需要补课！现在也算是个半吊子的Java程序员，虽然看了一遍的Java核心技术，但是还是要继续巩固，不同阶段相信有不同的理解，以后还会买更多的书回来，继续学习。</p>
<p>想法二：学习框架和算法</p>
<p>完成了基本的基础学习，开始着手框架，从Spring开始学起，了解框架底层原理，并且模仿造几个轮子。</p>
<p>大学只掌握了一些基础的数据结构知识，想要进大企业，算法也不能落下，不过这种东西不是可以快速见到成效的，所以静下心，慢慢来！</p>
<p>想法三：改</p>
<p>现在的写的代码用一个字形容——乱。</p>
<p>SVN没有发挥它该有的作用，SVN上的代码都不是最新的。</p>
<p>缺少一个完整的项目管理软件，BUG没有任何追踪记录，解决了？！没解决？！进度走到哪里了？！后续是关注还是下放到下一个版本解决？！项目的开发进度完成了吗？！</p>
<p>有计划</p>
<p>计划一:读书计划。</p>
<p>读完至少6本技术书籍，以下为计划书单：</p>
<p>1.《Java核心技术 卷一》 再读</p>
<p>2.《Java核心技术 卷二》 也可选择《java编程思想》</p>
<p>3.《Effective Java》</p>
<p>4.《深入理解Java虚拟机：JVM高级特性与最佳实践》</p>
<p>5.《大型网站技术架构 核心原理与案例分析》</p>
<p>6.《Java并发编程的艺术》</p>
<p>7.《算法第四版》</p>
<p>计划二：工作计划</p>
<p>1.2017年，继续坚持现有的工作状态。</p>
<p>2.加强自己的业务代码能力。</p>
<p>3.接触新项目（不同领域）。</p>
<p>4.自己做点外包。</p>
<p>（完）</p>
]]></content>
      
        <categories>
            
            <category> 程序人生 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[jdk1.8的HashMap和ConcurrentHashMap]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/jdk1-8%E7%9A%84HashMap%E5%92%8CConcurrentHashMap/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>本文针对jdk1.8的ConcurrentHashMap</p>
<h1>1.8的HashMap设计</h1>

<h2>1.1 整体概览</h2>

<p>HashMap采用的是<strong>数组+链表+红黑树</strong>的形式。</p>
<p>数组是可以扩容的，链表也是转化为红黑树的，这2种方式都可以承载更多的数据。</p>
<p>用户可以设置的参数：初始总容量默认16，默认的加载因子0.75</p>
<p>初始的数组个数默认是16（用户不能设置的）</p>
<p>容量X加载因子=阈值</p>
<p>一旦目前容量超过该阈值，则执行扩容操作。<a id="more"></a></p>
<p><strong>什么时候扩容？</strong></p>
<p><li>当前容量超过阈值</li></p>
<p><li>当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树</li></p>
<p><strong>什么时候链表转化为红黑树？（上面已经提到了）</strong></p>
<p><li>当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树</li></p>
<p>目前形象的表示数组中的一个元素称为一个桶</p>
<h2>1.2 put过程</h2>

<p><li>根据key计算出hash值</li></p>
<p><li>hash值&amp;（数组长度-1）得到所在数组的index</li></p>
<pre><code>如果该index位置的Node元素不存在，则直接创建一个新的Node
如果该index位置的Node元素是TreeNode类型即红黑树类型了，则直接按照红黑树的插入方式进行插入
如果该index位置的Node元素是非TreeNode类型则，则按照链表的形式进行插入操作
</code></pre><p>链表插入操作完成后，判断是否超过阈值TREEIFY_THRESHOLD（默认是8），超过则要么数组扩容要么链表转化成红黑树</p>
<p><li>判断当前总容量是否超出阈值，如果超出则执行扩容</li></p>
<p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107004609227" alt="这里写图片描述"></p>
<p>下面来说说这个扩容的过程</p>
<h2>1.3 扩容过程</h2>

<p>按照2倍扩容的方式，那么就需要将之前的所有元素全部重新按照2倍桶的长度重新计算所在桶。这里为啥是2倍？</p>
<p>因为2倍的话，更加容易计算他们所在的桶，并且各自不会相互干扰。如原桶长度是4，现在桶长度是8，那么</p>
<pre><code>桶0中的元素会被分到桶0和桶4中
桶1中的元素会被分到桶1和桶5中
桶2中的元素会被分到桶2和桶6中
桶3中的元素会被分到桶3和桶7中
</code></pre><p>为啥是这样呢？</p>
<p>桶0中的元素的hash值后2位必然是00，这些hash值可以根据后3位000或者100分成2类数据。他们分别&amp;（8-1）即&amp;111,则后3位为000的在桶0中，后3位为100的必然在桶4中。其他同理，也就是说桶4和桶0重新瓜分了原来桶0中的元素。</p>
<p>如果换成其他倍数，那么瓜分就比较混乱了。</p>
<p>这样在瓜分这些数据的时候，只需要先把这些数据分类，如上述桶0中分成000和100 2类，然后直接构成新的链表，分类完毕后，直接将新的链表挂在对应的桶下即可，源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107004911697" alt="这里写图片描述"></p>
<p>上述 (e.hash &amp; oldCap) == 0 即可将原桶中的数据分成2类</p>
<p>上述是对于链表情况下的重新移动，而针对红黑树情况下：</p>
<p>则需要考虑分类之后是否还需要依然保持红黑树，如果个数少则直接使用链表即可。</p>
<h2>1.4 get过程</h2>

<p>get过程比较简单</p>
<p><li>根据key计算出hash值</li></p>
<p><li>hash值&amp;（数组长度-1）得到所在数组的index        </li></p>
<pre><code>如果要找的key就是上述数组index位置的元素，直接返回该元素的值
如果该数组index位置元素是TreeNode类型，则按照红黑树的查询方式来进行查找
如果该数组index位置元素非TreeNode类型，则按照链表的方式来进行遍历查询
</code></pre><p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005249311" alt="这里写图片描述"></p>
<h1>1.7的ConcurrentHashMap设计</h1>

<p>ConcurrentHashMap是线程安全，通过分段锁的方式提高了并发度。分段是一开始就确定的了，后期不能再进行扩容的。</p>
<p>其中的段Segment继承了重入锁ReentrantLock，有了锁的功能，同时含有类似HashMap中的数组加链表结构（这里没有使用红黑树）</p>
<p>虽然Segment的个数是不能扩容的，但是单个Segment里面的数组是可以扩容的。</p>
<h2>2.1 整体概览</h2>

<p>ConcurrentHashMap有3个参数：</p>
<pre><code>initialCapacity：初始总容量，默认16
loadFactor：加载因子，默认0.75
concurrencyLevel：并发级别，默认16
</code></pre><p>然后我们需要知道的是：</p>
<p><li>segment的个数即ssize</li></p>
<p>取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16</p>
<p><li>单个segment的初始容量cap</li></p>
<p>c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2</p>
<p>c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是2</p>
<p><li>单个segment的阈值threshold</li></p>
<p>cap*loadFactor</p>
<p>所以默认情况下，segment的个数sszie=16,每个segment的初始容量cap=2，单个segment的阈值threshold=1</p>
<h2>2.2 put过程</h2>

<p><li>首先根据key计算出一个hash值，找到对应的Segment</li></p>
<p><li>调用Segment的lock方法，为后面的put操作加锁</li></p>
<p><li>根据key计算出hash值，找到Segment中数组中对应index的链表，并将该数据放置到该链表中</li></p>
<p><li>判断当前Segment包含元素的数量大于阈值，则Segment进行扩容</li></p>
<p>整体代码逻辑见如下源码：</p>
<p><img src="http://img.blog.csdn.net/20170107005617154" alt="这里写图片描述"></p>
<p>其中上述Segment的put过程源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005641091" alt="这里写图片描述"></p>
<h2>2.3 扩容过程</h2>

<p>这个扩容是在Segment的锁的保护下进行扩容的，不需要关注并发问题。</p>
<p><img src="http://img.blog.csdn.net/20170107005716473" alt="这里写图片描述"></p>
<p>这里的重点就是：</p>
<p>首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。</p>
<p>然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。</p>
<h2>2.4 get过程</h2>

<p><li>根据key计算出对应的segment</li></p>
<p><li>再根据key计算出对应segment中数组的index</li></p>
<p><li>最终遍历上述index位置的链表，查找出对应的key的value</li></p>
<p>源码如下：</p>
<p><img src="http://img.blog.csdn.net/20170107005803333" alt="这里写图片描述"></p>
<h1>1.8的ConcurrentHashMap设计</h1>

<p>1.8的ConcurrentHashMap摒弃了1.7的segment设计，而是在1.8HashMap的基础上实现了线程安全的版本，即也是采用<strong>数组+链表+红黑树</strong>的形式。</p>
<p>数组可以扩容，链表可以转化为红黑树</p>
<h2>3.1 整体概览</h2>

<p>有一个重要的参数sizeCtl，代表数组的大小（但是还有其他取值及其含义，后面再详细说到）</p>
<p>用户可以设置一个初始容量initialCapacity给ConcurrentHashMap</p>
<p>sizeCtl=大于（1.5倍initialCapacity+1）的最小的2的幂次。</p>
<p>即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。</p>
<p>初始化的时候，会按照sizeCtl的大小创建出对应大小的数组</p>
<h2>3.2 put过程</h2>

<p>源码如下所示：</p>
<p><img src="http://img.blog.csdn.net/20170107005911460" alt="这里写图片描述"></p>
<p><li>如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作</li></p>
<p><li>根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新</li></p>
<p><li>如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细谈及。</li></p>
<p><li>如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新</li></p>
<pre><code>如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新
如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新
</code></pre><p><li>在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树</li></p>
<p><strong>下面就来重点看看这个扩容过程</strong></p>
<h2>3.3 扩容过程</h2>

<p>一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟HashMap依据的策略是一致的。</p>
<p>当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。</p>
<p>源码如下所示：</p>
<p><img src="http://img.blog.csdn.net/20170107010024665" alt="这里写图片描述"></p>
<p>重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式</p>
<p><img src="http://img.blog.csdn.net/20170107010051374" alt="这里写图片描述"></p>
<p>第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。</p>
<p>该ConcurrentHashMap的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。</p>
<p><strong>问题1：当前线程如何感知其他线程也在参与迁移工作？</strong></p>
<p>靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010125312" alt="这里写图片描述"></p>
<p><strong>问题2：任务按照何规则进行分片？</strong></p>
<p><img src="http://img.blog.csdn.net/20170107010151062" alt="这里写图片描述"></p>
<p>上述stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。</p>
<p><strong>问题3：如何记录目前已经分出去的任务？</strong></p>
<p>ConcurrentHashMap含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。</p>
<p><strong>问题4：每个线程如何处理分到的部分桶的迁移工作</strong></p>
<p>第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。</p>
<p>遍历自己所分到的桶：</p>
<pre><code>桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用

此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了

桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对）

桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了
</code></pre><p>下面来看下详细的代码：</p>
<p><img src="http://img.blog.csdn.net/20170107010302919" alt="这里写图片描述"></p>
<h2>3.4 get过程</h2>

<p><li>根据k计算出hash值，找到对应的数组index</li></p>
<p><li>如果该index位置无元素则直接返回null</li></p>
<p><li>如果该index位置有元素</li></p>
<pre><code>如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin

如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找

如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找

如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素
</code></pre><p>详细代码如下</p>
<p><img src="http://img.blog.csdn.net/20170107010356702" alt="这里写图片描述"></p>
<p>至此，ConcurrentHashMap主要的操作都粗略的介绍完毕了，其他一些操作靠各位自行去看了。</p>
<p>下面针对一些问题来进行解答</p>
<p></p><h1>问题分析<h1><p></p>
<h2>4.1 ConcurrentHashMap读为什么不需要锁？</h2>

<p>我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？</p>
<p>如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如ConcurrentHashMap对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。</p>
<p>假如ConcurrentHashMap提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。</p>
<p>虽然ConcurrentHashMap的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。</p>
<h2>4.2 ConcurrentHashMap是否可以在无锁的情况下进行迁移？</h2>

<p>目前1.8的ConcurrentHashMap迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题：</p>
<p><li>在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？</li></p>
<p>一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010526876" alt="这里写图片描述"></p>
<p><li>某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？</li></p>
<p>该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作）</p>
<p>从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？</p>
<p>可以参考参考这篇论文Split-Ordered Lists: Lock-Free Extensible Hash Tables</p>
<p>一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。上述Split-Ordered Lists就是把所有元素按照一定的顺序进行排列。该list被分成一段一段的，每一段都代表某个桶中的所有元素。每个桶中都有一个指向第一个元素的指针，如下图结构所示：</p>
<p><img src="http://img.blog.csdn.net/20170107010603392" alt="这里写图片描述"></p>
<p>每一段其实也是分成2类的，如同前面所说的HashMap在扩容是分成2类的情况是一样的，此时Split-Ordered Lists在扩容时就只需要将新桶的指针指向这2类的分界点即可。</p>
<p>这一块之后再详细说明吧。</p>
<h2>4.3 ConcurrentHashMap曾经的弱一致性</h2>

<p>具体详见这篇针对老版本的ConcurrentHashMap的说明文章<a href="http://ifeve.com/concurrenthashmap-weakly-consistent/" target="_blank" rel="external">为什么ConcurrentHashMap是弱一致的</a></p>
<p>文中已经解释到：对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。</p>
<p>我觉得这个只需要稍微改动下就可以实现强一致性：</p>
<p><li>对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式</li></p>
<p><li>或者对数组中元素的更新采用volatile写的方式，如下1.7的形式</li></p>
<p>但是现在1.7版本的ConcurrentHashMap对于数组中元素的写也是加了volatile的，如下代码</p>
<p><img src="http://img.blog.csdn.net/20170107010723393" alt="这里写图片描述"></p>
<p>1.8的方式就是：直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素。</p>
<p><img src="http://img.blog.csdn.net/20170107010744786" alt="这里写图片描述"></p>
<p>所以在1.7和1.8版本的ConcurrentHashMap中不再是弱一致性，写入的数据是可以立马本读到的。</p>
</h1></h1>]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[cordova中与inBrowser的通讯]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Browser%E7%9A%84%E9%80%9A%E8%AE%AF%E2%80%9D/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>为了把我的练琴记录仪改成多用户App，我需要做一个Weibo OAuth功能，因为练琴记录仪是Single Page App，我不愿意直接跳转到OAuth页面，那样会打断我的应用状态，于是我打算打开一个新窗口来完成OAuth。</p>
<p>这样一来，问题自然就转换为跨窗口通讯问题了。<br><a id="more"></a><br>窗口间通讯毫无疑问首选是 window.postMessage ，在cordova当中，原生 window.open 是不能用的，官方给的方案是使用 cordova-plugin-inappbrowser 插件所提供的 cordova.InAppBrowser.open(url, target, options) 来取代 window.open ，这两者基本上API差不多一致。</p>
<p>但是IAB插件所返回的对象并不是真正的 window ，它没有 postMessage 功能，并且在IAB所打开的页面中，也没有 window.opener ，于是只能另辟蹊径，找点不靠谱的挫方法来试试了。</p>
<p>OAuth基本流程</p>
<p>OAuth的基本流程这里就不赘述了，简单描述一下</p>
<p>Client需要授权，把自己（由服务商分配的） client_id ——也称 app key 以及在服务商注册的 redirect_url 拼在一起，让用户去访问服务商的 authorize 地址。<br>服务商会询问用户是否对这个 client_id 授权自己的账号，如果是，会跳转到 redirect_url?code=xxxxxx 。<br>应用的服务端接收到 redirect_url 的访问，用URL参数中的 code 和自己的 client_id 以及 app secret （相当于密码）去请求服务商的 access_token 接口，得到 access_token ，这个就是此应用对于这个用户账号的访问凭条。<br>redirect_url 页面根据应用自身需要把获得的 access_token 传回应用，完成授权过程。<br>使用 window.open 时的流程</p>
<p>客户端 var win = window.open(oauth_url) 。<br>完成OAuth授权，跳转到 redirect_url 。<br>在 redirect_url 上，把 access_token 用 window.opener.postMessage 的方式发给应用。<br>应用监听 win 的 onmessage 事件，一旦收到了 access_token 就完成授权，可以 win.close() 了。<br>然后我先把它写成了一个函数</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindowViaBrowser</span>(<span class="params">url, target, opts, key, timeout</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> defer = <span class="built_in">Promise</span>.defer()</div><div class="line">  <span class="keyword">let</span> resolve = defer.resolve.bind(defer)</div><div class="line">  <span class="keyword">let</span> reject = defer.reject.bind(defer)</div><div class="line">  <span class="keyword">let</span> promise = defer.promise</div><div class="line">  <span class="keyword">let</span> timing</div><div class="line"></div><div class="line">  <span class="keyword">let</span> win = <span class="built_in">window</span>.open(url, target, utils.buildOpenWindowOptions(opts))</div><div class="line"></div><div class="line">  <span class="keyword">let</span> onMessage = <span class="function"><span class="params">e</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">let</span> data = e.data || &#123;&#125;</div><div class="line">    <span class="keyword">if</span> (data.type === <span class="string">'cross-window'</span> &amp;&amp; data.key === key) &#123;</div><div class="line">      parseResult(data.result, resolve, reject)</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">// close（貌似）没有可用的事件，`win.addEventListener('close')`没用的样子</span></div><div class="line">  <span class="comment">// `win.addEventListener`不好用的问题也可能是因为跨域，真是蛋疼啊</span></div><div class="line">  <span class="comment">// 于是轮询`closed`属性吧</span></div><div class="line">  <span class="keyword">let</span> pollingClosed = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="keyword">if</span> (win.closed) &#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(ErrorType.CANCELED))</div><div class="line">    &#125;</div><div class="line">  &#125;, POLLING_INTERVAL)</div><div class="line"></div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, onMessage, <span class="literal">false</span>)</div><div class="line"></div><div class="line">  <span class="comment">// 超时`reject`</span></div><div class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</div><div class="line">    timing = setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(ErrorType.TIMEOUT))</div><div class="line">    &#125;, timeout)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  promise.finally(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</div><div class="line">    <span class="comment">// clean up</span></div><div class="line">    clearInterval(pollingClosed)</div><div class="line">    clearTimeout(timing)</div><div class="line">    <span class="built_in">window</span>.removeEventListener(<span class="string">'message'</span>, onMessage)</div><div class="line">    win.close()</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用 cordova.InAppBrowser.open 时的流程</p>
<p>客户端 var win = cordova.InAppBrowser.open(oauth_url) 。<br>客户端开始对 win.executeScript 并进行轮询，其内容是尝试读取 localStorage.getItem(key) 。<br>redirect_url 页面把获取到的 access_token 写到 localStorage.setItem(key, access_token) 。<br>客户端一旦轮询到 localStorage.getItem(key) 有值，就可以得到 access_token ，然后就可以 localStorage.removeItem(key) ，完成授权， win.close() 。<br>然后我也单独写了一个函数</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindowViaCordovaIAB</span><span class="params">(url, target, opts, key, timeout)</span> </span>&#123;</div><div class="line">  <span class="keyword">let</span> defer = Promise.defer()</div><div class="line">  <span class="keyword">let</span> resolve = defer.resolve.bind(defer)</div><div class="line">  <span class="keyword">let</span> reject = defer.reject.bind(defer)</div><div class="line">  <span class="keyword">let</span> promise = defer.promise</div><div class="line">  <span class="keyword">let</span> timing</div><div class="line"></div><div class="line">  <span class="keyword">let</span> win = cordova.InAppBrowser.open(url, target, utils.buildOpenWindowOptions(opts))</div><div class="line">  <span class="comment">// cordova的InAppBrowser没有window.opener对象，只能使用轮询罢。。</span></div><div class="line">  <span class="keyword">const</span> code = `(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">var</span> key = <span class="string">'$&#123;key&#125;'</span></div><div class="line">    <span class="keyword">var</span> data = localStorage.getItem(key)</div><div class="line">    <span class="keyword">if</span> (data !== <span class="keyword">null</span>) &#123;</div><div class="line">      localStorage.removeItem(key)</div><div class="line">      <span class="keyword">return</span> data</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">false</span></div><div class="line">  &#125;)()`</div><div class="line"></div><div class="line">  <span class="keyword">let</span> poll = () =&gt; &#123;</div><div class="line">    win.executeScript(&#123; code: code &#125;, ret =&gt; &#123;</div><div class="line">      <span class="keyword">if</span> (ret[<span class="number">0</span>] === <span class="keyword">false</span>) &#123;</div><div class="line">        <span class="comment">// 等待</span></div><div class="line">      &#125; <span class="keyword">else</span> &#123;</div><div class="line">        clearInterval(pollingData)</div><div class="line">        parseResult(ret[<span class="number">0</span>], resolve, reject)</div><div class="line">      &#125;</div><div class="line">    &#125;)</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">let</span> pollingData = setInterval(poll, POLLING_INTERVAL)</div><div class="line"></div><div class="line">  <span class="comment">// 窗口关闭时`reject`</span></div><div class="line">  <span class="comment">// 正常流程上面`resolve`后才会`win.close()`，所以这里再`reject`也不会有影响</span></div><div class="line">  win.addEventListener(<span class="string">'exit'</span>, e =&gt; &#123;</div><div class="line">    reject(<span class="keyword">new</span> Error(ErrorType.CANCELED))</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="comment">// 超时`reject`</span></div><div class="line">  <span class="keyword">if</span> (timeout &gt; <span class="number">0</span>) &#123;</div><div class="line">    timing = setTimeout(() =&gt; &#123;</div><div class="line">      reject(<span class="keyword">new</span> Error(ErrorType.TIMEOUT))</div><div class="line">    &#125;, timeout)</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  promise.<span class="keyword">finally</span>(() =&gt; &#123;</div><div class="line">    <span class="comment">// clean up</span></div><div class="line">    clearInterval(pollingData)</div><div class="line">    clearTimeout(timing)</div><div class="line">    win.close()</div><div class="line">  &#125;)</div><div class="line"></div><div class="line">  <span class="keyword">return</span> promise</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>整合</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">crossWindow</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;</div><div class="line">  <span class="keyword">if</span> (window.cordova !== <span class="literal">undefined</span> &amp;&amp; cordova.InAppBrowser !== <span class="literal">undefined</span>) &#123;</div><div class="line">    <span class="keyword">return</span> crossWindowViaCordovaIAB(...args)</div><div class="line">  &#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="keyword">return</span> crossWindowViaBrowser(...args)</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>服务端</p>
<p>服务端的Redirect Page我是用PHP写的，涉及到上面的 cross-browser 的部分大概是：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> key = <span class="xml"><span class="php"><span class="meta">&lt;?</span>= json_encode($key) <span class="meta">?&gt;</span></span></span></div><div class="line"></div><div class="line">  var result = <span class="php"><span class="meta">&lt;?</span>= json_encode($output) <span class="meta">?&gt;</span></span></div><div class="line"></div><div class="line">  localStorage.setItem(key, result)</div><div class="line">  if (window.opener) &#123;</div><div class="line">    window.opener.postMessage(&#123;</div><div class="line">      type: 'cross-window',</div><div class="line">      key: key,</div><div class="line">      result: result</div><div class="line">    &#125;, '*')</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>其中 $output 是对 access_token 接口 curl 得到的返回值，虽然微博给的返回值理论上说都是合法的JSON，但出于通用考虑我还是直接把它当字符串传递，让客户端自己在 parse 的时候进行 try/catch ，而且这样对 localStorage 也比较直接。</p>
]]></content>
      
        <categories>
            
            <category> 移动开发 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Cordova </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[高级for循环使用remove/add 问题]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E9%AB%98%E7%BA%A7for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8remove-add-%E9%97%AE%E9%A2%98/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天在高级for循环中用了一下remove发现报错，写了个demo测试看：<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"> List&lt;<span class="keyword">String</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line"> a.<span class="built_in">add</span>(<span class="string">"1"</span>);</div><div class="line"> a.<span class="built_in">add</span>(<span class="string">"2"</span>);</div><div class="line"> <span class="keyword">for</span> (<span class="keyword">String</span> temp : a) &#123;</div><div class="line">     <span class="keyword">if</span>(<span class="string">"1"</span>.equals(temp))&#123;</div><div class="line">         a.remove(temp);</div><div class="line">&#125; &#125;</div></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>此时代码是没有问题的，运行正常；但是把”1”.equals(temp)换成”2”.equals(temp)之后，问题就出来了！</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.util</span><span class="selector-class">.ConcurrentModificationException</span></div><div class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.ArrayList</span><span class="variable">$Itr</span>.checkForComodification(ArrayList<span class="selector-class">.java</span>:<span class="number">901</span>)</div><div class="line">	at java<span class="selector-class">.util</span><span class="selector-class">.ArrayList</span><span class="variable">$Itr</span>.next(ArrayList<span class="selector-class">.java</span>:<span class="number">851</span>)</div><div class="line">	at main<span class="selector-class">.exam</span><span class="selector-class">.ForeachTest</span><span class="selector-class">.main</span>(ForeachTest<span class="selector-class">.java</span>:<span class="number">15</span>)</div><div class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke0</span>(Native Method)</div><div class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.NativeMethodAccessorImpl</span><span class="selector-class">.invoke</span>(NativeMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">62</span>)</div><div class="line">	at sun<span class="selector-class">.reflect</span><span class="selector-class">.DelegatingMethodAccessorImpl</span><span class="selector-class">.invoke</span>(DelegatingMethodAccessorImpl<span class="selector-class">.java</span>:<span class="number">43</span>)</div><div class="line">	at java<span class="selector-class">.lang</span><span class="selector-class">.reflect</span><span class="selector-class">.Method</span><span class="selector-class">.invoke</span>(Method<span class="selector-class">.java</span>:<span class="number">497</span>)</div><div class="line">	at com<span class="selector-class">.intellij</span><span class="selector-class">.rt</span><span class="selector-class">.execution</span><span class="selector-class">.application</span><span class="selector-class">.AppMain</span><span class="selector-class">.main</span>(AppMain<span class="selector-class">.java</span>:<span class="number">147</span>)</div></pre></td></tr></table></figure>
<p> 报了这么一堆异常。</p>
<p>自己想了想画了个图：</p>
<p><img src="http://img.blog.csdn.net/20161229172604530" alt="这里写图片描述"></p>
<p>看图就明白了，<strong>该list每当删除一个元素时，集合的size方法的值都会减小1,这将直接导致集合中元素的索引重新排序</strong>，进一步说，就是剩余所有元素的索引值都减1，正如上图所示，而for循环语句的局部变量i仍然在递增，这将导致删除操作发生跳跃。从而导致上述代码还有删除的问题。</p>
<p>所以<font color="red">不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。</font>如下：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Iterator&lt;String&gt; </span><span class="keyword">it </span>= a.<span class="keyword">iterator(); </span><span class="meta">while</span>(<span class="keyword">it.hasNext())&#123;</span></div><div class="line"><span class="keyword">String </span>temp = <span class="keyword">it.next(); </span><span class="meta">if</span>(删除元素的条件)&#123;</div><div class="line">        <span class="keyword">it.remove();</span></div><div class="line">       &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HashMap面试题总结！]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/HashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%81/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>HashTable和HashMap的区别有哪些？</strong></p>
<p>HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。</p>
<p>理解HashMap是Hashtable的轻量级实现（非线程安全的实现，hashtable是非轻量级，线程安全的），都实现Map接口，主要区别在于：<br><a id="more"></a><br>1、由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable</p>
<p>2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。</p>
<p>3、HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。</p>
<p>4、Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。</p>
<p>5、Hashtable和HashMap扩容的方法不一样，HashTable中hash数组默认大小11，扩容方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数，增加为原来的2倍，没有加1。</p>
<p>6、两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。</p>
<p>7、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。</p>
<li>fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。</li>

<li>结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。</li>

<p><li>该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。</li><br><br><br><strong>为什么HashMap是线程不安全的，实际会如何体现？</strong></p>
<p>第一，如果多个线程同时使用put方法添加元素</p>
<p>假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。</p>
<p>第二，如果多个线程同时检测到元素个数超过数组大小*loadFactor</p>
<p>这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。</p>
<p>具体细节上的原因，可以参考：<a href="http://ifeve.com/hashmap-infinite-loop/" target="_blank" rel="external">不正当使用HashMap导致cpu 100%的问题追究</a></p>
<p><br><br><strong>能否让HashMap实现线程安全，如何做？</strong></p>
<p>1、直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。</p>
<p>2、HashMap可以通过下面的语句进行同步：</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Collections.synchronizeMap(hashMap)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>3、直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。</p>
<p><br><br><strong>Collections.synchronizeMap(hashMap);又是如何保证了HashMap线程安全？</strong></p>
<p>直接分析源码吧</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// synchronizedMap方法</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> SynchronizedMap&lt;&gt;(m);</div><div class="line">   &#125;</div><div class="line"><span class="comment">// SynchronizedMap类</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> class SynchronizedMap&lt;K,V&gt;</div><div class="line">       implements Map&lt;K,V&gt;, Serializable &#123;</div><div class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1978198479659022715</span>L;</div><div class="line"> </div><div class="line">       <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;K,V&gt; m;     <span class="comment">// Backing Map</span></div><div class="line">       <span class="keyword">final</span> <span class="keyword">Object</span>      mutex;        <span class="comment">// Object on which to synchronize</span></div><div class="line"> </div><div class="line">       SynchronizedMap(Map&lt;K,V&gt; m) &#123;</div><div class="line">           <span class="keyword">this</span>.m = Objects.requireNonNull(m);</div><div class="line">           mutex = <span class="keyword">this</span>;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       SynchronizedMap(Map&lt;K,V&gt; m, <span class="keyword">Object</span> mutex) &#123;</div><div class="line">           <span class="keyword">this</span>.m = m;</div><div class="line">           <span class="keyword">this</span>.mutex = mutex;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       <span class="keyword">public</span> <span class="built_in">int</span> <span class="built_in">size</span>() &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">size</span>();&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> isEmpty() &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.isEmpty();&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> containsKey(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsKey(<span class="built_in">key</span>);&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">public</span> <span class="built_in">boolean</span> containsValue(<span class="keyword">Object</span> value) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.containsValue(value);&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.<span class="built_in">get</span>(<span class="built_in">key</span>);&#125;</div><div class="line">       &#125;</div><div class="line"> </div><div class="line">       <span class="keyword">public</span> V put(K <span class="built_in">key</span>, V value) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.put(<span class="built_in">key</span>, value);&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">public</span> V remove(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">           <span class="keyword">synchronized</span> (mutex) &#123;<span class="keyword">return</span> m.remove(<span class="built_in">key</span>);&#125;</div><div class="line">       &#125;</div><div class="line">       <span class="comment">// 省略其他方法</span></div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。</p>
<p><br><br><strong>为什么HashTable的默认大小和HashMap不一样？</strong></p>
<p>前面分析了，Hashtable 的扩容方法是乘2再+1，不是简单的乘2，故hashtable保证了容量永远是奇数，结合之前分析hashmap的重算hash值的逻辑，就明白了，因为在数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数 n，则至少有(n-1)/n 数量的桶是利用不到的，故之前的hashmap 会在取模（使用位与运算代替）哈希前先做一次哈希运算，调整hash值。这里hashtable比较古老，直接使用了除留余数法，那么就需要设置容量起码不是偶数（除（近似）质数求余的分散效果好）。而JDK开发者选了11。</p>
<font color="red">感觉针对Java的hashmap和hashtable面试，或者理解，到这里就可以了，具体就是多写代码实践。</font>]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈HashMap]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E6%B5%85%E8%B0%88HashMap/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>什么是Map?</strong></p>
<font color="#008080">Map用于保存具有key-value映射关系的数据</font><br><a id="more"></a><br>首先看图！<br><br><img src="http://img.blog.csdn.net/20161224234534698" alt="这里写图片描述"><br><br>可以看出Java 中有四种常见的Map实现——HashMap, TreeMap, Hashtable和LinkedHashMap：<br><br>·HashMap就是一张hash表，键和值都没有排序。<br><br>·TreeMap以红黑树结构为基础，键值可以设置按某种顺序排列。<br><br>·LinkedHashMap保存了插入时的顺序。<br><br>·Hashtable是同步的(而HashMap是不同步的)。所以如果在线程安全的环境下应该多使用HashMap，而不是Hashtable，因为Hashtable对同步有额外的开销。<br><br><br><strong>我们在这里简单的说说HashMap：</strong><br><br>(1)HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。<br><br>(2)HashMap是非线程安全的，只用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。<br><br>(3)HashMap 实现了Serializable接口，因此它支持序列化。<br><br>(4)HashMap还实现了Cloneable接口，故能被克隆。<br><br><br><br>先从<strong>HashMap的存储结构</strong>说起：<br><br><img src="http://img.blog.csdn.net/20161224235308725" alt="这里写图片描述"><br><br>蓝色部分即代表哈希表本身（其实是一个数组），数组的每个元素都是一个单链表的头节点，链表是用来解决hash地址冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中保存。<br><br><strong>HashMap的构造方法中有两个很重要的参数：</strong><font color="#008080">初始容量和加载因子</font>

<p>这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。</p>
<p>JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方。</p>
<p><strong>我们来分析一下HashMap中用的最多的两个方法put和get的源码</strong></p>
<blockquote>
<p>get()：</p>
</blockquote>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 获取key对应的value</span></div><div class="line">    <span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="built_in">key</span> == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> getForNullKey();</div><div class="line">        <span class="comment">// 获取key的hash值</span></div><div class="line">        <span class="built_in">int</span> hash = hash(<span class="built_in">key</span>.hashCode());</div><div class="line">        <span class="comment">// 在“该hash值对应的链表”上查找“键值等于key”的元素</span></div><div class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">Object</span> k;</div><div class="line">            <span class="comment">// 判断key是否相同</span></div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.<span class="built_in">key</span>) == <span class="built_in">key</span> || <span class="built_in">key</span>.equals(k)))</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 没找到则返回null</span></div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！</span></div><div class="line">    <span class="keyword">private</span> V getForNullKey() &#123;</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[<span class="number">0</span>]; e != <span class="keyword">null</span>; e = e.next) &#123;</div><div class="line">            <span class="keyword">if</span> (e.<span class="built_in">key</span> == <span class="keyword">null</span>)</div><div class="line">                <span class="keyword">return</span> e.value;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。</p>
<blockquote>
<p>put()：<br></p>
</blockquote>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 将“key-value”添加到HashMap中</span></div><div class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">put</span>(<span class="params">K key, V <span class="keyword">value</span></span>) </span>&#123;</div><div class="line">        <span class="comment">// 若“key为null”，则将该键值对添加到table[0]中。</span></div><div class="line">        <span class="keyword">if</span> (key == <span class="literal">null</span>)</div><div class="line">            <span class="keyword">return</span> putForNullKey(<span class="keyword">value</span>);</div><div class="line">        <span class="comment">// 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。</span></div><div class="line">        <span class="keyword">int</span> hash = hash(key.hashCode());</div><div class="line">        <span class="keyword">int</span> i = indexFor(hash, table.length);</div><div class="line">        <span class="keyword">for</span> (Entry&lt;K, V&gt; e = table[i]; e != <span class="literal">null</span>; e = e.next) &#123;</div><div class="line">            Object k;</div><div class="line">            <span class="comment">// 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！</span></div><div class="line">            <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.<span class="keyword">equals</span>(k))) &#123;</div><div class="line">                V oldValue = e.<span class="keyword">value</span>;</div><div class="line">                e.<span class="keyword">value</span> = <span class="keyword">value</span>;</div><div class="line">                e.recordAccess(<span class="keyword">this</span>);</div><div class="line">                <span class="keyword">return</span> oldValue;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// 若“该key”对应的键值对不存在，则将“key-value”添加到table中</span></div><div class="line">        modCount++;</div><div class="line">        <span class="comment">// 将key-value添加到table[i]处</span></div><div class="line">        addEntry(hash, key, <span class="keyword">value</span>, i);</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。</span></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addEntry</span>(<span class="params"><span class="keyword">int</span> hash, K key, V <span class="keyword">value</span>, <span class="keyword">int</span> bucketIndex</span>) </span>&#123;</div><div class="line">        <span class="comment">// 保存“bucketIndex”位置的值到“e”中</span></div><div class="line">        Entry&lt;K, V&gt; e = table[bucketIndex];</div><div class="line">        <span class="comment">// 设置“bucketIndex”位置的元素为“新Entry”，</span></div><div class="line">        <span class="comment">// 设置“e”为“新Entry的下一个节点”</span></div><div class="line">        table[bucketIndex] = <span class="keyword">new</span> Entry&lt;K, V&gt;(hash, key, <span class="keyword">value</span>, e);</div><div class="line">        <span class="comment">// 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小</span></div><div class="line">        <span class="keyword">if</span> (size++ &gt;= threshold)</div><div class="line">            resize(<span class="number">2</span> * table.length);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。</p>
<font color="#008080"><strong>接下来重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。</strong></font>

<blockquote>
<p>由hash值找到对应索引的方法如下：</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> h &amp; (length<span class="number">-1</span>);</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。</p>
<blockquote>
<p>计算hash值的方法如下:</p>
</blockquote>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">static</span> int hash(int h) &#123;</div><div class="line">           <span class="attribute">h</span><span class="regexp"> ^=</span> (h &gt;&gt;&gt; <span class="number">20</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">12</span>);</div><div class="line">           <span class="attribute">return</span> h<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">7</span>)<span class="regexp"> ^</span> (h &gt;&gt;&gt; <span class="number">4</span>);</div><div class="line">       &#125;</div></pre></td></tr></table></figure>
<p>JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 &amp; (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。<font color="red">于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。</font></p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[nginx 基本入门(至今为止见过最好的 nginx 入门文章，没有之一。)]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/nginx-%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8-%E8%87%B3%E4%BB%8A%E4%B8%BA%E6%AD%A2%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84-nginx-%E5%85%A5%E9%97%A8%E6%96%87%E7%AB%A0%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80%E3%80%82/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>本文转自<a href="http://www.jianshu.com/p/93ac21161ac6" target="_blank" rel="external">StuQ</a> </p>
</blockquote>
<p><br><br>这篇教程简单介绍了 nginx 并且讲解了一些 nginx 可以解决的简单任务。这里，我们假设 nginx 已经安装在读者的机器上。如果没有，可以看一下如何安装 nginx。这篇教程主要讲解的是如果启用和停止 ngixn，和重新加载配置，描述配置文件的基本结构和怎样搭建一个 nginx 静态辅助器，怎样配置 nginx 作为一个代理服务器来。 nginx 有一个主进程和其他子进程。主进程的主要工作是加载和执行配置文件，并且驻留子进程。子进程用来作为实际的请求处理。nginx 采取基于事件的模型和 OS 依赖的机制，在多个子进程之间高效的分配请求。子进程的个数会直接写在配置文件中并且，对于给定的配置可以是固定的，或者根据可用的 CPU 核数自动的进行调整（参考子进程）。 nginx 和它模块的工作方式是在配置文件中写好的。默认情况下，这个配置文件通常命名为 nginx.conf 并且会放置在 /usr/local/nginx/conf，/etc/nginx，或者 /usr/local/etc/nginx。<br><a id="more"></a><br>启用，停止和重载配置</p>
<p>运行可执行文件就可以开启 nginx，比如:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// -c 为 nginx 的配置文件</span></div><div class="line"></div><div class="line">nginx -c/usr/<span class="keyword">local</span>/nginx/<span class="keyword">conf</span>/nginx.<span class="keyword">conf</span></div></pre></td></tr></table></figure>
<p>如果，nginx 已经开启，那么它就可以通过使用 -s 参数的可执行命令控制。使用下列格式：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx -s <span class="keyword">signal</span><span class="string"></span></div></pre></td></tr></table></figure>
<p>signal 可以为下列命令之一：</p>
<p>stop — 直接关闭 nginx</p>
<p>quit — 会在处理完当前正在的请求后退出，也叫优雅关闭</p>
<p>reload — 重新加载配置文件，相当于重启</p>
<p>reopen — 重新打开日志文件 比如，等待当前子进程处理完正在执行的请求后，结束 nginx 进程，可以使用下列命令：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx <span class="_">-s</span> quit</div></pre></td></tr></table></figure>
<p>执行该命令的用户需要和启动的 nginx 的用户一致。 如果重载配置文件的命令没有传递给 nginx 或者 nginx 没有重启，那么配置文件的改动是不会被使用的。重载配置文件的命令可以使用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx <span class="_">-s</span> reload</div></pre></td></tr></table></figure>
<p>一旦主进程接收到重载配置文件的命令后，它会先检查配置文件语法的合法性，如果没有错误，则会重新加载配置文件。如果成功，则主进程会重新创建一个子进程并且发送关闭请求给以前的子进程。如果没有成功，主进程会回滚改动并且继续使用以前的配置。老的子进程在接受关闭的命令后，会停止接受新的请求并且继续处理当前的请求，直到处理完毕。之后，该子进程就直接退出了。 在 Unix 工具的帮助下，比如使用 kill 工具，该信号会被发送给 nginx 进程。在这种情况下，信号会被直接发送给带有进程 ID 的进程。nginx 的主进程的进程 ID 是写死在 nginx.pid 文件中的。该文件通常放在 /usr/local/nginx/logs 或者 /var/run 目录下。比如，如果主进程的 ID 是 1628，为了发送 QUIT 信号来使 nginx 优雅退出，可以执行：kill -s QUIT 1628</p>
<p>为了得到所有正在运行的 nginx 进程，我们可能会使用到 ps 工具，比如，像下列的方式：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">$ ps -ax | grep nginx</div><div class="line"></div><div class="line"><span class="comment">// 结果为：（下面是单核 CPU 的情况） </span></div><div class="line"></div><div class="line"><span class="number">516</span> pts/<span class="number">0</span>    D+    <span class="number">0</span>:<span class="number">00</span> grep --color=auto nginx </div><div class="line"></div><div class="line"><span class="number">1156</span> ?        S      1:<span class="number">22</span> <span class="string">nginx:</span> worker process</div><div class="line"></div><div class="line"><span class="number">27999</span> ?        Ss    0:<span class="number">00</span> <span class="string">nginx:</span> master process ./nginx</div></pre></td></tr></table></figure>
<p>更多关于发送信号给 nginx，可以参考<a href="https://link.zhihu.com/?target=http://nginx.org/en/docs/ngx_core_module.html#worker_processes" target="_blank" rel="external">nginx 控制</a>。<br><br><br><strong><h2>配置文件结构</h2></strong></p>
<p>nginx 是由一些模块组成，我们一般在配置文件中使用一些具体的指令来控制它们。指令被分为简单指令和块级命令。一个简单的指令是由名字和参数组成，中间用空格分开，并以分号结尾。例如：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">//</span> 简单指令</div><div class="line"></div><div class="line">root <span class="regexp">/data/</span>www;</div></pre></td></tr></table></figure>
<p>块级指令和简单指令一样有着类似的结构，但是末尾不是分号而是用 {和} 大括号包裹的额外指令集。如果一个块级指令的大括号里有其他指令，则它被叫做一个上下文（比如：<a href="http://nginx.org/en/docs/ngx_core_module.html#events" target="_blank" rel="external">events</a>，<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#httph" target="_blank" rel="external">Module ngx_http_core_module</a>，<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#servers" target="_blank" rel="external">server</a>，和<a href="http://nginx.org/en/docs/http/ngx_http_core_module.html#location" target="_blank" rel="external">location</a>）。 在配置文件中，没有放在任何上下文中的指令都是处在主上下文中。events 和 http 的指令是放在主上下文中，server 放在 http 中, location 放在 server 中。</p>
<p>以 # 开头的行，会被当做注释。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="comment"># this is a comment</span></div><div class="line"></div><div class="line"><span class="section">events</span> &#123;  </div><div class="line"></div><div class="line">    <span class="attribute">worker_connections</span>  <span class="number">4096</span>;  <span class="comment">## Default: 1024</span></div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="section">http</span> &#123;    </div><div class="line"></div><div class="line">        <span class="section">server</span> &#123;          </div><div class="line"></div><div class="line">                <span class="attribute">listen</span>      <span class="number">80</span>;        </div><div class="line"></div><div class="line">                <span class="attribute">server_name</span>  domain1.com www.domain1.com;        </div><div class="line"></div><div class="line">                <span class="attribute">access_log</span>  logs/domain1.access.log  main;        </div><div class="line"></div><div class="line">                <span class="attribute">root</span>        html;        </div><div class="line"></div><div class="line">                <span class="attribute">location</span> <span class="regexp">~ \.php$</span> &#123;          </div><div class="line"></div><div class="line">                    <span class="attribute">fastcgi_pass</span>  <span class="number">127.0.0.1:1025</span>;        </div><div class="line"></div><div class="line">                &#125;    </div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><br><br><strong><h2>静态服务器</h2></strong></p>
<p>一个重要的网络服务器的任务是处理文件（比如图片或者静态 HTML 文件）。这里，你会实践一个例子，文件会从不同的目录中映射（取决于请求）：/data/www（放置 HTML 文件）和 /data/images（放置图片）。这需要配置一下文件，将带有两个 location 的指令的 server 的块级命令放在 server 指令中。 首先，创建一个 /data/www 目录，然后放置一个事先写好内容的 index.html 文件。接着，创建一个 /data/images 目录，然后放置一些图片。 下一步，打开配置文件。默认的配置文件已经包含了一些关于 server 指令的样式，大多数情况下直接把他们给注释掉。现在，注释掉其他的区块，然后写一个新的 server 区块：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="class">http </span>&#123;    </div><div class="line"></div><div class="line">        <span class="class">server </span>&#123;    </div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通常，该配置文件可能会包含多个 server 指令。这些 server 指令监听不同的端口和服务器名。一旦 nginx 决定哪个服务进程处理请求，它会根据在 server 块级指令中定义好的 location 指令的参数，来匹配请求头中指定的 URI。 将下列 location 指令添加到 server 指令中：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">location</span> <span class="title">/ &#123;    </span></div><div class="line"></div><div class="line">        root /data/www;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该 location 指令相对于请求中的 URI 执行了 “/” 的前缀。为了匹配请求，URI 会被添加到 root 命令指定的路径后，即 /data/www，得到本地文件系统中请求文件的路径。如果，有几个 location 匹配到，那么 nginx 会选择最长的前缀。上面的 location 提供了长度为 1 的前缀，所以，仅当其他的 location 匹配失败后，该指令才会使用。 接着，添加第二个 location 区块：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">location</span> <span class="title">/images</span>/ &#123;    </div><div class="line"></div><div class="line">        root /data;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>它会匹配到以 /images/ 开头的请求（location / 也会匹配到该请求，只是前缀更短） server 块级命令的配置结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;   </div><div class="line"></div><div class="line">        <span class="keyword">location</span> <span class="title">/ &#123;       </span></div><div class="line"></div><div class="line">                root /data/www;   </div><div class="line"></div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        <span class="keyword">location</span> <span class="title">/images</span>/ &#123;       </div><div class="line"></div><div class="line">                root /data;   </div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这已经是一个可用的服务器配置，它监听标准的 80 端口并且可以在本地上通过 <a href="http://localhost/" target="_blank" rel="external">http://localhost/</a> 访问。对于 URI 以 /images/ 开头的请求，服务器会从 /data/images 目录中，返回对应的文件。例如，nginx 会返回 /data/images/example.png 文件，当接收到 <a href="http://localhost/images/example.png" target="_blank" rel="external">http://localhost/images/example.png</a> 的请求响应时。如果该文件不存在，nginx 会返回一个 404 错误的响应。没有以 /images/ 开头的 URI 的请求，将会直接映射到 /data/www 目录中。比如，响应 <a href="http://localhost/some/example.html" target="_blank" rel="external">http://localhost/some/example.html</a> 的请求，nginx 会发送 /data/www/some/example.html 文件。 为了使用新的配置文件，如果还没开启 nginx 需要先开启，然后将重载信号发送给 nginx 的主进程，通过执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nginx <span class="_">-s</span> reload</div></pre></td></tr></table></figure>
<p>如果你发现有些地方出了问题，你可以在 /usr/local/nginx/logs 或者 /var/log/nginx 目录下的 access.log 和 error.log 文件中，找到原因。<br><br><br><strong><h2>搭建一个简易的代理服务</h2></strong></p>
<p>nginx 常常用来作为代理服务器，这代表着服务器接收请求，然后将它们传递给被代理服务器，得到请求的响应，再将它们发送给客户端。 我们将配置一个基本的代理服务器，它会处理本地图片文件的请求并返回其他的请求给被代理的服务器。在这个例子中，两个服务器都会定义在一个 nginx 实例中。 首先，通过在 nginx 配置文件中添加另一个 server 区块，来定义一个被代理的服务器，像下面的配置：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="section">server</span> &#123;   </div><div class="line"></div><div class="line">        <span class="attribute">listen</span> <span class="number">8080</span>;   </div><div class="line"></div><div class="line">        <span class="attribute">root</span> /data/up1;   </div><div class="line"></div><div class="line">        <span class="attribute">location</span> / &#123;   </div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面就是一个简单的服务器，它监听在 8080 端口（之前，listen 并没被定义，是因为默认监听的 80 端口）并且会映射所有的请求给 本地文件目录 /data/up1。创建该目录，然后添加 index.html 文件。注意，root 指令是放在 server 上下文中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。 接着，使用前面章节中的 server 配置，然后将它改为一个代理服务配置。在第一个 location 区块中，放置已经添加被代理服务器的协议，名字和端口等参数的proxy_pass指令（在这里，就是 <a href="http://localhost:8080）" target="_blank" rel="external">http://localhost:8080）</a>:</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server &#123;   </div><div class="line"></div><div class="line">        <span class="keyword">location</span> <span class="title">/ &#123;</span></div><div class="line"></div><div class="line">                proxy_pass http://localhost:<span class="number">8080</span>;   </div><div class="line"></div><div class="line">        &#125;   </div><div class="line"></div><div class="line">        <span class="keyword">location</span> <span class="title">/images</span>/ &#123;</div><div class="line"></div><div class="line">               root /data;   </div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们将修改第二个 location 区块，使他返回一些典型后缀的图片文件请求，现在它只会映射带有 /images/ 前缀的请求到 /data/images 目录下。修改后的 location 指令如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">location</span> <span class="title">~ \.(gif</span>|jpg|png)$&#123;</div><div class="line"></div><div class="line">        root/data/images;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该参数是一个正则表达式，它会匹配所有以 .gif，.jpg 或者 .png 结尾的 URIs。一个正则表达式需要以 ~ 开头。匹配到的请求会被映射到 /data/images 目录下。 当 nginx 在选择 location 去响应一个请求时，它会先检测带有前缀的 location 指令，记住先是检测带有最长前缀的 location，然后检测正则表达式。如果有一个正则的匹配的规则，nginx 会选择该 location，否则，会选择之前缓存的规则。 最终，一个代理服务器的配置结果如下：</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">server&#123;</div><div class="line"></div><div class="line">        location<span class="class">/&#123;</span></div><div class="line"><span class="symbol"></span></div><div class="line">                proxy_passhttp:<span class="comment">//localhost:8080/;</span></div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        location~\.(gif|jpg|png)$&#123;</div><div class="line"></div><div class="line">                root<span class="meta-keyword">/data/</span>images;</div><div class="line"></div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该服务器会选择以 .gif，.jpg，或者 .png 结束的请求并且映射到 /data/images 目录（通过添加 URI 给 root 指令的参数），接着将其他所有的请求映射到上述被代理的服务器。 为了使用新的配置，像前几个章节描述的一样，需要向 nginx 发送重载信号。 这还有很多<a href="http://nginx.org/en/docs/http/ngx_http_proxy_module.html" target="_blank" rel="external">其他的指令</a>，可以用于进一步配置代理连接。</p>
]]></content>
      
        <categories>
            
            <category> WebWebWeb </category>
            
        </categories>
        
        
        <tags>
            
            <tag> nginx </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java泛型总结]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>一. 我们为什么需要泛型？</strong></p>
<p>首先，我们看下下面这段简短的代码:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class GenericTest &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        List list = <span class="keyword">new</span> ArrayList();</div><div class="line">        list.<span class="built_in">add</span>(<span class="string">"justdoit"</span>);</div><div class="line">        list.<span class="built_in">add</span>(<span class="string">"core"</span>);</div><div class="line">        list.<span class="built_in">add</span>(<span class="number">100</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</div><div class="line">            <span class="keyword">String</span> name = (<span class="keyword">String</span>) list.<span class="built_in">get</span>(i); <span class="comment">// 1</span></div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>我们定义一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。</p>
<p> <strong>在如上的编码过程中，我们发现主要存在两个问题：</strong></p>
<p>1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。</p>
<p>2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。</p>
<font color="#008080"><strong>那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。</strong></font>

<p><strong>二.什么是泛型？</strong></p>
<p>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p>
<p>这样说有点复杂，我们来看下上面那个例子采用泛型的写法:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.ArrayList;</div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class GenericTest_2 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="comment">/*</span></div><div class="line">        List list = new ArrayList();</div><div class="line">        list.add("justdoit");</div><div class="line">        list.add("core");</div><div class="line">        list.add(100);</div><div class="line">        */</div><div class="line"></div><div class="line">        List&lt;<span class="keyword">String</span>&gt; list = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</div><div class="line">        list.<span class="built_in">add</span>(<span class="string">"justdoit"</span>);</div><div class="line">        list.<span class="built_in">add</span>(<span class="string">"core"</span>);</div><div class="line">        <span class="comment">//list.add(100);   // 1  提示编译错误</span></div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; list.<span class="built_in">size</span>(); i++) &#123;</div><div class="line">            <span class="keyword">String</span> name = list.<span class="built_in">get</span>(i); <span class="comment">// 2</span></div><div class="line">            System.out.<span class="built_in">println</span>(<span class="string">"name:"</span> + name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List&lt; String&gt;，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。</p>
<p>结合上面的泛型定义，我们知道在List&lt; String&gt;中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">Collection</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    Object[] toArray();</div><div class="line"></div><div class="line">    &lt;T&gt; T[] toArray(T[] a);</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">containsAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">removeAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">retainAll</span><span class="params">(Collection&lt;?&gt; c)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">ListIterator&lt;E&gt; <span class="title">listIterator</span><span class="params">(<span class="keyword">int</span> index)</span></span>;</div><div class="line"></div><div class="line">    <span class="function">List&lt;E&gt; <span class="title">subList</span><span class="params">(<span class="keyword">int</span> fromIndex, <span class="keyword">int</span> toIndex)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到，在List接口中采用泛型化定义之后，&lt; E&gt;中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。</p>
<p>自然的，ArrayList作为List接口的实现类，其定义形式是:</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt; </span></div><div class="line">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> &#123;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> add(E e) &#123;</div><div class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">        elementData[size++] = e;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">public</span> E get(<span class="keyword">int</span> <span class="keyword">index</span>) &#123;</div><div class="line">        rangeCheck(<span class="keyword">index</span>);</div><div class="line">        checkForComodification();</div><div class="line">        <span class="keyword">return</span> ArrayList.<span class="keyword">this</span>.elementData(offset + <span class="keyword">index</span>);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">//...省略掉其他具体的定义过程</span></div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们可以从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。</p>
<p><strong>三.自定义泛型接口、泛型类和泛型方法</strong></p>
<p>从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。</p>
<p>自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_3</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        Box&lt;String&gt; name = new Box&lt;String&gt;(<span class="string">"core"</span>);</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"name:"</span> + name.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> T <span class="keyword">data</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Box() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Box(T <span class="keyword">data</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> T getData() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericTest_4 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line"></div><div class="line">        Box&lt;<span class="keyword">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="keyword">String</span>&gt;(<span class="string">"core"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"name class:"</span> + name.getClass());      <span class="comment">// CoreJava.day_5.Box</span></div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"age class:"</span> + age.getClass());        <span class="comment">// CoreJava.day_5.Box</span></div><div class="line">        System.out.<span class="built_in">println</span>(name.getClass() == age.getClass());    <span class="comment">// true</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。</p>
<p>究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。</p>
<font color="#008080"><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></font>


<p><strong>四.类型通配符</strong></p>
<p>接着上面的结论，我们知道，Box&lt; Number&gt;和Box&lt; Integer&gt;实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box&lt; Number&gt;和Box&lt; Integer&gt;是否可以看成具有父子关系的泛型类型呢？</p>
<p>为了弄清这个问题，我们继续看下下面这个例子:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_6</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Box&lt;Number&gt; name = <span class="keyword">new</span> Box&lt;Number&gt;(<span class="number">99</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line"></div><div class="line">        <span class="comment">//The method getData(Box&lt;Number&gt;) in the type GenericTest is</span></div><div class="line">        <span class="comment">//not applicable for the arguments (Box&lt;Integer&gt;)</span></div><div class="line">        getData(age);   <span class="comment">// 1</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">getData</span><span class="params">(Box&lt;Number&gt; data)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们发现，在代码//1处出现了错误提示信息：The method getData(Box&lt; Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt; Integer&gt;)。显然，通过提示信息，我们知道Box&lt; Number&gt;在逻辑上不能视为Box&lt; Integer&gt;的父类。那么，原因是什么呢？</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest_5</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> static void main(String[] args) &#123;</div><div class="line"></div><div class="line">        Box&lt;Integer&gt; a = new Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;Number&gt; b = a;  <span class="comment">// 1</span></div><div class="line">        Box&lt;<span class="built_in">Float</span>&gt; f = new Box&lt;<span class="built_in">Float</span>&gt;(<span class="number">3.14</span>f);</div><div class="line">        b.setData(f);        <span class="comment">// 2</span></div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> static void getData(Box&lt;Number&gt; <span class="keyword">data</span>) &#123;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"data :"</span> + <span class="keyword">data</span>.getData());</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Box</span>&lt;<span class="type">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> T <span class="keyword">data</span>;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Box() &#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> Box(T <span class="keyword">data</span>) &#123;</div><div class="line">        setData(<span class="keyword">data</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> T getData() &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">data</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> void setData(T <span class="keyword">data</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.<span class="keyword">data</span> = <span class="keyword">data</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。</p>
<p>假设Box&lt; Number&gt;在逻辑上可以视为Box&lt; Integer&gt;的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，<font color="#008080"><strong>在逻辑上Box&lt; Number&gt;不能视为Box&lt; Integer&gt;的父类。</strong></font></p>
<p>好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总不能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，<font color="#008080"><strong>因此，我们需要一个在逻辑上可以用来表示同时是Box&lt; Integer&gt;和Box&lt; Number&gt;的父类的一个引用类型，由此，类型通配符应运而生。</strong></font></p>
<p>类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box&lt; Integer&gt;、Box&lt; Number&gt;…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericTest_7 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line"></div><div class="line">        Box&lt;<span class="built_in">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="built_in">String</span>&gt;(<span class="string">"core"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;<span class="built_in">Number</span>&gt; <span class="built_in">number</span> = <span class="keyword">new</span> Box&lt;<span class="built_in">Number</span>&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(<span class="built_in">number</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> getData(Box&lt;?&gt; data) &#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>有时候，<font color="#008080"><strong>我们还可能听到类型通配符上限和类型通配符下限</strong>。具体有是怎么样的呢？</font></p>
<p>在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_5;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/15</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> GenericTest_8 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> main(<span class="built_in">String</span>[] args) &#123;</div><div class="line"></div><div class="line">        Box&lt;<span class="built_in">String</span>&gt; name = <span class="keyword">new</span> Box&lt;<span class="built_in">String</span>&gt;(<span class="string">"core"</span>);</div><div class="line">        Box&lt;Integer&gt; age = <span class="keyword">new</span> Box&lt;Integer&gt;(<span class="number">712</span>);</div><div class="line">        Box&lt;<span class="built_in">Number</span>&gt; <span class="built_in">number</span> = <span class="keyword">new</span> Box&lt;<span class="built_in">Number</span>&gt;(<span class="number">314</span>);</div><div class="line"></div><div class="line">        getData(name);</div><div class="line">        getData(age);</div><div class="line">        getData(<span class="built_in">number</span>);</div><div class="line"></div><div class="line">        <span class="comment">//getUpperNumberData(name); // 1</span></div><div class="line">        getUpperNumberData(age);    <span class="comment">// 2</span></div><div class="line">        getUpperNumberData(<span class="built_in">number</span>); <span class="comment">// 3</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> getData(Box&lt;?&gt; data) &#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="built_in">void</span> getUpperNumberData(Box&lt;? extends <span class="built_in">Number</span>&gt; data) &#123;</div><div class="line">        System.out.println(<span class="string">"data :"</span> + data.getData());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。</p>
<font color="#008080"><strong>类型通配符上限通过形如Box&lt; ? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt; ? super Number&gt;形式，其含义与类型通配符上限正好相反</strong>，</font>在此不作过多阐述了。<br><br><br><br><strong>五.话外篇</strong><br><br>本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。<br><br><font color="red"><strong>对于泛型，最主要的还是需要理解其背后的思想和目的。</strong></font>





]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 泛型 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java 8 最佳技巧]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java-8-%E6%9C%80%E4%BD%B3%E6%8A%80%E5%B7%A7/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><blockquote>
<p>翻译文章<br>转自<a href="https://muyinchen.github.io/2016/12/13/Java%208%20%E6%9C%80%E4%BD%B3%E6%8A%80%E5%B7%A7/#more" target="_blank" rel="external">一叶知秋</a></p>
</blockquote>
<p><br><br>在过去的几年中，我一直使用Java 8 进行了很多的编码工作，用于开发 <a href="http://trishagee.github.io/presentation/java8_in_anger/" target="_blank" rel="external">新应用</a> 和 <a href="http://trishagee.github.io/presentation/refactoring_to_java_8/" target="_blank" rel="external">迁移遗留应用</a> ，我觉得是时候写一些有用的”最佳实践”。我个人不喜欢”最佳实践”这个术语，因为它意味着“一刀切”的解决方案，当然编码工作是不会这样的–这是因为我们开发人员会想出适合我们的方案。但我发现我对Java8特别的喜欢，它让我的生活更轻松一点，所以我想就此话题展开讨论。<br><a id="more"></a><br>Optional</p>
<p>Optional是一个被严重低估的功能, 它消除了很多困扰着我们的 NullPointerExceptions。它在代码边界（包括你调用和提供 API）处理上特别有用，因为它允许你和你调用的代码说明程序运行的期望结果。</p>
<p>然而，如果没有必要的思考和设计，那么就会导致一个小变化而影响大量的类，也会导致可读性变差。这里有一些关于如何高效使用Optional的提示。<br><br><br>Optional <strong>应该只用于返回类型</strong></p>
<p>…不能是参数和属性. 阅读 <a href="http://blog.joda.org/2015/08/java-se-8-optional-pragmatic-approach.html" target="_blank" rel="external">这个博客</a> 了解怎样使用 Optional。 幸运的是, IntelliJ IDEA 在打开 <a href="https://www.jetbrains.com/help/idea/2016.2/code-inspection.html" target="_blank" rel="external">inspection</a> 功能的情况下会检查你是否遵循了这些建议。</p>
<p><img src="http://img.blog.csdn.net/20161214162906891" alt=""></p>
<p>可选值应该在使用的地方进行处理.IntelliJ IDEA 的建议可以防止你不恰当的使用Optional, 所以你应该立即处理你发现的不恰当使用Optional。(根据自己的理解翻译)</p>
<p><img src="http://img.blog.csdn.net/20161214163003908" alt="这里写图片描述"></p>
<p><br><br><strong>你不应该简单的调用</strong> get()<br>Optional的目的是为了表示此值有可能为空，且让你有能力来应付这种情况。因此，在使用值之前进行检查是非常重要的。在某些情况下简单的调用get()而没有先使用isPresent()进行检查是一样会导致空指针问题。幸运的是，IntelliJ IDEA 任然会检查出这个问题并警告你。</p>
<p><img src="http://img.blog.csdn.net/20161214163211900" alt="这里写图片描述"><br><br><br><strong>有可能是一个更优雅的方式</strong></p>
<p>isPresent() 与  get() 结合 使用的技巧 …</p>
<p><img src="http://img.blog.csdn.net/20161214163327369" alt="这里写图片描述"></p>
<p>…但还有更优雅的解决方案。你可以使用 orElse方法来使得当它为null时给出一个代替的值。</p>
<p><img src="http://img.blog.csdn.net/20161214163422572" alt="这里写图片描述"></p>
<p>…或者使用 orElseGet方法来处理上述相同情况。这个例子和上面的看起来好像一样，但本例是可以调用 supplier 接口的 实现 ,，因此如果它是一个高开销的方法，可以使用 lambda 表达式来获得更好的性能。</p>
<p><img src="http://img.blog.csdn.net/20161214163525758" alt="这里写图片描述"></p>
<p><strong>使用Lambda表达式</strong></p>
<p>Lambda 表达式 是 Java 8 的卖点之一.。即使你还没有使用过Java 8， 到目前你也可能有一些基本的了解。但在Java编程中还是一种新的方式，它也不是明显的”最佳实践” 。 这里有一些我遵循的指南。</p>
<p><strong>保持简短</strong></p>
<p>函数式程序员更愿意使用较长的lambda 表达式，但我们这些仅仅使用Java很多年的程序员来说更容易保持lambda 表达式的短小。你甚至更喜欢把它们限制在一行，更容易把较长的表达式 重构 到一个方法中。</p>
<p><img src="http://img.blog.csdn.net/20161214163709620" alt="这里写图片描述"></p>
<p>把它们变成一个方法引用， 方法引用看起来有一点陌生，但却值得这样做，因为在某些情况有助于提高可读性，后面我再谈可读性。</p>
<p><img src="http://img.blog.csdn.net/20161214163740278" alt="这里写图片描述"></p>
<p><strong>明确的</strong><br>(作者应该想要表达的是: 参数命名规范，要有意义；有更好的翻译请修正)</p>
<p>lambda 表达式中类型信息已经丢失了，因此你会发现包含类型信息的参数会更有用。</p>
<p><img src="http://img.blog.csdn.net/20161214163826731" alt="这里写图片描述"></p>
<p>如你所见，这样会比较麻烦。因此我更喜欢给参数一个更有意义的命名。当然，你做与否， IntelliJ IDEA 都会让你看到参数的类型信息。</p>
<p><img src="http://img.blog.csdn.net/20161214163910185" alt="这里写图片描述"></p>
<p>即使是在函数式接口的lambda 表达式中:</p>
<p><img src="http://img.blog.csdn.net/20161214163951076" alt="这里写图片描述"></p>
<p><strong>针对 Lambda 表达式进行设计</strong></p>
<p>我认为lambda表达式有点像 泛型 – 泛型,我们经常使用它们 (例如, 给 List&lt;&gt; 添加类型信息 )，但不常见的是我们把一个方法或类泛型化 (如:  Person&lt;’T&gt; )。同样的, 它就像我们使用通过lambdas包装的 Streams API，但对我们来说更罕见的是创建一个需要 lambda 表达式参数的方法。</p>
<p><strong>IntelliJ IDEA 可以帮助你引入一个函数化的参数</strong></p>
<p>这里让你可以使用 Lambda 表达式而非对象来 <a href="https://www.jetbrains.com/help/idea/2016.1/extract-functional-parameter.html" target="_blank" rel="external">创建一个参数</a> 。这个功能的好处在于其建议使用一个已有的 <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html" target="_blank" rel="external">函数接口</a> 来匹配这个规范。</p>
<p><img src="http://img.blog.csdn.net/20161214164320297" alt="这里写图片描述"></p>
<p>这个将引导我们</p>
<p><strong>使用已有的函数接口</strong></p>
<p>当开发者越来越熟悉 Java 8 代码时，我们会知道使用例如 Supplier 和 Consumer 这样的接口会发生什么，但是单独再创建一个 ErrorMessageCreator 会让我们很诧异并且很浪费时间。你可以翻阅 function package 来查看系统本身已经给我们准备了什么。</p>
<p><strong>为函数接口添加 @FunctionalInterface 注解</strong></p>
<p>如果你真的需要创建自己的函数接口，那么就需要用这个  @FunctionalInterface  注解。这个注解似乎没多大用处，但是  IntelliJ IDEA  会在接口不满足这个注解要求的情况下予以提示。例如你没有指定要继承的方法：</p>
<p><img src="http://img.blog.csdn.net/20161214164518523" alt="这里写图片描述"></p>
<p>指定太多的方法：</p>
<p><img src="http://img.blog.csdn.net/20161214164547695" alt="这里写图片描述"></p>
<p>在类中使用注解而不是在接口：</p>
<p><img src="http://img.blog.csdn.net/20161214164619204" alt="这里写图片描述"></p>
<p>Lambda 表达式可用于任意只包含单个抽象方法的接口中，但是不能用于满足该要求的抽象类。看似不符合逻辑，但实际要求必须如此。</p>
<p><br><br><strong>Streams</strong></p>
<p><a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html" target="_blank" rel="external">Stream</a> API 是Java 8的另一大卖点, 我认为到现在为止，我们仍然不知道这会对我们的编码方式有多大改变．但我发现这是一个好坏参半的功能。</p>
<p><strong>流式风格</strong></p>
<p>就我个人而言，更喜欢使用流式风格．当然你不必也这么做, 但我发现它帮助了我：</p>
<p>  ·一眼就能看出有哪些操作，它的执行顺序是什么<br>·更方便调试（虽然IntelliJ IDEA提供了 <a href="https://www.youtube.com/watch?v=rimzOolGguo&amp;feature=youtu.be&amp;t=3s" target="_blank" rel="external">在包含lambda表达式的行上设置断点的能力</a> ，为了更方便调试，把它拆分到不同的行上）* 在测试的时候允许取消一个操作<br>·在调试或测试是，可以很方便的插入peek()</p>
<p><img src="http://img.blog.csdn.net/20161214165029299" alt="这里写图片描述"></p>
<p>在我看来这样写很简洁。但是使用这种方法并没有给我们节省多少代码行。你可能需要调整代码格式化设置让代码看起来更加清晰。</p>
<p><img src="http://img.blog.csdn.net/20161214165143409" alt="这里写图片描述"></p>
<p><br><br><strong>使用方法引用</strong></p>
<p>是的，你需要一点时间来适应这个奇怪的语法。但如果使用恰当，真的可以提升代码的可读性，看看下面代码：</p>
<p><img src="http://img.blog.csdn.net/20161214165247861" alt="这里写图片描述"></p>
<p>以及使用 Objects 类的辅助方法：</p>
<p><img src="http://img.blog.csdn.net/20161214165331410" alt="这里写图片描述"></p>
<p>后面一段代码更加的明确可读。IntelliJ IDEA 通常会知道怎么将一个 Lambda 表达式进行折叠。</p>
<p><img src="http://img.blog.csdn.net/20161214165408051" alt="这里写图片描述"></p>
<p><strong>当对集合进行元素迭代时，尽可能的使用 Streams API</strong></p>
<p>…或者用新的集合方法，例如 forEach . IntelliJ IDEA 会建议你这么做：</p>
<p><img src="http://img.blog.csdn.net/20161214165535504" alt="这里写图片描述"></p>
<p>一般来说使用 Streams API 比起循环和 if 语句组合来得更加直观，例如：</p>
<p><img src="http://img.blog.csdn.net/20161214165613194" alt="这里写图片描述"></p>
<p>IntelliJ IDEA 会建议这样的写法进行重构：</p>
<p><img src="http://img.blog.csdn.net/20161214165649927" alt="这里写图片描述"></p>
<p>我做过的性能测试显示这种重构带来的结果比较奇怪，难以预测，有时候好，有时候坏，有时候没区别。一如既往的，如果你的应用对性能问题非常在意，请认真的进行衡量。</p>
<p><strong>遍历数组时请用 for 循环</strong></p>
<p>然后，使用 Java 8 并不意味着你一定要使用流 API 以及集合的新方法。IntelliJ IDEA 会建议一些做法改用流的方式重构，但你不一定非得接受 (记住 <a href="https://www.jetbrains.com/help/idea/2016.2/suppressing-inspections.html" target="_blank" rel="external">inspections can be suppressed</a> 或者 <a href="https://www.jetbrains.com/help/idea/2016.2/disabling-and-enabling-inspections.html" target="_blank" rel="external">turned off</a> ).</p>
<p>特别是对一个原始类型的小数组时，使用 for 循环的性能是最好的，而且代码更具可读性（至少对 Streams API 的新手来说是这样）：</p>
<p><img src="http://img.blog.csdn.net/20161214165851697" alt="这里写图片描述"></p>
<p>任何的技巧和提示都不是一成不变的，你应该自己决定哪里需要使用 Streams API ，而哪里还用循环操作。</p>
<p><strong>最后</strong></p>
<p>我每天都在发现一些新的东西，有时候我的偏好会有所变化。例如我过去会讨厌方法的引用。非常期待倾听你的建议。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Logger级别]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Logger%E7%BA%A7%E5%88%AB/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。日志记录器(Logger)的可用级别Level (不包括自定义级别 Level)， <a id="more"></a>以下内容就是摘自log4j API (<a href="http://jakarta.apache.org/log4j/docs/api/index.html" target="_blank" rel="external">http://jakarta.apache.org/log4j/docs/api/index.html</a>):<br><br><strong>static Level DEBUG</strong><br><br>DEBUG Level指出细粒度信息事件对调试应用程序是非常有帮助的。<br><strong>static Level INFO</strong><br><br>INFO level表明 消息在粗粒度级别上突出强调应用程序的运行过程。<br><strong>static Level WARN</strong><br><br>WARN level表明会出现潜在错误的情形。<br><strong>static Level ERROR</strong><br><br>ERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。<br><strong>static Level FATAL</strong><br><br>FATAL level指出每个严重的错误事件将会导致应用程序的退出。<br>另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j API <a href="http://jakarta.apache.org/log4j/docs/api/index.html" target="_blank" rel="external">http://jakarta.apache.org/log4j/docs/api/index.html</a>):<br><br><strong>static Level ALL</strong><br><br>ALL Level是最低等级的，用于打开所有日志记录。<br><strong>static Level OFF</strong><br><br>OFF Level是最高等级的，用于关闭所有日志记录。<br>日志记录器（Logger）的行为是分等级的。如下表所示：<br>分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。<font color="red">Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。</font>通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。<font color="red">比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。</font></p>
<font color="red">日志记录的级别有继承性，子类会记录父类的所有的日志级别。</font>]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Logger </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java接口是常量存放的最佳地点吗？]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E5%9C%B0%E7%82%B9%E5%90%97%EF%BC%9F/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天偶然看到接口中不能包含<strong>实例域</strong>或<strong>静态方法</strong>，但是却可以包含<strong>常量</strong>。<br><br>其实在之前，就知道这么回事，但是一直只是当做知道而已，现在回过头来巩固基础，觉得有必要多想想。<br><a id="more"></a><br>首先，由于java的接口中声明的字段在编译时会自动加上static final的修饰符，即声明为常量。因而接口通常是存放常量的最佳地点，因为这样可以省去很多修饰符嘛，然而在java的实际应用时却会产生一些问题。<br></p>
<p>问题的起因个人觉得有两个:<br><br>第一，是我们所使用的常量并不是一成不变的，而是相对于变量不能赋值改变。例如我们在一个项目初期定义常量π＝3.14，而由于计算精度的提高我们可能会重新定义π＝3.14159，此时整个项目对此常量的引用都应该做出改变。<br><br>第二，java是动态语言。与c++之类的静态语言不同,java对一些字段的引用可以在运行期动态进行，这种灵活性是java这样的动态语言的一大优势。也就使得我们在java项目中有时部分内容的改变不用重新编译整个项目，而只需编译改变的部分重新发布就可以改变整个应用。</p>
<p>例如，有一个interface A，一个class B，代码如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">A</span>&#123;</div><div class="line">	String name = <span class="string">"bright"</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"Class A's name = "</span> + A.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>编译A和B。<br><br>运行，输入java B，显然结果如下：<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span></span></div></pre></td></tr></table></figure></p>
<p>我们现在修改A如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">A</span></span>&#123;</div><div class="line">	<span class="keyword">String</span> name = <span class="string">"bright sea"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>编译A后重新运行B，输入java B，注意：结果如下<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span></span></div></pre></td></tr></table></figure></p>
<p>为什么不是”Class A’s name = bright sea”？让我们使用jdk提供的反编译工具javap反编译B.class看个究竟，输入：javap -c B ，结果如下：</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Compiled from B.java</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">Object</span> &#123;</span></div><div class="line">    <span class="keyword">public</span> B();</div><div class="line">    <span class="keyword">public</span> static void main(java.lang.String[]);</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">Method</span> <span class="title">B</span>(</span>)</div><div class="line">   <span class="number">0</span> aload_0</div><div class="line">   <span class="number">1</span> invokespecial<span class="meta"> #1 &lt;Method java.lang.Object()&gt;</span></div><div class="line">   <span class="number">4</span> <span class="keyword">return</span></div><div class="line"><span class="function"><span class="keyword">Method</span> <span class="title">void</span> <span class="title">main</span>(</span>java.lang.String[])</div><div class="line">   <span class="number">0</span> getstatic<span class="meta"> #2 &lt;Field java.io.PrintStream out&gt;</span></div><div class="line">   <span class="number">3</span> ldc<span class="meta"> #3 &lt;String "Class A's name = bright"&gt;</span></div><div class="line">   <span class="number">5</span> invokevirtual<span class="meta"> #4 &lt;Method void println(java.lang.String)&gt;</span></div><div class="line">   <span class="number">8</span> <span class="keyword">return</span></div></pre></td></tr></table></figure>
<p>注意到标号3的代码了吗？由于引用了一个static final 的字段，编译器已经将interface A中name的内容编译进了class B中，而不是对interface A中的name的引用。因此除非我们重新编译class B，interface A中name发生的变化无法在class B中反映。如果这样去做那么java的动态优势就消失殆尽。<br></p>
<p>解决方案，有两种解决方法。<br><br>第一种方法是不再使用常量，将所需字段放入class中声明，并去掉final修饰符。但这种方法存在一定的风险，由于不再是常量着因而在系统运行时有可能被其他类修改其值而发生错误，也就违背了我们设置它为常量的初衷，因而不推荐使用。<br><br>第二种方法，将常量放入class中声明，使用class方法来得到此常量的值。为了保持对此常量引用的简单性，我们可以使用一个静态方法。我们将A.java和B.java修改如下：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">A</span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final String name = <span class="string">"bright"</span>;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getName</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">B</span>&#123;</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</div><div class="line">		System.<span class="keyword">out</span>.println(<span class="string">"Class A's name = "</span> + A.getName());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>同样我们编译A和B。运行class B，输入java B，显然结果如下：<br>Class A’s name = bright<br>现在我们修改A如下：<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">String</span> name = <span class="string">"bright"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> getName()&#123;</div><div class="line">		<span class="keyword">return</span> name;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们再次编译A后重新运行B，输入java B：结果如下<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">Class</span> <span class="title">A</span>'<span class="title">s</span> <span class="title">name</span> = <span class="title">bright</span> <span class="title">sea</span></span></div></pre></td></tr></table></figure></p>
<p>终于得到了我们想要的结果，我们可以再次反编译B看看class B的改变，输入<br>javap -c B,结果如下：<br><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Compiled from B.java</div><div class="line">public <span class="keyword">class</span> B extends java.lang.Object &#123;</div><div class="line">    public B();</div><div class="line">    public <span class="keyword">static</span> <span class="keyword">void</span> main(java.lang.String[]);</div><div class="line">&#125;</div><div class="line">Method B()</div><div class="line">   <span class="number">0</span> aload_0</div><div class="line">   <span class="number">1</span> invokespecial <span class="meta">#1 <span class="meta-string">&lt;Method java.lang.Object()&gt;</span></span></div><div class="line">   <span class="number">4</span> <span class="keyword">return</span></div><div class="line">Method <span class="keyword">void</span> main(java.lang.String[])</div><div class="line">   <span class="number">0</span> getstatic <span class="meta">#2 <span class="meta-string">&lt;Field java.io.PrintStream out&gt;</span></span></div><div class="line">   <span class="number">3</span> new <span class="meta">#3 <span class="meta-string">&lt;Class java.lang.StringBuffer&gt;</span></span></div><div class="line">   <span class="number">6</span> dup</div><div class="line">   <span class="number">7</span> invokespecial <span class="meta">#4 <span class="meta-string">&lt;Method java.lang.StringBuffer()&gt;</span></span></div><div class="line">  <span class="number">10</span> ldc <span class="meta">#5 <span class="meta-string">&lt;String "Class A's name = "&gt;</span></span></div><div class="line">  <span class="number">12</span> invokevirtual <span class="meta">#6 <span class="meta-string">&lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span></span></div><div class="line">  <span class="number">15</span> invokestatic <span class="meta">#7 <span class="meta-string">&lt;Method java.lang.String getName()&gt;</span></span></div><div class="line">  <span class="number">18</span> invokevirtual <span class="meta">#6 <span class="meta-string">&lt;Method java.lang.StringBuffer append(java.lang.String)&gt;</span></span></div><div class="line">  <span class="number">21</span> invokevirtual <span class="meta">#8 <span class="meta-string">&lt;Method java.lang.String toString()&gt;</span></span></div><div class="line">  <span class="number">24</span> invokevirtual <span class="meta">#9 <span class="meta-string">&lt;Method void println(java.lang.String)&gt;</span></span></div><div class="line">  <span class="number">27</span> <span class="keyword">return</span></div></pre></td></tr></table></figure></p>
<p>注意标号10至15行的代码，class B中已经变为对A class的getName()方法的引用，当常量name的值改变时我们只需对class A中的常量做修改并重新编译，无需编译整个项目工程我们就能改变整个应用对此常量的引用，即保持了java动态优势又保持了我们使用常量的初衷，因而方法二是一个最佳解决方案。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 接口 </tag>
            
            <tag> 常量 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射学习总结（五）]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>使用反射实例对象</strong></p>
<p>使用反射机制，我们可以在运行时动态加载类并且实例化对象，操作对象的方法、改变类成员的值，甚至还可以改变私有（private）成员的值。</p>
<p>我们可以用 Class 的 newInstance() 方法来实例化一个对象，实例化的对象是以 Object 传回的，例如：<br><a id="more"></a><br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">Class c</span> = Class.forName(className);</div><div class="line"><span class="attribute">Object obj</span> = c.newInstance();</div></pre></td></tr></table></figure></p>
<p>下面范例动态加载list接口的类：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.util.List;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> NewInstanceDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line">            List list = (List) c.newInstance();</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">                list.add(<span class="string">"element "</span> + i);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">for</span> (Object o : list.toArray()) &#123;</div><div class="line">                System.out.<span class="keyword">println</span>(o);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java CoreJava<span class="selector-class">.day_2</span><span class="selector-class">.NewInstanceDemo</span> java<span class="selector-class">.util</span><span class="selector-class">.ArrayList</span></div><div class="line">element <span class="number">0</span></div><div class="line">element <span class="number">1</span></div><div class="line">element <span class="number">2</span></div><div class="line">element <span class="number">3</span></div><div class="line">element <span class="number">4</span></div></pre></td></tr></table></figure>
<p>实际上如果想要使用反射来动态加载类，通常是对对象的接口或类别都一无所知，也就无法像上面对 newInstance() 传回的对象进行接口转换。</p>
<p>如果加载的类中具备无参数的构造方法，则可以无参数的 newInstance() 来构造一个不指定初始化的引用，如果要在动态加载及生成对象时指定对象的引用，则要先指定参数类型、取得 Constructor 对象、使用 Constructor 的 newInstance() 并指定参数。</p>
<p>可以用一个例子来说明，先定义一个student类:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/05</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> String name;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;</div><div class="line">        name = <span class="string">"N/A"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> score)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">        <span class="keyword">this</span>.score = score;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.name = name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.score = score;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> score;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> name + <span class="string">":"</span> + score;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以用 Class.forName() 来加载 Student ，并使用第二个有参数的构造方法来构造Student 实例：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> NewInstanceDemo2 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line"></div><div class="line">            <span class="comment">// 指定参数</span></div><div class="line">            <span class="keyword">Class</span>[] params = <span class="keyword">new</span> <span class="keyword">Class</span>[<span class="number">2</span>];</div><div class="line">            <span class="comment">// 第一个是String</span></div><div class="line">            params[<span class="number">0</span>] = String.<span class="keyword">class</span>;</div><div class="line">            <span class="comment">// 第二个是int</span></div><div class="line">            params[<span class="number">1</span>] = Integer.TYPE;</div><div class="line"></div><div class="line">            <span class="comment">// 取得对应的构造方法</span></div><div class="line">            Constructor constructor =</div><div class="line">                    c.getConstructor(params);</div><div class="line"></div><div class="line">            <span class="comment">// 指定引用内容</span></div><div class="line">            Object[] argObjs = <span class="keyword">new</span> Object[<span class="number">2</span>];</div><div class="line">            argObjs[<span class="number">0</span>] = <span class="string">"caterpillar"</span>;</div><div class="line">            argObjs[<span class="number">1</span>] = <span class="keyword">new</span> Integer(<span class="number">90</span>);</div><div class="line"></div><div class="line">            <span class="comment">// 给定引用并初始化</span></div><div class="line">            Object obj = constructor.newInstance(argObjs);</div><div class="line">            <span class="comment">// toString()查看</span></div><div class="line">            System.out.<span class="keyword">println</span>(obj);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"没有所指定的方法"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">java</span> <span class="selector-tag">NewInstanceDemo2</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.Student</span></div><div class="line"><span class="selector-tag">caterpillar</span><span class="selector-pseudo">:90</span></div></pre></td></tr></table></figure>
<p><strong>调用方法</strong></p>
<p>使用反射可以取回类上方法的对象代表，方法的物件代表是 java.lang.reflect.Method 的实例，我们可以使用它的 invoke() 方法来动态调用指定的方法，例如调用上面 Student 上的 setName() 等方法：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> InvokeMethodDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="comment">// 使用无参构造方法实例对象</span></div><div class="line">            Object targetObj = c.newInstance();</div><div class="line">            <span class="comment">// 设置参数类型</span></div><div class="line">            <span class="keyword">Class</span>[] param1 = &#123;String.<span class="keyword">class</span>&#125;;</div><div class="line">            <span class="comment">// 根据参数取回方法</span></div><div class="line">            Method setNameMethod = c.getMethod(<span class="string">"setName"</span>, param1);</div><div class="line">            <span class="comment">// 设置引用</span></div><div class="line">            Object[] argObjs1 = &#123;<span class="string">"caterpillar"</span>&#125;;</div><div class="line">            <span class="comment">// 给引用调用指定对象的方法方法</span></div><div class="line">            setNameMethod.invoke(targetObj, argObjs1);</div><div class="line"></div><div class="line"></div><div class="line">            <span class="keyword">Class</span>[] param2 = &#123;Integer.TYPE&#125;;</div><div class="line">            Method setScoreMethod =</div><div class="line">                    c.getMethod(<span class="string">"setScore"</span>, param2);</div><div class="line"></div><div class="line">            Object[] argObjs2 = &#123;<span class="keyword">new</span> Integer(<span class="number">90</span>)&#125;;</div><div class="line">            setScoreMethod.invoke(targetObj, argObjs2);</div><div class="line">            <span class="comment">// 显示类描述</span></div><div class="line">            System.out.<span class="keyword">println</span>(targetObj);</div><div class="line"></div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"没有这个方法"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以指定加载 Student 类并生成实例，接着可以动态调用 setName() 和 setScore() 方法，由于调用setName() 和 setScore() 所设置的参数是 “caterpillar” 和90。</p>
<p>在很少的情況下，我们需要突破 Java 的存取限制来调用受保护的（protected）或私有（private）的方法（例如我们拿到一个组件（Component），但我们没法修改它的原始码来改变某个私有方法的权限，而我们又一定要调用某个私有方法），这时我们可以使用反射机制來达到目的，一个存取私有方法的例子如下：</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">Method</span> <span class="title">privateMethod</span> = </span></div><div class="line">            <span class="title">c</span>.<span class="title">getDeclaredMethod</span><span class="params">("somePrivateMethod", <span class="keyword">new</span> <span class="keyword">Class</span>[0])</span>;</div><div class="line">privateMethod.setAccessible(<span class="keyword">true</span>);</div><div class="line">privateMethod.invoke(targetObj, argObjs);</div></pre></td></tr></table></figure>
<p>使用反射来动态调用方法的实例例子之一是在 JavaBean 的设定，例如在 JSP/Servlet 中，可以根据使用者的请求名和 JavaBean 的属性自动对比，将请求值设置到指定的 JavaBean 上，并自动根据参数类型转换。</p>
<p>下面是一个map的小例子：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Method;</div><div class="line"><span class="keyword">import</span> java.lang.reflect.Modifier;</div><div class="line"><span class="keyword">import</span> java.util.Map;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class CommandUtil &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> getCommand(Map requestMap,</div><div class="line">                                    <span class="keyword">String</span> commandClass)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        Class c = Class.forName(commandClass);</div><div class="line">        <span class="keyword">Object</span> o = c.newInstance();</div><div class="line"></div><div class="line">        <span class="keyword">return</span> updateCommand(requestMap, o);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 使用reflection自动找出要更新的属性</span></div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">Object</span> updateCommand(</div><div class="line">            Map requestMap,</div><div class="line">            <span class="keyword">Object</span> command)</div><div class="line">            <span class="keyword">throws</span> Exception &#123;</div><div class="line">        Method[] methods =</div><div class="line">                command.getClass().getDeclaredMethods();</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; methods.length; i++) &#123;</div><div class="line">            <span class="comment">// 略过private、protected成员</span></div><div class="line">            <span class="comment">// 且找出必须是set开头的方法</span></div><div class="line">            <span class="keyword">if</span> (!Modifier.isPrivate(methods[i].getModifiers()) &amp;&amp;</div><div class="line">                    !Modifier.isProtected(methods[i].getModifiers()) &amp;&amp;</div><div class="line">                    methods[i].getName().startsWith(<span class="string">"set"</span>)) &#123;</div><div class="line">                <span class="comment">// 取得不包括set方法</span></div><div class="line">                <span class="keyword">String</span> name = methods[i].getName()</div><div class="line">                        .substring(<span class="number">3</span>)</div><div class="line">                        .toLowerCase();</div><div class="line">                <span class="comment">// 如果setter名称键值对相同</span></div><div class="line">                <span class="comment">// 调用对应的setter并给值</span></div><div class="line">                <span class="keyword">if</span> (requestMap.containsKey(name)) &#123;</div><div class="line">                    <span class="keyword">String</span> param = (<span class="keyword">String</span>) requestMap.<span class="built_in">get</span>(name);</div><div class="line">                    <span class="keyword">Object</span>[] values = findOutParamValues(</div><div class="line">                            param, methods[i]);</div><div class="line">                    methods[i].invoke(command, values);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> command;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 转换对应类型</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">Object</span>[] findOutParamValues(</div><div class="line">            <span class="keyword">String</span> param, Method method) &#123;</div><div class="line">        Class[] params = method.getParameterTypes();</div><div class="line">        <span class="keyword">Object</span>[] objs = <span class="keyword">new</span> <span class="keyword">Object</span>[params.length];</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; params.length; i++) &#123;</div><div class="line">            <span class="keyword">if</span> (params[i] == <span class="keyword">String</span>.class) &#123;</div><div class="line">                objs[i] = param;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Short.TYPE) &#123;</div><div class="line">                <span class="keyword">short</span> number = Short.parseShort(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Short(number);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Integer.TYPE) &#123;</div><div class="line">                <span class="built_in">int</span> number = Integer.parseInt(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Integer(number);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Long.TYPE) &#123;</div><div class="line">                <span class="keyword">long</span> number = Long.parseLong(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Long(number);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Float.TYPE) &#123;</div><div class="line">                <span class="built_in">float</span> number = Float.parseFloat(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Float(number);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Double.TYPE) &#123;</div><div class="line">                <span class="keyword">double</span> number = Double.parseDouble(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Double(number);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (params[i] == Boolean.TYPE) &#123;</div><div class="line">                <span class="built_in">boolean</span> bool = Boolean.parseBoolean(param);</div><div class="line">                objs[i] = <span class="keyword">new</span> Boolean(bool);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> objs;</div><div class="line">    &#125;</div><div class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) <span class="keyword">throws</span> Exception &#123;</div><div class="line">        Map&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt; request = </div><div class="line">                  <span class="keyword">new</span> <span class="keyword">HashMap</span>&lt;<span class="keyword">String</span>, <span class="keyword">String</span>&gt;();</div><div class="line">        request.put(<span class="string">"name"</span>, <span class="string">"caterpillar"</span>);</div><div class="line">        request.put(<span class="string">"score"</span>, <span class="string">"90"</span>);</div><div class="line">        <span class="keyword">Object</span> obj = CommandUtil.getCommand(request, args[<span class="number">0</span>]);</div><div class="line">        System.out.<span class="built_in">println</span>(obj);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>CommandUtil 可以自动根据方法上的参数类型，将Map 中的value转换成相应的类型，目前它可以转换基本类型和 String。</p>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">java</span> <span class="selector-tag">CommandUtilDemo</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.Student</span></div><div class="line"><span class="selector-tag">caterpillar</span><span class="selector-pseudo">:90</span></div></pre></td></tr></table></figure>
<p>当然也可以修改<strong>成员变量</strong>，尽管直接读取类的成员属性（Field）是不被鼓励的，但我们仍是可以直接存取公共的（public）成员属性的，而我们甚至也可以通过反射机制来读取私用成员变量，以一个例子来说明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestField</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">int</span> testInt;</div><div class="line">    <span class="keyword">public</span> String testString;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> testInt + <span class="string">":"</span> + testString;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后利用反射机制动态的读取成员变量：</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line">package <span class="type">CoreJava</span>.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.Field;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AssignFieldDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="type">Class</span> <span class="built_in">c</span> = <span class="type">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="type">Object</span> targetObj = <span class="built_in">c</span>.newInstance();</div><div class="line"></div><div class="line">            <span class="type">Field</span> testInt = <span class="built_in">c</span>.getField(<span class="string">"testInt"</span>);</div><div class="line">            testInt.setInt(targetObj, <span class="number">99</span>);</div><div class="line"></div><div class="line">            <span class="type">Field</span> testString = <span class="built_in">c</span>.getField(<span class="string">"testString"</span>);</div><div class="line">            testString.<span class="keyword">set</span>(targetObj, <span class="string">"caterpillar"</span>);</div><div class="line"></div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(targetObj);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ArrayIndexOutOfBoundsException</span> e) &#123;</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"没有指定类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ClassNotFoundException</span> e) &#123;</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定的类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">SecurityException</span> e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">NoSuchFieldException</span> e) &#123;</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定的成员变量"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">InstantiationException</span> e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">IllegalAccessException</span> e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">java</span> <span class="selector-tag">AssignFieldDemo</span> <span class="selector-tag">CoreJava</span><span class="selector-class">.day_2</span><span class="selector-class">.TestField</span></div><div class="line">99<span class="selector-pseudo">:caterpillar</span></div></pre></td></tr></table></figure>
<p>如果有必要的话，也可以通过反射机制来读取私有的成员变量，例如：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Field privateField = c.getDeclaredField(<span class="string">"privateField"</span>)<span class="comment">; </span></div><div class="line">privateField.setAccessible(true)<span class="comment">;</span></div><div class="line">privateField.setInt(targetObj, <span class="number">99</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p><strong>数组</strong><br>在 Java 中数组也是一个对象，也会有一个 Class 实例来表示它，我们用几个基本类型和String来进行测试：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ArrayDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">short</span>[] sArr = <span class="keyword">new</span> <span class="keyword">short</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">long</span>[] lArr = <span class="keyword">new</span> <span class="keyword">long</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">float</span>[] fArr = <span class="keyword">new</span> <span class="keyword">float</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">double</span>[] dArr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">byte</span>[] bArr = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">boolean</span>[] zArr = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>];</div><div class="line">        <span class="keyword">String</span>[] strArr = <span class="keyword">new</span> <span class="keyword">String</span>[<span class="number">5</span>];</div><div class="line"></div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"short 数组："</span> + sArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"int 数组："</span> + iArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"long 数组："</span> + lArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"float 数组："</span> + fArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"double 数组："</span> + dArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"byte 数组："</span> + bArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"boolean 数组："</span> + zArr.getClass());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"String 数组："</span> + strArr.getClass());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">short</span> 数组：<span class="keyword">class</span> [S</div><div class="line"><span class="keyword">int</span> 数组：<span class="keyword">class</span> [I</div><div class="line"><span class="keyword">long</span> 数组：<span class="keyword">class</span> [J</div><div class="line"><span class="keyword">float</span> 数组：<span class="keyword">class</span> [F</div><div class="line"><span class="keyword">double</span> 数组：<span class="keyword">class</span> [D</div><div class="line"><span class="keyword">byte</span> 数组：<span class="keyword">class</span> [B</div><div class="line"><span class="keyword">boolean</span> 数组：<span class="keyword">class</span> [Z</div><div class="line"><span class="keyword">String</span> 数组：<span class="keyword">class</span> [Ljava.lang.<span class="keyword">String</span>;</div><div class="line"></div><div class="line"><span class="built_in">Process</span> finished with exit code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>要使用<strong>反射机制动态生成数组</strong>的话，也可以这样：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class NewArrayDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        Class c = <span class="keyword">String</span>.class;</div><div class="line">        <span class="keyword">Object</span> objArr = <span class="keyword">Array</span>.newInstance(c, <span class="number">5</span>);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            <span class="keyword">Array</span>.<span class="built_in">set</span>(objArr, i, i + <span class="string">""</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            System.out.<span class="built_in">print</span>(<span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i) + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">        System.out.<span class="built_in">println</span>();</div><div class="line"></div><div class="line">        <span class="keyword">String</span>[] strs = (<span class="keyword">String</span>[]) objArr;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> s : strs) &#123;</div><div class="line">            System.out.<span class="built_in">print</span>(s + <span class="string">" "</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Array.newInstance() 的第一个参数是指定参数类型，而第二个参数是用来指定数组长度的，结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="symbol">0 </span><span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span></div></pre></td></tr></table></figure>
<p>如果是二维数组，也是一样的：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.lang.reflect.<span class="keyword">Array</span>;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> class NewArrayDemo2 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        Class c = <span class="keyword">String</span>.class;</div><div class="line"></div><div class="line">        <span class="comment">// 打算建立一个3*4数组</span></div><div class="line">        <span class="built_in">int</span>[] dim = <span class="keyword">new</span> <span class="built_in">int</span>[]&#123;<span class="number">3</span>, <span class="number">4</span>&#125;;</div><div class="line">        <span class="keyword">Object</span> objArr = <span class="keyword">Array</span>.newInstance(c, dim);</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">Object</span> row = <span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i);</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">                <span class="keyword">Array</span>.<span class="built_in">set</span>(row, j, <span class="string">""</span> + (i + <span class="number">1</span>) * (j + <span class="number">1</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</div><div class="line">            <span class="keyword">Object</span> row = <span class="keyword">Array</span>.<span class="built_in">get</span>(objArr, i);</div><div class="line">            <span class="keyword">for</span> (<span class="built_in">int</span> j = <span class="number">0</span>; j &lt; <span class="number">4</span>; j++) &#123;</div><div class="line">                System.out.<span class="built_in">print</span>(<span class="keyword">Array</span>.<span class="built_in">get</span>(row, j) + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            System.out.<span class="built_in">println</span>();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">1 </span><span class="number">2</span> <span class="number">3</span> <span class="number">4</span></div><div class="line"><span class="symbol">2 </span><span class="number">4</span> <span class="number">6</span> <span class="number">8</span></div><div class="line"><span class="symbol">3 </span><span class="number">6</span> <span class="number">9</span> <span class="number">12</span></div></pre></td></tr></table></figure>
<p>如果想要知道数组元素的类型，可以在取得数组的 Class 实例之后，使用 Class 实例的 getComponentType() 方法，所取回的是元素的 Class 实例，例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span>[] iArr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</div><div class="line">System.out.<span class="built_in">println</span>(iArr.getClass().getComponentType());</div></pre></td></tr></table></figure>
<p>对反射的总结差不多就写到这里了，查阅了很多资料，网络上写的也是参差不齐的，在手写的几十个demo支撑下，得出的一点关于反射的东西，肯定不能说全部正确，但是还是可以提供一些帮助的  -。-</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射学习总结（四）]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>类加载器</strong></p>
<p>Java在需要使用类的时候，才会将类加载，Java的类加载是由类加载器（Class loader）来完成的。<br>当我们在命令模式下执行java xxx指令后，Java执行程序会尝试找到jre安装的所在目录，然后找到jvm.dll（假设在jre目录下的bin\client下），接着启动jvm并进行初始化操作，接着会产生bootstrap loader，bootstrap loader则会加载 extended loader，并设定 extended loader的parent为bootstrap loader，接着bootstrap loader会加载system loader，并将system loader的parent设为 extended loader。<br><a id="more"></a><br>bootstrap loader通常是由c写的， extended loader是由Java写的，实际这个对应着sun.misc.Launcher\$ExtClassLoader（Launcher 中的内部类）；system loader 是由 Java写的，实际对应sun.misc. Launcher\$AppClassLoader（Launcher 中的内部类）。</p>
<p><strong>流程如下图：</strong><br><img src="http://img.blog.csdn.net/20161205220032526" alt="这里写图片描述"></p>
<p>Bootstrap Loader 会查找系统参数 sun.boot.class.path 中指定位置的类，假设是 JRE classes 下之文件，或 lib 目录下 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“sun.boot.class.path”) 来显示 sun.boot.class.path 中指定的路劲，例如在我的终端显示的是以下的路劲：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/resources.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>rt.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/sunrsasign.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>jsse.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/jce.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span>charsets.<span class="string">jar:</span><span class="regexp">/Library/</span>Java<span class="regexp">/JavaVirtualMachines/</span>jdk1<span class="number">.8</span><span class="number">.0</span>_65.jdk<span class="regexp">/Contents/</span>Home<span class="regexp">/jre/</span>lib<span class="regexp">/jfr.jar:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre/classes</div></pre></td></tr></table></figure>
<p>Extended Loader（sun.misc.Launcher$ExtClassLoader）是由 Java 写的，会查找系统参数java.ext.dirs 中指定位置的类，假设是 JRE 目录下的 lib\ext\classes 目录下的 .class 文件，或 lib\ext 目录下的 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“java.ext.dirs”) 来显示指定的路劲:</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="regexp">/Users/</span>lizhi<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>Library<span class="regexp">/Java/</span>JavaVirtualMachines<span class="regexp">/jdk1.8.0_65.jdk/</span>Contents<span class="regexp">/Home/</span>jre<span class="regexp">/lib/</span><span class="string">ext:</span><span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>Network<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>System<span class="regexp">/Library/</span>Java<span class="regexp">/Extensions:/</span>usr<span class="regexp">/lib/</span>java</div></pre></td></tr></table></figure>
<p>System Loader（sun.misc.Launcher$AppClassLoader）是由 Java 写的，会查找系统参 java.class.path 中指定位置的类，也就是 Classpath 所指定的路径，假设是目前工作路径下的 .class 文件，我们可以使用 System.getProperty(“java.class.path”) 来显示 java.class.path 中指定的路径，在使用 java 执行程序时，我们也可以加上 -cp 來覆盖原有的 Classpath 设置，例如：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">java</span> –<span class="meta">cp</span> ./classes SomeClass</div></pre></td></tr></table></figure>
<p>Bootstrap Loader 会在 JVM 启动之后生成，之后它会加载 Extended Loader 并将其 parent 设为 Bootstrap Loader，然后Bootstrap Loader 再加载 System Loader 并将其 parent 设为 ExtClassLoader，接着System Loader 开始加载我们指定的类，在加载类时，每个类加载器会先将加载类的任务讲给他的parent，如果 parent 找不到，才由自己负责加载，所以在加载类时，会以 Bootstrap Loader→Extended Loader→System Loader 的顺序开查找类，如果都找不到，就会抛出 NoClassDefFoundError。</p>
<p>类加载器在 Java 中是以 java.lang.ClassLoader 形式存在，每一个类被加载后，都会有一个 Class 的实例来代表，而每个 Class 的实例都会记得自己是由哪个 ClassLoader 加载的，可以由 Class 的 getClassLoader() 取得加载该类的 ClassLoader，而从 ClassLoader 的 getParent() 方法可以取得自己的 parent。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/5</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SomeClass</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        <span class="comment">// 建立SomeClass实例</span></div><div class="line">        SomeClass some = <span class="keyword">new</span> SomeClass();</div><div class="line">        <span class="comment">// 取得SomeClass的Class实例</span></div><div class="line">        Class c = some.getClass();</div><div class="line">        <span class="comment">// 取得ClassLoader</span></div><div class="line">        ClassLoader loader = c.getClassLoader();</div><div class="line">        System.<span class="keyword">out</span>.println(loader);</div><div class="line">        <span class="comment">// 取得父ClassLoader</span></div><div class="line">        System.<span class="keyword">out</span>.println(loader.getParent());</div><div class="line">        <span class="comment">// 再取得父ClassLoader</span></div><div class="line">        System.<span class="keyword">out</span>.println(loader.getParent().getParent());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sun.misc.Launcher<span class="variable">$AppClassLoader</span>@<span class="number">60</span>e53b93</div><div class="line">sun.misc.Launcher<span class="variable">$ExtClassLoader</span>@<span class="number">66</span>d3c617</div><div class="line">null</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>CoreJava.day_2.SomeClass 是个自定义类，我们在目前的目录下执行程序，首先 AppClassLoader 会将加载类的任务交給 ExtClassLoader，而 ExtClassLoader 将会把加载类的任务交给 Bootstrap Loader，由于Bootstrap Loader 在它的路径（sun.boot.class.path）下找不到类，所以由 ExtClassLoader 来尝试查找，而 ExtClassLoader 在它的路径设置（java.ext.dirs）下也找不到类，所以由 AppClassLoader 来尝试查找，AppClassLoader 最后在 Classpath（java.class.path）设置下找到指定的类并加载。</p>
<p>在输出中可以看到，加载 SomeClass 的 ClassLoader 是 AppClassLoader，而 AppClassLoader 的 parent 是 ExtClassLoader，而 ExtClassLoader 的 parent 是 null，null 并不是表示 ExtClassLoader 没有设置 parent，而是因为 Bootstrap Loader 通常由 C 写的，在 Java 中并没有一个类来表示它，所以才会显示为null。</p>
<p>如果把 SomeClass 的 .class 文件移至 JRE 目录下的 lib\ext\classes下，并重新（任何目录下）执行程序，我们可以看到：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">null</div><div class="line">Exception <span class="keyword">in</span> thread <span class="string">"main"</span> java<span class="selector-class">.lang</span><span class="selector-class">.NullPointerException</span></div><div class="line">        at CoreJava<span class="selector-class">.day_2</span><span class="selector-class">.SomeClass</span><span class="selector-class">.main</span>(SomeClass<span class="selector-class">.java</span>:<span class="number">13</span>)</div></pre></td></tr></table></figure>
<p>由于 SomeClass 这次可以在 Bootstrap Loader 的设置路径下找到，所以会由 Bootstrap Loader 来加载 SomeClass 类，Bootstrap Loader 通常由 C 写的，在 Java 中没有一个实际类来表示，所以显示为 null，因为表示为null，所以再由 null 上尝试调用 getParent() 方法就会抛出 NullPointerException 异常。</p>
<p>取得 ClassLoader 的实例之后，我们可以使用它的 loadClass() 方法来加载类，使用 loadClass() 方法加载类时，不会执行静态代码块，静态代码块的执行会等到真正使用类时来建立实例：</p>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">加载TestClass2</div><div class="line">TestClass2声明</div><div class="line">TestClass2实例对象</div><div class="line">[执行静态代码块]</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>可以看出，loadClass() 不会在加载类时执行静态代码块，而会在使用类new对象时才执行静态代码块代码。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射学习总结（三）]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Class对象表示所加载的类，取得Class对象后，我们就可以愉快的取得与类相关的信息了，就像包（package,package也是类名的一部分哦~），构造方法，方法，属性等信息，而每一个信息，也会有相应的类别形态，比如包对应的是 java.lang.Package，构造方法对应的是java.lang.reflect.Constructor，成员方法对应的是 java.lang.reflect.Method，属性对应的是 java.lang.reflect.Field等。<br><a id="more"></a><br>先来个简单的例子吧，获取一下包名：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassInfoDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="keyword">Package</span> p = c.getPackage();</div><div class="line">            System.out.<span class="keyword">println</span>(p.getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (ArrayIndexOutOfBoundsException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"没有指定类"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定类"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">java</span> <span class="selector-tag">ClassInfoDemo</span> <span class="selector-tag">java</span><span class="selector-class">.util</span><span class="selector-class">.ArrayList</span></div><div class="line"><span class="selector-tag">java</span><span class="selector-class">.util</span></div></pre></td></tr></table></figure>
<p>用相应的方法，我们可以分别取得 Field、Constructor、Method等对象。</p>
<p>下面是一个我之前写的可以获取某些类信息的一个demo：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line">import java.lang.reflect.Constructor;</div><div class="line">import java.lang.reflect.Field;</div><div class="line">import java.lang.reflect.Method;</div><div class="line">import java.lang.reflect.Modifier;</div><div class="line">import java.util.Scanner;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/1</div><div class="line"> */</div><div class="line">public <span class="keyword">class</span> ReflectTest &#123;</div><div class="line">    public static void main(String[] <span class="keyword">args</span>) &#123;</div><div class="line">        String name;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">args</span>.length &gt; 0) &#123;</div><div class="line">            name = <span class="keyword">args</span>[0];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            Scanner <span class="keyword">in</span> = new Scanner(System.<span class="keyword">in</span>);</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"输入类名:(例如:java.util.Date)"</span>);</div><div class="line">            name = <span class="keyword">in</span>.next();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        try &#123;</div><div class="line">            <span class="keyword">Class</span> c1 = <span class="keyword">Class</span>.forName(name);</div><div class="line">            <span class="keyword">Class</span> superc1 = c1.getSuperclass();</div><div class="line">            String modifiers = Modifier.<span class="keyword">toString</span>(c1.getModifiers());</div><div class="line">            <span class="keyword">if</span> (modifiers.<span class="built_in">length</span>() &gt; 0) &#123;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">""</span>);</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"class "</span> + name);</div><div class="line">            <span class="keyword">if</span> (superc1 != null &amp;&amp; superc1 != Object.<span class="keyword">class</span>) &#123;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">" extends"</span> + superc1.getName());</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">"\n&#123;\n"</span>);</div><div class="line">            printConstructors(c1);</div><div class="line">            System.<span class="keyword">out</span>.println();</div><div class="line">            printMethods(c1);</div><div class="line">            System.<span class="keyword">out</span>.println();</div><div class="line">            printFields(c1);</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">"&#125;"</span>);</div><div class="line">        &#125; catch (Exception <span class="keyword">e</span>) &#123;</div><div class="line">            <span class="keyword">e</span>.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        System.<span class="keyword">exit</span>(0);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printConstructors(<span class="keyword">Class</span> c1) &#123;</div><div class="line">        Constructor[] constructors = c1.getDeclaredConstructors();</div><div class="line">        <span class="keyword">for</span> (Constructor c : constructors) &#123;</div><div class="line">            String name = c.getName();</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">""</span>);</div><div class="line">            String modifers = Modifier.<span class="keyword">toString</span>(c.getModifiers());</div><div class="line">            <span class="keyword">if</span> (modifers.<span class="built_in">length</span>() &gt; 0) &#123;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifers + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(name + <span class="string">"("</span>);</div><div class="line">            <span class="keyword">Class</span>[] paramTypes = c.getParameterTypes();</div><div class="line">            <span class="keyword">for</span> (int j = 0; j &lt; paramTypes.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j &gt; 0) &#123;</div><div class="line">                    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">","</span>);</div><div class="line">                &#125;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName());</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printMethods(<span class="keyword">Class</span> c1) &#123;</div><div class="line">        Method[] methods = c1.getDeclaredMethods();</div><div class="line">        <span class="keyword">for</span> (Method <span class="keyword">m</span> : methods) &#123;</div><div class="line">            <span class="keyword">Class</span> retType = <span class="keyword">m</span>.getReturnType();</div><div class="line">            String name = <span class="keyword">m</span>.getName();</div><div class="line"></div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">" "</span>);</div><div class="line">            String modifiers = Modifier.<span class="keyword">toString</span>(<span class="keyword">m</span>.getModifiers());</div><div class="line">            <span class="keyword">if</span> (modifiers.<span class="built_in">length</span>() &gt; 0) &#123;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(retType.getName() + <span class="string">" "</span> + <span class="string">"("</span>);</div><div class="line">            <span class="keyword">Class</span>[] paramTypes = <span class="keyword">m</span>.getParameterTypes();</div><div class="line">            <span class="keyword">for</span> (int j = 0; j &lt; paramTypes.length; j++) &#123;</div><div class="line">                <span class="keyword">if</span> (j &gt; 0) &#123;</div><div class="line">                    System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">","</span>);</div><div class="line">                &#125;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(paramTypes[j].getName());</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="string">");"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    public static void printFields(<span class="keyword">Class</span> c1) &#123;</div><div class="line">        Field[] fields = c1.getDeclaredFields();</div><div class="line">        <span class="keyword">for</span> (Field f : fields) &#123;</div><div class="line">            <span class="keyword">Class</span> <span class="keyword">type</span> = f.getType();</div><div class="line">            String name = f.getName();</div><div class="line">            System.<span class="keyword">out</span>.<span class="keyword">print</span>(<span class="string">" "</span>);</div><div class="line">            String modifiers = Modifier.<span class="keyword">toString</span>(f.getModifiers());</div><div class="line">            <span class="keyword">if</span> (modifiers.<span class="built_in">length</span>() &gt; 0) &#123;</div><div class="line">                System.<span class="keyword">out</span>.<span class="keyword">print</span>(modifiers + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">            System.<span class="keyword">out</span>.println(<span class="keyword">type</span>.getName() + <span class="string">" "</span> + name + <span class="string">";"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line">输入类名:(例如:java.util.Date)</div><div class="line">java.util.Date</div><div class="line">publicclass java.util.Date</div><div class="line">&#123;</div><div class="line"><span class="keyword">public</span> java.util.Date(java.lang.<span class="keyword">String</span>);</div><div class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</div><div class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</div><div class="line"><span class="keyword">public</span> java.util.Date();</div><div class="line"><span class="keyword">public</span> java.util.Date(<span class="keyword">long</span>);</div><div class="line"><span class="keyword">public</span> java.util.Date(<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</div><div class="line"></div><div class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.lang.<span class="keyword">Object</span>);</div><div class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">Object</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> (java.util.Date);</div><div class="line"> <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="built_in">int</span> (java.lang.<span class="keyword">Object</span>);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">void</span> (java.io.ObjectInputStream);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">void</span> (java.io.ObjectOutputStream);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date ();</div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date (sun.util.calendar.BaseCalendar$Date);</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> (java.lang.<span class="keyword">String</span>);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.util.Date);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">boolean</span> (java.util.Date);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> ();</div><div class="line"> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> (java.util.Date);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.StringBuilder (java.lang.StringBuilder,java.lang.<span class="keyword">String</span>);</div><div class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</div><div class="line"> <span class="keyword">public</span> java.lang.<span class="keyword">String</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">private</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar$Date ();</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (sun.util.calendar.BaseCalendar$Date);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (<span class="keyword">long</span>);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar (<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> sun.util.calendar.BaseCalendar ();</div><div class="line"> <span class="keyword">public</span> java.time.Instant ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> (<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>,<span class="built_in">int</span>);</div><div class="line"> <span class="keyword">public</span> <span class="keyword">static</span> java.util.Date (java.time.Instant);</div><div class="line"> <span class="keyword">public</span> <span class="built_in">int</span> ();</div><div class="line"> <span class="keyword">public</span> <span class="keyword">void</span> (<span class="keyword">long</span>);</div><div class="line"> <span class="keyword">public</span> <span class="keyword">long</span> ();</div><div class="line"></div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.util.calendar.BaseCalendar gcal;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> sun.util.calendar.BaseCalendar jcal;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">long</span> fastTime;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">transient</span> sun.util.calendar.BaseCalendar$Date cdate;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="built_in">int</span> defaultCenturyStart;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> [Ljava.lang.<span class="keyword">String</span>; wtb;</div><div class="line"> <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> [I ttb;</div><div class="line">&#125;</div><div class="line"></div><div class="line">Process finished with <span class="built_in">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>输入一个类（完整的类名），即可打印该类的略为完整信息。当然还有一些不知道的，可以查看API来完成。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射学习总结（二）]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p><strong>使用 Class.forName() 加载类</strong></p>
<p>在一些应用中，我们无法事先知道使用者将会加载什么类，而必须让使用者指定类名类加载类，我们就可以用Class的静态forName()方法来实现动态加载类，如下：<br><a id="more"></a><br><figure class="highlight swift"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">package <span class="type">CoreJava</span>.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForNameDemo</span> </span>&#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="type">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="type">Class</span> <span class="built_in">c</span> = <span class="type">Class</span>.forName(args[<span class="number">0</span>]);</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"类名："</span> +</div><div class="line">                    <span class="built_in">c</span>.getName());</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为接口："</span> +</div><div class="line">                    <span class="built_in">c</span>.isInterface());</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为基本类型："</span> +</div><div class="line">                    <span class="built_in">c</span>.isPrimitive());</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"是否为数组："</span> + <span class="built_in">c</span>.isArray());</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"父类名："</span> +</div><div class="line">                    <span class="built_in">c</span>.getSuperclass().getName());</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ArrayIndexOutOfBoundsException</span> e) &#123;</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"没有指定的类名"</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (<span class="type">ClassNotFoundException</span> e) &#123;</div><div class="line">            <span class="type">System</span>.out.<span class="built_in">println</span>(<span class="string">"找不到指定类"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">java ForNameDemo java<span class="selector-class">.util</span><span class="selector-class">.String</span></div><div class="line">类名：java<span class="selector-class">.util</span><span class="selector-class">.Scanner</span></div><div class="line">是否为接口：false</div><div class="line">是否为基本类型：false</div><div class="line">是否为数组：false</div><div class="line">父类名：java<span class="selector-class">.lang</span><span class="selector-class">.Object</span></div></pre></td></tr></table></figure>
<p>Class的静态方法forName()方法有两个版本，上面所示的是指定类名版本，还一个版本可以让我们指定类名，加载时是否执行静态代码块，指定类的加载器（Class loader）:</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">Class</span> forName(<span class="keyword">String</span> <span class="keyword">name</span>, boolean initialize, ClassLoader loader)</div></pre></td></tr></table></figure>
<p><a href="http://justdoitlee.com/javafan-she-xue-xi-bi-ji/" target="_blank"><br>上一篇</a>写到过，假设在加载类的时候，如果类中有定义静态代码块则会执行它，我们可以使用forName的第二个版本，将initialize设为false，如果在加载类时并不会马上执行静态代码块的代码，而会在使用类实例对象时才执行静态代码块，我们可以做一下测试：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass2</span> &#123;</span></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            System.out.println(<span class="string">"[执行静态代码块]"</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这里我们只定义了静态代码块显示一段信息，来观察静态代码块何时被执行。先用第一个版本来测试：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ForNameDemoV1 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"加载TestClass2"</span>);</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(<span class="string">"TestClass2"</span>);</div><div class="line"></div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2声明"</span>);</div><div class="line">            TestClass2 test = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2实例对象"</span>);</div><div class="line">            test = <span class="keyword">new</span> TestClass2();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">加载TestClass2</div><div class="line">[执行静态代码块]</div><div class="line">TestClass2声明</div><div class="line">TestClass2实例对象</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>可以从结果看出，第一个版本的forName()方法在加载类之后，会马上执行静态代码块，再看看第二种结果怎么样：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ForNameDemoV2 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"加载TestClass2"</span>);</div><div class="line">            <span class="keyword">Class</span> c = <span class="keyword">Class</span>.forName(</div><div class="line">                    <span class="string">"CoreJava.day_2.TestClass2"</span>,</div><div class="line">                    <span class="keyword">false</span>, <span class="comment">// 加载类时不执行静态代码块代码</span></div><div class="line">                    Thread.currentThread().getContextClassLoader());</div><div class="line"></div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2声明"</span>);</div><div class="line">            TestClass2 test = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"TestClass2实例对象"</span>);</div><div class="line">            test = <span class="keyword">new</span> TestClass2();</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            System.out.<span class="keyword">println</span>(<span class="string">"找不到指定的类"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">加载TestClass2</div><div class="line">TestClass2声明</div><div class="line">TestClass2实例对象</div><div class="line">[执行静态代码块]</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>由于在第二个版本的forName()方法中，把initialize设为了false，所以加载类时并不会马上执行静态代码块，而会在类实例对象时才去执行静态代码块代码，第二个版本的forName()方法需要一个类加载器（Class loader）。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java反射学习总结（一)]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Java提供的反射机制允许我们在运行时期动态加载类，检测和修改它本身状态或行为，要举反射机制的一个实例的话，就是在整合开发环境中所提供的方法提示或者类的检查工具，另外像jsp中的javabean自动收集请求也用到了反射，还有我们经常用的框架也可以看到反射机制的使用，这样可以达到动态加载使用者自己定义的类的目的。<br><a id="more"></a><br>在我们拿到一个类时，即使对它一无所知，但是其实他本身就包括了很多信息，Java在需要使用某个类时才会将类加载，并在jvm中以一个<strong>java.lang.Class</strong>的实例存在，从Class实例开始，我们可以获取类的信息。</p>
<p><strong>Class类的加载</strong></p>
<p>Java在真正需要使用一个类的时候才会进行加载，而不是在程序启动时加载所有的类，因为大多数人都只使用到应用程序的部分资源，在需要某些功能时在加载某些资源，这样可以让系统的资源运用更有效率。</p>
<p>一个java.lang.Class代表了Java程序中运行时加载类或者接口的实例，也可以用来表达enum（枚举），annotation（注解），数组，基本数据类型；Class类没有public构造方法，Class是由jvm自动生成的，每当一个类被加载时，jvm就会自动生成一个Class实例。</p>
<p>我们还可以通过Object的getClass()方法来取得每一个对象对应Class实例，或者通过”class”常量，在取得Class实例之后，操作Class实例上的一些方法来取得类的基本信息，例如：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/3</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassDemo &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        <span class="keyword">String</span> name = <span class="string">"justdoitlee"</span>;</div><div class="line">        Class stringClass = name.getClass();</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"类名称："</span> +</div><div class="line">                stringClass.getName());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为接口："</span> +</div><div class="line">                stringClass.isInterface());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为基本数据类型："</span> +</div><div class="line">                stringClass.isPrimitive());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"是否为数组："</span> +</div><div class="line">                stringClass.isArray());</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="string">"父类名称："</span> +</div><div class="line">                stringClass.getSuperclass().getName());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">类名称：java.lang.String</div><div class="line">是否为借口：false</div><div class="line">是否为基本数据类型：false</div><div class="line">是否为数组：false</div><div class="line">父类名称：java.lang.Object</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>这里简单的的使用 getClass() 方法来取得 String 类的 Class 实例，并从中得到 String 的一些基本信息。</p>
<p>当然，我们也可以直接使用下面的方式来取得String类的Class对象：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Class</span> stringClass = <span class="keyword">String</span>.<span class="keyword">class</span>;</div></pre></td></tr></table></figure>
<p>Java在真正需要类时才会加载这个类，所谓的<strong>真正需要</strong>通常指的是要使用指定的类生成对象时，或者使用指定要加载的类时，例如使用Class.forName()加载类，或者使用ClassLoader的loadClass()加载类，声明类并不会导致类的加载，可以使用一个小测试来验证。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> 李智</div><div class="line"> * <span class="doctag">@date</span> 2016/12/3</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestClass</span> &#123;</span></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        System.out.println(<span class="string">"类被加载"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在上面我们定义了一个静态代码块，假设在类第一次被加载时会执行静态代码块（说假设是因为，可以设置加载类时不执行静态代码块，使Class生成对象时才执行静态代码块），看输出信息可以看出类何时被加载(如下LoadClassTest)。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/3</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LoadClassTest</span> &#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">        TestClass test = <span class="literal">null</span>;</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"声明TestClass"</span>);</div><div class="line">        test = <span class="keyword">new</span> TestClass();</div><div class="line">        System.<span class="keyword">out</span>.println(<span class="string">"生成TestClass实例"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">声明TestClass</div><div class="line">类被加载</div><div class="line">生成TestClass实例</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>从执行结果可以看出，声明类并不会导致TestClass被加载，而是在使用new生成对象时才会被加载类。</p>
<p>Class的信息是在编译时期就被加入至.class文件的，这是Java执行时期被辨别（RTTI，Run-Time Type Information或Run-Time Type Identification）的一种方式，在编译时期编译器会先检查对应的.class文件，而执行时期jvm在使用类时，会先检查对应的Class是否已经被加载，如果没有加载，则会寻找对应的,class文件并加载，一个类在jvm中只会有一个Class实例，每个类的实例都会记得自己是由哪个Class实例所生成，我们可以使用getClass()或.class来取得Class实例。</p>
<p>另外，在Java中，数组对象也有对应的Class实例，这个对象是由具有相同元素与维度的数组所共用，而基本类型像是 boolean, byte, char, short, int, long, float, double 以及关键字 void（以前都不知道有这个呢！！），也都具有对应的Class对象，我们还可以用类常量（Class literal）来获取这些对象。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">package CoreJava.day_2;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * @author 李智</div><div class="line"> * @date 2016/12/4</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> ClassDemo2 &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">boolean</span>.<span class="keyword">class</span>);</div><div class="line">        System.out.<span class="built_in">println</span>(<span class="keyword">void</span>.<span class="keyword">class</span>);</div><div class="line"></div><div class="line">        <span class="keyword">int</span>[] iarr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</div><div class="line">        System.out.<span class="built_in">println</span>(iarr.getClass().toString());</div><div class="line"></div><div class="line">        <span class="keyword">double</span>[] darr = <span class="keyword">new</span> <span class="keyword">double</span>[<span class="number">10</span>];</div><div class="line">        System.out.<span class="built_in">println</span>(darr.getClass().toString());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">boolean</div><div class="line">void</div><div class="line">class [I</div><div class="line">class [D</div><div class="line"></div><div class="line">Process finished with <span class="keyword">exit</span> code <span class="number">0</span></div></pre></td></tr></table></figure>
<p>在Java中 数组确实是以对象的形式存在的，其对应的类都是有jvm自动生成的，当我们是用toString()来显示数组对象的描述时，[表示为数组类型，并且加上一个类型代表字，上面的I表示是一个Int的数组，d是一个double数组。</p>
<p>这里就先讲一下Class类的加载吧，后面的再总结。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 反射 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我们为什么要用Spring，SpringMVC]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Spring%EF%BC%8CSpringMVC/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天被公司派到别的公司谈项目，刚去就先被面试了一波（原来是把我外包到别的公司做项目了 -。-），面试时候问了我一个问题，很简单，就是问我java开发web项目为什么要用spring,springmvc？<br><br>好吧，当时我人直接懵逼了，什么鬼问我这个！！不就是可以省去很多功夫让我们踏踏实实写业务代码嘛? <br><br><a id="more"></a><br>当时就随便回答了一些，回到公司仔细想想，发现还有挺多可以想，可以讲的。我想起了之前项目的控制层从struts2转到springmvc，我就在想为什么我们现在做javaweb开发，要用struts2或者springMVC这样的框架，而不是使用servlet加jsp这样的技术呢？特别是现在我们web的前端页面都是使用freemaker这样的模板语言进行开发，抛弃了jsp，这样的选择又会给我们javaweb开发带来什么样的好处，延着这个问题的思路，我又发现新的疑问，为什么现在很多java企业级开发都会去选择spring框架，spring框架给我们开发的应用带来了什么？这么一想我人更加糊涂了，很难找带让自己完全信服的答案。<br><br>最终我发现，这些我认为<strong>“用”</strong>的很熟悉技术，其实还有很多让我陌生不解的地方，这些陌生和不解的地方也正是我是否能更高层次使用它们的关键。</p>
<p> 首先，软件里有很多优秀的框架，有一种类型的框架，它的特点是建立在一个现有技术的基础上，提供和现有技术一样业务功能的技术框架，这个新的技术框架比原技术更加易用，更加健壮同时功能更加强大，例如常用的jQuery，以及上面提到的spring和springMVC（其实是一个啦），深究这些框架都是很复杂的，但是它们的优点其实只有一个：<strong>就是让使用者只关心核心业务的开发，框架帮你屏蔽原有技术跟业务开发无关的各类技术问题</strong>。像jQuery，springMVC这类框架之所以优秀，就是它们在这点上做的太好了，以至于很多使用它的程序员都已经不清楚原有技术的真实面目，因此我们要将springmvc理解的更好，使用的更加熟练和深入，这里我们就要跳出springmvc的技术，到springmvc技术的源头servlet，仔细研究下servlet的特点，只有这样我们才能把springmvc框架学的更好（所以才那么多人看springmvc的源码学习吧）。</p>
<p>先讲讲servlet吧，servlet的作用就是是接收浏览器传给服务端的请求（request），并将服务端处理完的响应（response）返回给用户的浏览器，浏览器和服务端之间通过http协议进行沟通，其过程是浏览器根据用户的选择将相关信息按http协议报文的规范组装请求的http报文，报文通过网络传输到指定的服务器，服务器通过特定的web容器接收这个报文信息，例如：tomcat，jetty，jboss这样的web容器，web容器会将http报文解析出来，如果是用户请求，最终解析出来的报文信息会用一个request对象存储起来，服务端使用这个request做完相应的处理后，服务端程序将结果信息封装到response对象里，然后将response对象交给web容器，web容器则把这个response对象转变为http协议的报文，并将报文回传给浏览器，浏览器最后解析这个响应报文，将最终结果展示给用户。</p>
<p>而Web容器创造了servlet接口，servlet接口就是开发人员自己实现业务逻辑的地方，程序员开发servlet就好比做填空题，而填空题的语境或者说上下文提示就是由request和response对象，但是javaEE规范里的servlet接口很简单，就三个方法init，service和destory，但是这个接口太笼统了，所以规范里还提供了一个HttpServlet类，这个类根据http请求类型提供了doGet，doPost等方法，servlet接口最大的特点就是根据http协议的特点进行定义，因此做servlet开发时候如果使用者对http协议特点不是特别熟悉，都会碰到或多或少令人迷惑的问题，特别是碰到一些复杂特殊的请求时候：例如文件上传，返回特殊的文件格式到浏览器，这时候使用servlet开发就不是很方便了，servlet开发还有个问题可能大家常常被忽视，就是请求的数据的类型转化，http协议传输都是文本形式，到了web容器解析后也是文本类型，如果碰到货币，数字，日期这样的类型需要我们根据实际情况进行转化，如果页面传送的信息非常多，我们就不得不做大量类型转化，这种工作没有什么技术含量，是个体力活而且很容易导致程序错误。</p>
<p>servlet另一个作用就是构造response对象，让页面获得正确的响应，其实现代的浏览器是一个多媒体工具，文字，图片，视屏等等东西都可以在浏览器里显示，资源的不同就会导致http响应报文的差别，如果我们使用servlet开发就要根据资源的不同在java程序里用硬编码的形式处理，这样的程序很难复用，而且如果程序员对某种资源的处理理解不到位，就会导致问题的出现。</p>
<p>而在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。</p>
<p>servlet里还有两个重要的技术：监听器和过滤器，对于监听器在web开发里使用的场景比较少，都是一些十分特别的情况才会使用，大部分web开发里可以忽略它的使用，我们用的最多的监听器可能就是对ServletContext创建和销毁的监听器，ServletContext是整个web应用的全局对象，它和Web应用的生命周期绑定在一起，因此使用这个监听器对Web应用的全局信息进行初始化和销毁操作，例如spring容器的初始化操作。而过滤器方面，使用SpringMVC拦截器和Struts2一样，Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口。</p>
<p><strong>下面再谈谈spring</strong><br><br>spring技术可以说是java企业开发里最重要的技术，不过真的理解spring的作用和意义还真是一件麻烦的事情，很多人对spring理解其实都是停留在使用阶段（例如：声明式事务很好用等等），当今的spring技术生态环境里可谓是蔚为壮观，spring已经包罗万象，它的内容之多完全不亚于它的本源java语言了，而spring这么大的框都是建立在ioc和aop技术之上，只有深入理解了这两个技术我们才能明白为什么spring这个框能装的下那么多东西了。</p>
<p>首先是ioc，ioc技术第一个解释叫做控制反转，它还有个解释就是依赖注入，这两个名字很难从字面理解，但是当你理解它的原理后就会发现它们的描述是何等准确。Ioc技术的本质就是构建对象的技术换句话说就是将一个类实例化成对象的技术，在java里实例化类通过new关键字进行的，每次new一个类都会产生一个新的实例对象，这么做视乎很浪费，有时这种浪费还挺危险，因为在程序开发时候我们常常只需要某个类永远只能产生一个的实例对象这个时候就得使用单例模式，此外在设计模式里还可以通过工厂方式产生对象，使用过spring的人看到上面的文字就知道了，spring里bean的定义就和上面的内容一一对应，scope属性single产生单例对象，prototype产生新对象，bean还可以通过工厂方式产生对象，可以说spring的bean就是制造对象的工具。面向对象编程里对象相当于显示生活中的一个实体，例如我们有个对象作用是完成打猎的操作，那么打猎这个对象内部包含两个辅助对象：人和枪，只有人和枪赋予了打猎这个对象，那么打猎对象才能完成打猎的操作，但是构建一个人和枪的对象并不是看起来那么简单，这里以枪为例，要创造一把枪我们需要金属，需要机床，需要子弹，而机床和子弹又是两个新对象，这些对象一个个相互嵌套相互关联，大伙试想下如果我们在java代码里构建一个枪的对象那是何其的复杂，假如我们要构造的不是简单的枪对象而是更加复杂的航空母舰，那么构造这个对象的成本之高是让人难以想象的，怎么来消除这种对象相互嵌套相互依赖的关系了？spring提供了一种方式，这种方式就是spring提供一个容器，我们在xml文件里定义各个对象的依赖关系，由容器完成对象的构建，当我们java代码里需要使用某个实例的时候就可以从容器里获取，那么对象的构建操作就被spring容器接管，所以它被称为控制反转，控制反转的意思就是本来属于java程序里构建对象的功能交由容器接管，依赖注入就是当程序要使用某个对象时候，容器会把它注入到程序里，这就叫做依赖注入。在java开发里我们想使用某个类提供的功能，有两种方式，一种就是构造一个新的类，新的类继承该类，另一种方式则是将某个类定义在新类里，那么两个类之间就建立一种关联关系，spring的ioc容器就是实现了这种关联关系（记住不是继承关系哦），那么某个类要被赋予到新类有哪些办法了？一般只有两种：一种就是通过构造函数，一种就是通过setXXX方式，这也是spring容器使用到了两种标准的注入方式。</p>
<p>不管是上面说的继承方式，还是关联方式其实都是增强目标对象能力的开发手段，在设计模式里有一种代理模式，代理模式将继承模式和关联模式结合在一起使用，代理模式就是继承模式和关联模式的综合体，不过这个综合体的作用倒不是解决对象注入的问题，而是为具体操作对象找到一个保姆或者是秘书，这就和小说里的二号首长一样，这个二号首长对外代表了具体的实例对象，实例对象的入口和出口都是通过这个二号首长，因为具体的实例对象是一号首长，一号首长是要干大事的，所以一些事务性，重复性的工作例如泡茶，安排车子，这样的工作是不用劳烦一号首长的大驾，而是二号首长帮忙解决的，这就是aop的思想，aop解决程序开发里事务性，和核心业务无关的问题，但这些问题对于业务场景的实现是很有必要的，在实际开发里aop也是节省代码的一种方式。</p>
<p>Spring的核心技术的作用本质就是一个 沟通机制，spring总是尽全力的让沟通的双方信息畅通，同时降低双方的沟通成本，在现实机构里一个善于沟通的人肯定是该公司的领导，很会沟通的领导能调动起各种资源的积极性，善于沟通的领导就会做到海纳百川，让各种不同人追随他，所以当今的spring就是一个大框，什么都可以往里装。</p>
<p>Spring很像银行，它不能直接创造物质财富，但是一切资源都要通过它进行流通，它能控制经济发展的走向，回到程序的世界，spring的作用是被标榜为程序之间的解耦，spring能降低不同模块之间的耦合度，原因就是在程序开发里不同模块之间信息的沟通是通过对象传递完成的，而对象能否顺利传递就是要合理的构建好对象，而管理好对象的构建方式就能管理好对象传递，这就是spring给系统架构设计带来的好处。</p>
<p>写啊写，找啊找，抄啊抄，结果搞了这么多。。。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Java的静态/动态绑定]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/Java%E7%9A%84%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天看到《Java核心技术I》书上的动态绑定，意思就是当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用方法是调用父类的方法还是子类的重写方法呢？程序会在运行的时候自动选择调用某个方法（根据方法表）。<br>看完这里不由自主的想到，有动态肯定也就有静态吧，于是去求助了下google，首先看了下什么是<strong>绑定</strong>:<br>绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。<br><a id="more"></a><br>然后我们分别看看两者之间含义以及差别<br><br><strong>动态绑定</strong>：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。</p>
<p><strong>动态绑定的过程</strong>：<br><br>虚拟机提取对象的实际类型的方法表；–&gt;<br>虚拟机搜索方法签名；–&gt;<br>调用方法。</p>
<p><strong>静态绑定</strong>：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。针对java，可以简单的理解为程序编译期的绑定；这里要特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。</p>
<p><strong>差别</strong>：其实上述解释可以看出很多东西了。<br><br>（1）静态绑定发生在编译时期，动态绑定发生在运行时<br><br>（2）使用private或static或final修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。<br><br>（3）静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。<br><br>（4）重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成。</p>
<p><strong>下面开始代码测试</strong>：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> class Test &#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">      <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>();</div><div class="line">      Lee lee = <span class="keyword">new</span> Lee();</div><div class="line">      lee.say(<span class="built_in">str</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> class Lee &#123;</div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> say(<span class="keyword">Object</span> obj) &#123;</div><div class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是个Object"</span>);</div><div class="line">      &#125;   </div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> say(<span class="keyword">String</span> <span class="built_in">str</span>) &#123;</div><div class="line">          System.out.<span class="built_in">println</span>(<span class="string">"这是个String"</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>执行结果</strong>：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ java <span class="keyword">Test</span></div><div class="line">这是个<span class="built_in">String</span></div></pre></td></tr></table></figure></p>
<p>在上面的代码中，lee方法存在两个重载的实现，一个是接收Object类型的对象作为参数，另一个则是接收String类型的对象作为参数。而str是一个String对象，所有接收String类型参数的call方法会被调用。而这里的绑定就是在编译时期根据参数类型进行的静态绑定。</p>
<p><strong>接着我们反编译验证一下</strong>:</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">javap -c Test    </div><div class="line">Compiled from <span class="string">"Test.java"</span></div><div class="line">public class CoreJava.day_2.Test &#123;</div><div class="line">  public CoreJava.day_2.Test();</div><div class="line">    <span class="built_in">Code</span>:</div><div class="line">       <span class="number">0</span>: aload_0</div><div class="line">       <span class="number">1</span>: invokespecial <span class="meta">#1                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span></div><div class="line"></div><div class="line">  public static void main(java.lang.<span class="keyword">String</span>[]);</div><div class="line">    <span class="built_in">Code</span>:</div><div class="line">       <span class="number">0</span>: <span class="keyword">new</span>           <span class="meta">#2                  <span class="comment">// class java/lang/String</span></span></div><div class="line">       <span class="number">3</span>: dup</div><div class="line">       <span class="number">4</span>: invokespecial <span class="meta">#3                  <span class="comment">// Method java/lang/String."&lt;init&gt;":()V</span></span></div><div class="line">       <span class="number">7</span>: astore_1</div><div class="line">       <span class="number">8</span>: <span class="keyword">new</span>           <span class="meta">#4                  <span class="comment">// class CoreJava/day_2/Test$Lee</span></span></div><div class="line">      <span class="number">11</span>: dup</div><div class="line">      <span class="number">12</span>: invokespecial <span class="meta">#5                  <span class="comment">// Method CoreJava/day_2/Test$Lee."&lt;init&gt;":()V</span></span></div><div class="line">      <span class="number">15</span>: astore_2</div><div class="line">      <span class="number">16</span>: aload_2</div><div class="line">      <span class="number">17</span>: aload_1</div><div class="line">      <span class="number">18</span>: invokevirtual <span class="meta">#6                  <span class="comment">// Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V</span></span></div><div class="line">      <span class="number">21</span>: <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>看到了这一行18: invokevirtual #6                  // Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V确实是发生了静态绑定，确定了调用了接收String对象作为参数的say方法。</p>
<p><strong>现在可以改写一下</strong>：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line">      String <span class="keyword">str</span> = <span class="keyword">new</span> String();</div><div class="line">      Lee lee = <span class="keyword">new</span> SecLee();</div><div class="line">      lee.say(<span class="keyword">str</span>);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Lee</span> </span>&#123;</div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> say(String <span class="keyword">str</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"这是个String"</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SecLee</span> <span class="keyword">extends</span> <span class="title">Lee</span> </span>&#123;</div><div class="line">      @Override</div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> say(String <span class="keyword">str</span>) &#123;</div><div class="line">          System.out.println(<span class="string">"这是第二李的String"</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果为</strong>：</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ java <span class="keyword">Test</span></div><div class="line">这是第二李的<span class="built_in">String</span></div></pre></td></tr></table></figure>
<p>上面，用SecLee继承了Lee，并且重写了say方法。我们声明了一个Lee类型的变量lee，但是这个变量指向的是他的子类SecLee。根据结果可以看出，其调用了SecLee的say方法实现，而不是Lee的say方法。这一结果的产生的原因是因为在运行时发生了动态绑定，在绑定过程中需要确定调用哪个版本的say方法实现。</p>
<p><strong>再看看反编译的结果</strong>：</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">javap -c Test</div><div class="line">警告: 二进制文件Test包含CoreJava.day_2.Test</div><div class="line">Compiled from <span class="string">"Test.java"</span></div><div class="line">public class CoreJava.day_2.Test &#123;</div><div class="line">  public CoreJava.day_2.Test();</div><div class="line">    <span class="built_in">Code</span>:</div><div class="line">       <span class="number">0</span>: aload_0</div><div class="line">       <span class="number">1</span>: invokespecial <span class="meta">#1                  <span class="comment">// Method java/lang/Object."&lt;init&gt;":()V</span></span></div><div class="line">       <span class="number">4</span>: <span class="keyword">return</span></div><div class="line"></div><div class="line">  public static void main(java.lang.<span class="keyword">String</span>[]);</div><div class="line">    <span class="built_in">Code</span>:</div><div class="line">       <span class="number">0</span>: <span class="keyword">new</span>           <span class="meta">#2                  <span class="comment">// class java/lang/String</span></span></div><div class="line">       <span class="number">3</span>: dup</div><div class="line">       <span class="number">4</span>: invokespecial <span class="meta">#3                  <span class="comment">// Method java/lang/String."&lt;init&gt;":()V</span></span></div><div class="line">       <span class="number">7</span>: astore_1</div><div class="line">       <span class="number">8</span>: <span class="keyword">new</span>           <span class="meta">#4                  <span class="comment">// class CoreJava/day_2/Test$SecLee</span></span></div><div class="line">      <span class="number">11</span>: dup</div><div class="line">      <span class="number">12</span>: invokespecial <span class="meta">#5                  <span class="comment">// Method CoreJava/day_2/Test$SecLee."&lt;init&gt;":()V</span></span></div><div class="line">      <span class="number">15</span>: astore_2</div><div class="line">      <span class="number">16</span>: aload_2</div><div class="line">      <span class="number">17</span>: aload_1</div><div class="line">      <span class="number">18</span>: invokevirtual <span class="meta">#6                  <span class="comment">// Method CoreJava/day_2/Test$Lee.say:(Ljava/lang/String;)V</span></span></div><div class="line">      <span class="number">21</span>: <span class="keyword">return</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>正如上面的结果，18: invokevirtual #6                  // Method CoreJava/day_2/Test Lee.say:(Ljava/lang/String;)V这里是TestLee.say而非Test$SecLee.say，因为编译期无法确定调用子类还是父类的实现，所以只能丢给运行时的动态绑定来处理。</p>
<p>既然重写测试了，<strong>那我们再试试重载</strong>：</p>
<p>下面的例子更复杂！Lee类中存在say方法的两种重载，更复杂的是SecLee集成Lee并且重写了这两个方法。其实这种情况是上面两种情况的复合情况。<br>下面的代码首先会发生静态绑定，确定调用参数为String对象的say方法，然后在运行时进行动态绑定确定执行子类还是父类的say实现。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">      String str = <span class="keyword">new</span> String();</div><div class="line">      Lee lee = <span class="keyword">new</span> SecLee();</div><div class="line">      lee.say(str);</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">Lee</span> &#123;</div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params">Object obj</span>) </span>&#123;</div><div class="line">          System.<span class="keyword">out</span>.println(<span class="string">"这是Object"</span>);</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params">String str</span>) </span>&#123;</div><div class="line">          System.<span class="keyword">out</span>.println(<span class="string">"这是String"</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">  </div><div class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">SecLee</span> <span class="title">extends</span> <span class="title">Lee</span> &#123;</div><div class="line">      @<span class="function">Override</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params">Object obj</span>) &#123;</div><div class="line">          System.<span class="keyword">out</span>.println(<span class="string">"这是第二李的Object"</span>);</div><div class="line">      &#125;</div><div class="line">      </div><div class="line">      @<span class="function">Override</span></div><div class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params">String str</span>) &#123;</div><div class="line">          System.<span class="keyword">out</span>.println(<span class="string">"这是第二李的String"</span>);</div><div class="line">      &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>结果</strong>:</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ java <span class="keyword">Test</span></div><div class="line">这是第二李的<span class="built_in">String</span></div></pre></td></tr></table></figure>
<p>结果在意料之中，就不多说了。</p>
<p>那么问题来了，<font color="red"><strong>非动态绑定不可么？</strong></font><br>其实某些方法的绑定也可以由静态绑定实现，比如说：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">      <span class="keyword">String</span> <span class="built_in">str</span> = <span class="keyword">new</span> <span class="keyword">String</span>();</div><div class="line">      <span class="keyword">final</span> Lee lee = <span class="keyword">new</span> SecLee();</div><div class="line">      lee.say(<span class="built_in">str</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>可以看出，这里lee持有SecLee的对象并且lee变量为final，立即执行了say方法，编译器理论上通过足够的分析代码，是可以知道应该调用SecLee的say方法。</p>
<p><strong>结论：</strong><br>由于动态绑定需要在运行时确定执行哪个版本的方法实现或者变量，比起静态绑定起来要耗时，所以正如书上所说的，有些程序员认为，除非有足够的理由使用多态性，应该把所有的方法都声明为final，private或者static进行修饰。我觉得这个有点偏激了，具体使用仁者见仁，智者见智吧。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 静态动态绑定 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[mysql 如何插入一列自增序号]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/mysql-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E4%B8%80%E5%88%97%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%8F%B7/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天看到朋友问的一个问题，“mysql 加一列 叫序号 然后序号自增 怎么搞？”,由于他主要用的是oracle，所以不太了解mysql的用法，然后我就告诉他用rownum就好了，但是他说用了这个没得到效果。<br><a id="more"></a><br>我想了一下 没啥啊。他说他就想在查询结果中加一个序号列 实现自增，于是我自己建了张表实验一下。</p>
<p><img src="http://img.blog.csdn.net/20161124164205404" alt="这里写图片描述"></p>
<p>只给了id和name两个字段，方便测试。</p>
<p><img src="http://img.blog.csdn.net/20161124164414499" alt="这里写图片描述"></p>
<p>随便插入了几条数据（设置了utf-8的格式输入中文就直接???了 不知道怎么回事，估计是数据库编码有点问题，先用英文凑合一下。）</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">select</span> @rd := @rd+<span class="number">1</span>  <span class="keyword">as</span> <span class="keyword">rownum</span>, b.name <span class="keyword">from</span> (<span class="keyword">select</span> @rd:=<span class="number">0</span>, <span class="keyword">name</span> <span class="keyword">from</span> <span class="keyword">test</span>) b</div></pre></td></tr></table></figure>
<p>取出name属性，然后给变量rd自增1赋给rownum，看结果：</p>
<p><img src="http://img.blog.csdn.net/20161124164635603" alt="这里写图片描述"></p>
<p>然后，然后就这么成了 -。- 用变量累加，插入有自增字段的临时表中、如果有唯一标识的字段，也可以用查询解决。</p>
]]></content>
      
        <categories>
            
            <category> 数据库那点事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> mysql </tag>
            
            <tag> 自增序号 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于Ajax的cache参数的测试]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E5%85%B3%E4%BA%8EAjax%E7%9A%84cache%E5%8F%82%E6%95%B0%E7%9A%84%E6%B5%8B%E8%AF%95/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>&nbsp;&nbsp;其实这次做这个测试是因为和同学谈论@requestbody时引发的一个笑话，我之前一直以为ajax中的<code>dataType: &#39;json&#39;</code>是传输去后台的数据格式，后来分分钟被打脸，查了一下百度，才知道原来<code>dataType: &#39;json&#39;</code>是期望返回的数据类型，由此才发现原来ajax并没有平常用的那么简单。<br><a id="more"></a><br>首先我们来看一下什么是Ajax：<br>AJAX = 异步 JavaScript 和 XML。<br>AJAX 是一种用于创建快速动态网页的技术。<br>通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。<br>传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。<br>有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。(以上来自w3cschool)</p>
<p>在看这些资料的过程中，一个参数引起了我的注意：<strong>cache</strong> 这个cache有true和false两个方向，<font color="red">显式的要求如果当前请求有缓存的话，直接使用缓存。如果该属性设置为 false，则每次都会向服务器请求</font>。由此我做了下面的测试：</p>
<p>首先创建一个servlet，用来接收客户端发来的请求</p>
<p>AjaxServlet.java</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AjaxServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void doGet(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</div><div class="line">        <span class="type">System</span>.out.println(<span class="string">"进入了servlet!"</span>);</div><div class="line">        resp.setContentType(<span class="string">"text/html;charset=UTF-8"</span>);</div><div class="line">        <span class="type">PrintWriter</span> out = resp.getWriter();</div><div class="line">        int a = <span class="number">1</span>;</div><div class="line">        out.print(a);</div><div class="line">        out.flush();</div><div class="line">        out.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="keyword">protected</span> void doPost(<span class="type">HttpServletRequest</span> req, <span class="type">HttpServletResponse</span> resp) <span class="keyword">throws</span> <span class="type">ServletException</span>, <span class="type">IOException</span> &#123;</div><div class="line">        doGet(req, resp);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里做出了标记，如果请求进来了，控制台会输出”进入了servlet”</p>
<p>然后创建一个Jsp用来发出请求：<br>ajaxTest.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">%</span> <span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();</span> %&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Title<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"ajaxBtn"</span> <span class="attr">value</span>=<span class="string">"点我试试~"</span>&gt;</span>点我试试~<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"jquery.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    $(<span class="string">"#ajaxBtn"</span>).click(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">        $.ajax(&#123;</div><div class="line">            <span class="attr">url</span>: <span class="string">"&lt;%=path%&gt;/AjaxServlet"</span>,</div><div class="line">            <span class="attr">type</span>: <span class="string">'get'</span>,</div><div class="line">            <span class="attr">cache</span>: <span class="literal">true</span>,</div><div class="line">            <span class="attr">success</span>: <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">                alert(data);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;)</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<p>这里点击这个按钮可以出发一个get请求，我们把cache设置为了true，这样会在浏览器缓存中加载请求信息。</p>
<p><img src="http://img.blog.csdn.net/20161123204951948" alt="这里写图片描述"></p>
<p><img src="http://img.blog.csdn.net/20161123205002870" alt=""><br></p>
<p>可以看出第一次成功进入了servlet，前台也alert出了这个返回的值。</p>
<p>接着我们点击第二次，发现居然还是进入了servlet!!!!!<br><br><img src="http://img.blog.csdn.net/20161123205119785" alt="这里写图片描述"><br><br><br>这是怎么回事呢？ 没办法只能继续踏上百度谷歌之路，经过查找发现，在IE浏览器下，可以实现这个功能，点击两次，第二次就不再进入servlet了。<br><br><img src="http://img.blog.csdn.net/20161123205002870" alt=""><br><br><br>不过，并不鼓励使用cache:true,因为ajax是实时获取数据的，所以不太适合从缓存中加载信息，我想也正是因为这个原因，谷歌 safari浏览器实现不了这个功能吧，那么问题来了为什么ie还可以这么坚挺？（日常吐槽）。</p>
<p>附：ajax其他参数<br><br><strong>参数：</strong><br>url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。<br>type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。<br>timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。<br>async：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。<br>cache：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息。<br>data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看processData选项。对象必须为key/value格<br> 式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。<br>dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。<br>          可用的类型如下：<br><br>          xml：返回XML文档，可用JQuery处理。<br><br>          html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。<br><br>          script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。<br><br>          json：返回JSON数据。<br><br>          jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。<br><br>          text：返回纯文本字符串。<br>beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义。<br>            HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Ajax </tag>
            
            <tag> cache </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM常量池及字符串==比较分析]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/JVM%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有的话就创建一个），这样在我们需要重复创建相等变量节省了很多时间。<br><br>&nbsp;&nbsp;常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。String类是java中用的比较多的类，同样为了创建String对象的方便，该类也实现了常量池的技术。<br><br><a id="more"></a><br>在讲述常量池之前，我们有必要先说说<font color="red">JVM运行时数据区的内存模型</font>。<br><br>JVM运行时数据区的内存模型由五部分组成:<br><br>1.方法区<br>2.堆<br>3.JAVA栈<br>4.PC寄存器<br>5.本地方法栈</p>
<p>例如对于<figure class="highlight plain"><figcaption><span>s = "haha"``` ,它的虚拟机指令：</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">```</div><div class="line">0:   ldc     #16; //String haha    </div><div class="line">2:   astore_1 </div><div class="line">3:   return</div></pre></td></tr></table></figure></p>
<p>从上面的ldc指令的执行过程可以得出：s的值是来自被拘留String对象（由解析该入口的进程产生）的引用，即可以理解为是从被拘留String对象的引用复制而来的，故我个人的理解是s的值是存在栈当中。上面是对于s值得分析，接着是对于”haha”值的分析,我们知道，对于String s = “haha” 其中”haha”值在JAVA程序编译期就确定下来了的。简单一点说，就是haha的值在程序编译成class文件后，就在class文件中生成了。执行JAVA程序的过程中，第一步是class文件生 成，然后被JVM装载到内存执行。那么JVM装载这个class到内存中，其中的haha这个值，在内存中是怎么为其开辟空间并存储在哪个区域中呢？</p>
<p>&nbsp;&nbsp;首先我们不妨先来了解一下JVM常量池这个结构,这里我查询了一些资料,在资料中这样描述<strong>常量池</strong>:<br><br>虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。</p>
<p>下面讲讲<strong>八种基本类型的包装类和对象池</strong></p>
<p>Java中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外 Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。一些对应的测试代码：<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> Test &#123;</div><div class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</div><div class="line"><span class="comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span></div><div class="line"><span class="comment">//在值小于127时可以使用常量池</span></div><div class="line">        Integer i1 = <span class="number">127</span>;</div><div class="line">        Integer i2 = <span class="number">127</span>;</div><div class="line">        Sstem.out.<span class="keyword">println</span>(i1 == i2); <span class="comment">//输出true  </span></div><div class="line"><span class="comment">//值大于127时，不会从常量池中取对象</span></div><div class="line">        Integer i3 = <span class="number">128</span>;</div><div class="line">        Integer i4 = <span class="number">128</span>;</div><div class="line">        System.out.<span class="keyword">println</span>(i3 == i4); <span class="comment">//输出false  </span></div><div class="line"><span class="comment">//Boolean类也实现了常量池技术</span></div><div class="line">        <span class="keyword">Boolean</span> bool1 = <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">Boolean</span> bool2 = <span class="keyword">true</span>;</div><div class="line">        System.out.<span class="keyword">println</span>(bool1 == bool2); <span class="comment">//输出true  </span></div><div class="line"><span class="comment">//浮点类型的包装类没有实现常量池技术</span></div><div class="line">        <span class="keyword">Double</span> d1 = <span class="number">1.0</span>;</div><div class="line">        <span class="keyword">Double</span> d2 = <span class="number">1.0</span>;</div><div class="line">        System.out.<span class="keyword">println</span>(d1 == d2); <span class="comment">//输出false  </span></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><strong>对Integer对象的代码补充</strong><br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function">Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</div><div class="line">       <span class="keyword">final</span> <span class="keyword">int</span> offset = <span class="number">128</span>;</div><div class="line">       <span class="keyword">if</span> (i &gt;= <span class="number">-128</span> &amp;&amp; i &lt;= <span class="number">127</span>) &#123;</div><div class="line">           <span class="keyword">return</span> IntegerCache.cache[i + offset];</div><div class="line">       &#125;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</div><div class="line">   &#125;</div></pre></td></tr></table></figure></p>
<p>当你直接给一个Integer对象一个int值的时候，其实它调用了valueOf方法，然后你赋的这个值很特别，是128，那么没有进行cache方法，相当于new了两个新对象。所以问题中定义a、b的两句代码就类似于：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">Integer</span> a = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">128</span>);</div><div class="line"></div><div class="line"><span class="built_in">Integer</span> b = <span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">128</span>);</div></pre></td></tr></table></figure>
<p>这个时候再问你，输出结果是什么？你就知道是false了。如果把这个数换成127，再执行：</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Integer a = <span class="number">127</span><span class="comment">;</span></div><div class="line"></div><div class="line">Integer <span class="keyword">b </span>= <span class="number">127</span><span class="comment">;</span></div><div class="line"></div><div class="line">System.out.println(a == <span class="keyword">b);</span></div><div class="line"></div><div class="line">结果就是：true</div></pre></td></tr></table></figure>
<p>进行对象比较时最好还是使用equals，便于按照自己的目的进行控制。这里引出equals()和= =,equals比较的是字符串字面值即比较内容,==比较引用。</p>
<p><strong>看一下IntegerCache这个类里面的内容：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</div><div class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[] = <span class="keyword">new</span> Integer[-(-<span class="number">128</span>) + <span class="number">127</span> + <span class="number">1</span>];</div><div class="line"></div><div class="line">        <span class="keyword">static</span> &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cache.length; i++)</div><div class="line">                cache[i] = <span class="keyword">new</span> Integer(i - <span class="number">128</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>由于cache[]在IntegerCache类中是静态数组，也就是只需要初始化一次，即static{……}部分，所以，如果Integer 对象初始化时是-128~127的范围，就不需要再重新定义申请空间，都是同一个对象—在IntegerCache.cache中，这样可以在一定程度上提高效率。</p>
<p><strong>针对String方面的补充</strong></p>
<p>在同包同类下,引用自同一String对象.<br><br>在同包不同类下,引用自同一String对象.<br><br>在不同包不同类下,依然引用自同一String对象.<br><br>在编译成.class时能够识别为同一字符串的,自动优化成常量,所以也引用自同一String对象.<br><br>在运行时创建的字符串具有独立的内存地址,所以不引用自同一String对象.<br><br>String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,<br><br>如果有则返回一个引用,没有则添加自己的字符串进入常量池，注意：只是字符串部分。 所以这时会存在2份拷贝，常量池的部分被String类私有并管理，自己的那份按对象生命周期继续使用。</p>
<p>在介绍完JVM常量池的相关概念后，接着谈开始提到的”haha”的值的内存分布的位置。对于haha的值，实际上是在class文件被JVM装载到内存 当中并被引擎在解析ldc指令并执行ldc指令之前，JVM就已经为haha这个字符串在常量池的CONSTANT_String_info表中分配了空 间来存储haha这个值。既然haha这个字符串常量存储在常量池中，根据《深入JAVA虚拟机》书中描述：常量池是属于类型信息的一部分，类型信息也就 是每一个被转载的类型，这个类型反映到JVM内存模型中是对应存在于JVM内存模型的方法区中，也就是这个类型信息中的常量池概念是存在于在方法区中，而 方法区是在JVM内存模型中的堆中由JVM来分配的。所以，haha的值是应该是存在堆空间中的。</p>
<p>而对于<figure class="highlight plain"><figcaption><span>s = new String("haha")``` ,它的JVM指令：<br></span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"></div></pre></td></tr></table></figure></p>
<p>0:   new     #16; //class String<br>3:   dup<br>4:   ldc     #18; //String haha<br>6:   invokespecial   #20; //Methodjava/lang/String.””:(Ljava/lang/String;)V<br>9:   astore_1<br>10:  return<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;br&gt;</div><div class="line">通过上面<span class="number">6</span>个指令，可以看出，<span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"haha"</span>);中的haha存储在堆空间中，而s则是在操作数栈中。 </div><div class="line">上面是对s和haha值的内存情况的分析和理解；那对于<span class="keyword">String</span> s = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"haha"</span>);语句,到底创建了几个对象呢? </div><div class="line">我的理解：这里<span class="string">"haha"</span>本身就是常量池中的一个对象，而在运行时执行<span class="keyword">new</span> <span class="keyword">String</span>()时，将常量池中的对象复制一份放到堆中，并且把堆中的这个对象的引用交给s持有。所以这条语句就创建了<span class="number">2</span>个<span class="keyword">String</span>对象。如下图所示：&lt;br&gt;</div><div class="line">&lt;img src=<span class="string">"http://static.open-open.com/lib/uploadImg/20121021/20121021191840_830.jpg"</span>&gt;</div><div class="line"></div><div class="line"></div><div class="line">**<span class="keyword">String</span> 常量池问题的几个例子：**&lt;br&gt;</div><div class="line">【<span class="number">1</span>】</div></pre></td></tr></table></figure></p>
<p>String a = “a1”;<br>String b = “a” + 1;<br>System.out.println((a == b)); //result = true<br>String a = “atrue”;<br>String b = “a” + “true”;<br>System.out.println((a == b)); //result = true<br>String a = “a3.4”;<br>String b = “a” + 3.4;<br>System.out.println((a == b)); //result = true<br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">分析：JVM对于字符串常量的<span class="string">"+"</span>号连接，将程序编译期，JVM就将常量字符串的<span class="string">"+"</span>连接优化为连接后的值，拿<span class="string">"a"</span> + <span class="number">1</span>来说，经编译器优化后在<span class="class"><span class="keyword">class</span>中就已经是<span class="title">a1</span>。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为<span class="title">true</span>。&lt;br&gt;</span></div><div class="line"></div><div class="line">【<span class="number">2</span>】</div></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>String bb = “b”;<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = false<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">分析：<span class="type">JVM</span>对于字符串引用，由于在字符串的<span class="comment">"+"</span>连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即<span class="comment">"a"</span> + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为<span class="keyword">false</span>。</div><div class="line"></div><div class="line">【<span class="number">3</span>】</div></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>final String bb = “b”;<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = true<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">分析：和[<span class="number">3</span>]中唯一不同的是bb字符串加了<span class="keyword">final</span>修饰，对于<span class="keyword">final</span>修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或 嵌入到它的字节码流中。所以此时的<span class="string">"a"</span> + bb和<span class="string">"a"</span> + <span class="string">"b"</span>效果是一样的。故上面程序的结果为<span class="literal">true</span>。</div><div class="line"></div><div class="line">【<span class="number">4</span>】</div></pre></td></tr></table></figure></p>
<p>String a = “ab”;<br>final String bb = getBB();<br>String b = “a” + bb;<br>System.out.println((a == b)); //result = false<br>private static String getBB() {<br>return “b”;<br>}<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和<span class="string">"a"</span>来动态连接并分配地址为b，故上面程序的结果为<span class="keyword">false</span>。</div><div class="line"></div><div class="line"></div><div class="line">通过上面<span class="number">4</span>个例子可以得出得知：&lt;<span class="keyword">br</span>&gt;</div></pre></td></tr></table></figure></p>
<p>String  s  =  “a” + “b” + “c”;等价于String s = “abc”</p>
<p>这个就不一样了，最终结果等于:<br>StringBuffer temp = new StringBuffer();<br>temp.append(a).append(b).append(c);<br>String s = temp.toString();<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">由上面的分析结果，可就不难推断出<span class="keyword">String</span> 采用连接运算符（+）效率低下原因分析，形如这样的代码：</div></pre></td></tr></table></figure></p>
<p> public static void main(String args[]) {<br>        String s = null;<br>        for (int i = 0; i &lt; 100; i++) {<br>            s += “a”;<br>        }<br>    }<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">每做一次 + 就产生个StringBuilder对象，然后<span class="built_in">append</span>后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 <span class="built_in">append</span> 字符串，如此循环直至结束。 如果我们直接采用 StringBuilder 对象进行 <span class="built_in">append</span> 的话，我们可以节省 N - <span class="number">1</span> 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行 <span class="built_in">append</span>操作。</div><div class="line"></div><div class="line">最后贴一个<span class="keyword">String</span>对象的intern方法理解和分析，这是今天在群里看到的一个题目，也可以说是这篇博客的印子吧：</div></pre></td></tr></table></figure></p>
<p>public class Test {<br>    private static String a = “ab”;<br>    public static void main(String[] args) {<br>        String s1 = “a”;<br>        String s2 = “b”;<br>        String s = s1 + s2;<br>        System.out.println(s == a);//false<br>        System.out.println(s.intern() == a);//true<br>    }<br>}<br>```</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 常量池 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于多线程的饥饿和公平]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A5%A5%E9%A5%BF%E5%92%8C%E5%85%AC%E5%B9%B3/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>偶然学习到多线程，看到多线程的饥饿和公平，觉得可以写点什么。<br><br>什么是饥饿什么是公平呢？如果一个线程因为CPU运行时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性”，即所有线程均能公平地获得运行机会。<br><br><a id="more"></a><br>&nbsp;&nbsp;<strong>首先我们要知道，什么原因导致了“饥饿”？在Java方面我觉的分为了三种情况:</strong><br><br>&nbsp;&nbsp;①.线程中高优先级的吞噬所有的低优先级的CPU时间。<br><br>&nbsp;&nbsp;你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。所以对大多数应用来说，你最好是不要改变其优先级值。<br><br>&nbsp;&nbsp;②线程被永久堵塞在一个等待进入同步块的状态<br><br>&nbsp;&nbsp;Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。<br><br>&nbsp;&nbsp;③.线程被永久堵塞在一个等待进入同步块的状态<br><br>&nbsp;&nbsp;如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。</p>
<p>&nbsp;&nbsp;<strong>如何在Java中实现公平？</strong><br>无论哪里都不可能实现100%公平，所以我们只能提出比较好的方案来达到目的，首先可以通过同步结构来实现公平性的提高。<br><br>先来一段简单的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Synchronizer</span></span>&#123;  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doSynchronized</span><span class="params">()</span></span>&#123;  </div><div class="line">    <span class="comment">//需要运行很长时间的某些代码</span></div><div class="line">  &#125;    </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;如果有多个线程调用了doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。<br><br>&nbsp;&nbsp;<strong>现在我们使用<font color="red">锁方式替代同步块</font>来试试:</strong><br><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Synchronizer</span>&#123;  </div><div class="line">  Lock <span class="keyword">lock</span> = <span class="keyword">new</span> Lock();   </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSynchronized</span>(<span class="params"></span>) throws InterruptedException</span>&#123;  </div><div class="line">    <span class="keyword">this</span>.<span class="keyword">lock</span>.<span class="keyword">lock</span>();  <span class="comment">//当前线程锁住lock对象  </span></div><div class="line">      <span class="comment">//时间临界区</span></div><div class="line">    <span class="keyword">this</span>.<span class="keyword">lock</span>.unlock();  <span class="comment">//当前线程释放lock对象上的锁  </span></div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;我们可以注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。<br>下面是用Lock类做的一个实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Lock</span></span>&#123;  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked      = <span class="keyword">false</span>;  <span class="comment">//是否加过锁的信号  </span></div><div class="line">  <span class="keyword">private</span> Thread  lockingThread = <span class="keyword">null</span>;   <span class="comment">//进行加锁的线程  </span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  </div><div class="line">    <span class="keyword">while</span>(isLocked)&#123;  <span class="comment">//如果lock对象已被其他线程加锁了（线程已经退出了本lock()方法）  </span></div><div class="line">      wait();  <span class="comment">//当前线程阻塞，它释放锁对象上的锁，其他线程可以再进入本lock()  </span></div><div class="line">    &#125;  </div><div class="line">    isLocked = <span class="keyword">true</span>;  <span class="comment">//如果没加锁，则当前线程对锁对象加锁  </span></div><div class="line">    lockingThread = Thread.currentThread();  </div><div class="line">  &#125;  </div><div class="line"> </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;  </div><div class="line">    <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123;  <span class="comment">//如果调用lock()加锁的不是当前线程  </span></div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException(  </div><div class="line">        <span class="string">"所调用线程尚未锁定"</span>);  </div><div class="line">    &#125;  </div><div class="line">    isLocked = <span class="keyword">false</span>;  <span class="comment">//释放锁，标记为未加锁  </span></div><div class="line">    lockingThread = <span class="keyword">null</span>;  </div><div class="line">    notify();  <span class="comment">//通知阻塞在锁对象上的线程队列，唤醒其中某一个线程  </span></div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>&nbsp;&nbsp;注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果isLocked=true时，表示锁已被锁上，这些线程将阻塞在while(isLocked)循环的wait()调用里面。要注意的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。<br><br>&nbsp;&nbsp;我们回头看doSynchronized()方法，可以看到在lock()和unlock()之间：一段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。<br><br>&nbsp;&nbsp;由于同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。<br><br>&nbsp;&nbsp;但我们能改变这种情况。当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。<br><br>&nbsp;&nbsp;<strong>下面看看如何把Lock类转变为公平锁FairLock</strong>。<br><br>&nbsp;&nbsp;新的实现和之前的Lock类中的同步和wait()/notify()将会稍有不同。<br>每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FairLock</span> </span>&#123;  </div><div class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;  <span class="comment">//是否加锁的信号  </span></div><div class="line">    <span class="keyword">private</span> Thread lockingThread = <span class="keyword">null</span>;   <span class="comment">//加锁的线程  </span></div><div class="line">    <span class="keyword">private</span> List&lt;QueueObject&gt; waitingThreads =  </div><div class="line">            <span class="keyword">new</span> ArrayList&lt;QueueObject&gt;();   <span class="comment">//信号量队列  </span></div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span>&#123;  <span class="comment">//多个线程可同时进入  </span></div><div class="line">    QueueObject queueObject = <span class="keyword">new</span> QueueObject();  <span class="comment">//局部对象，线程安全  </span></div><div class="line">    <span class="keyword">boolean</span> isLockedForThisThread = <span class="keyword">true</span>;  <span class="comment">//是否为当前线程加锁  </span></div><div class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;  <span class="comment">//将当前线程（用信号量）推入队列  </span></div><div class="line">        waitingThreads.add(queueObject);  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    <span class="keyword">while</span>(isLockedForThisThread)&#123;  </div><div class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;  <span class="comment">//加锁操作需要同步  </span></div><div class="line">          <span class="comment">//锁状态依然被检查和设置，以避免出现滑漏条件  </span></div><div class="line">          isLockedForThisThread = isLocked || waitingThreads.get(<span class="number">0</span>) != queueObject;  </div><div class="line">          <span class="keyword">if</span>(!isLockedForThisThread)&#123; <span class="comment">//如果对象未加锁且队列头部是当前线程  </span></div><div class="line">              isLocked = <span class="keyword">true</span>; <span class="comment">//加锁  </span></div><div class="line">              waitingThreads.remove(queueObject); <span class="comment">//从队列中移除当前线程  </span></div><div class="line">              lockingThread = Thread.currentThread(); <span class="keyword">return</span>;   </div><div class="line">          &#125;   </div><div class="line">        &#125;   </div><div class="line">        <span class="keyword">try</span>&#123; <span class="comment">//放在同步块之外，避免monitor嵌套锁死   </span></div><div class="line">            queueObject.doWait(); <span class="comment">//监视器对象（持有信号量isNotified）等待  </span></div><div class="line">        &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;   </div><div class="line">           <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123; waitingThreads.remove(queueObject); &#125;   </div><div class="line">            <span class="keyword">throw</span> e;   </div><div class="line">        &#125;   </div><div class="line">    &#125;   </div><div class="line">  &#125;   </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span>&#123;   </div><div class="line">      <span class="keyword">if</span>(<span class="keyword">this</span>.lockingThread != Thread.currentThread())&#123; <span class="comment">//加锁的不是当前线程   </span></div><div class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException( <span class="string">"该线程尚未锁"</span>);   </div><div class="line">      &#125;   </div><div class="line">      isLocked = <span class="keyword">false</span>; <span class="comment">//解锁   </span></div><div class="line">      lockingThread = <span class="keyword">null</span>;   </div><div class="line">      <span class="keyword">if</span>(waitingThreads.size() &gt; <span class="number">0</span>)&#123; <span class="comment">//唤醒第一个线程   </span></div><div class="line">          waitingThreads.get(<span class="number">0</span>).doNotify();   </div><div class="line">      &#125;   </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QueueObject</span> </span>&#123;  </div><div class="line">  </div><div class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> isNotified = <span class="keyword">false</span>;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doWait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;  </div><div class="line">    <span class="keyword">while</span>(!isNotified)&#123;  </div><div class="line">        <span class="keyword">this</span>.wait();  </div><div class="line">    &#125;  </div><div class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">false</span>;  </div><div class="line">  &#125;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">doNotify</span><span class="params">()</span> </span>&#123;  </div><div class="line">    <span class="keyword">this</span>.isNotified = <span class="keyword">true</span>;  </div><div class="line">    <span class="keyword">this</span>.notify();  </div><div class="line">  &#125;  </div><div class="line">  </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;  </div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span> == o;  </div><div class="line">  &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;首先注意到lock()方法不再声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。<br><br>&nbsp;&nbsp;FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程都将其QueueObject实例推入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。<br><br>&nbsp;&nbsp;请注意，<font color="red">在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件</font>。<br><br>&nbsp;&nbsp;还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以进入unlock()来解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。<br><br>&nbsp;&nbsp;最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。<br><br><strong>性能考虑<br></strong><br>&nbsp;&nbsp;如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 饥饿 </tag>
            
            <tag> 公平 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[实验插入b站h5播放器]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E5%AE%9E%E9%AA%8C%E6%8F%92%E5%85%A5b%E7%AB%99h5%E6%92%AD%E6%94%BE%E5%99%A8/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>Hexo 插 B 站的播放器很简单，在 md 文档中插个 iframe 标签就行，aid 和 cid 值需要手动填写，播放器大小可以自己调节：</p>
<blockquote>
<p>B 站每个视频都有对应的 aid 和 cid 值，在视频网页的源代码中可以找到</p>
</blockquote>
<a id="more"></a>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;<span class="selector-tag">iframe</span> src=<span class="string">"https://www.bilibili.com/html/html5player.html?aid=3521416&amp;cid=6041635"</span> <span class="attribute">width</span>=<span class="string">"960"</span> height=<span class="string">"600"</span> frameborder=<span class="string">"0"</span> webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;</div></pre></td></tr></table></figure>
<p><br></p>
<iframe src="https://www.bilibili.com/html/html5player.html?aid=3521416&cid=6041635" width="960" height="600" frameborder="0" webkitallowfullscreen="" mozallowfullscreen="" allowfullscreen></iframe>

]]></content>
      
        <categories>
            
            <category> 博客 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 小插件 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JVM虚拟机关于“不使用的对象手动赋值为null”的理解]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E4%BA%8E%E2%80%9C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC%E4%B8%BAnull%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>今天逛博客,看到了一个关于<code>一个对象有没有必要手动赋值为null</code>的问题，捋了捋思路，决定写个测试代码来实践一下。<br><a id="more"></a><br><br><br>百说不如一用，直接上代码:<br><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test1</span> &#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];<span class="comment">//作用就是向内存中填充一个10MB的对象</span></div><div class="line">		System.gc();<span class="comment">//手动执行GC操作</span></div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行程序前，可以将JVM参数设置为如下:<br><br>-verbose:gc<br><br>-XX:+PrintGCDetails<br><br>控制台部分输出结果如下:<br><br><figure class="highlight scheme"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[<span class="name">GC</span> (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">3932</span>K-&gt;744K(<span class="name">76288K</span>)] <span class="number">69468</span>K-&gt;66288K(<span class="name">251392K</span>), <span class="number">0.0016500</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.03, real=0.00 secs] </div><div class="line">[<span class="name">Full</span> GC (<span class="name">System.gc</span>()) [<span class="name">PSYoungGen:</span> <span class="number">744</span>K-&gt;0K(<span class="name">76288K</span>)] [<span class="name">ParOldGen:</span> <span class="number">65544</span>K-&gt;66145K(<span class="name">175104K</span>)] <span class="number">66288</span>K-&gt;66145K(<span class="name">251392K</span>), [<span class="name">Metaspace:</span> <span class="number">3169</span>K-&gt;3169K(<span class="name">1056768K</span>)], <span class="number">0.0101306</span> secs] [<span class="name">Times:</span> user=0.00 sys=0.00, real=0.01 secs]</div></pre></td></tr></table></figure></p>
<p>根据ParOldGen: 65544K-&gt;66145K(175104K)可以看出，bytes对象并没有因为没有使用而被gc回收。<br><br><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test2</span> &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * -verbose:GC</div><div class="line">	 * -XX:+PrintGCDetails</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		&#123;</div><div class="line">	           <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">		&#125;</div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>控制台输出结果如下:<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc()) [PSYoungGen: <span class="number">3932</span><span class="keyword">K</span>-&gt;<span class="number">776</span><span class="keyword">K</span>(<span class="number">76288</span><span class="keyword">K</span>)] <span class="number">69468</span><span class="keyword">K</span>-&gt;<span class="number">66320</span><span class="keyword">K</span>(<span class="number">251392</span><span class="keyword">K</span>), <span class="number">0.0013737</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </div><div class="line">[<span class="keyword">Full</span> GC (System.gc()) [PSYoungGen: <span class="number">776</span><span class="keyword">K</span>-&gt;<span class="number">0</span><span class="keyword">K</span>(<span class="number">76288</span><span class="keyword">K</span>)] [ParOldGen: <span class="number">65544</span><span class="keyword">K</span>-&gt;<span class="number">66145</span><span class="keyword">K</span>(<span class="number">175104</span><span class="keyword">K</span>)] <span class="number">66320</span><span class="keyword">K</span>-&gt;<span class="number">66145</span><span class="keyword">K</span>(<span class="number">251392</span><span class="keyword">K</span>), [Metaspace: <span class="number">3169</span><span class="keyword">K</span>-&gt;<span class="number">3169</span><span class="keyword">K</span>(<span class="number">1056768</span><span class="keyword">K</span>)], <span class="number">0.0063873</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total <span class="number">76288</span><span class="keyword">K</span>, used <span class="number">655</span><span class="keyword">K</span> [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</div><div class="line">  eden space <span class="number">65536</span><span class="keyword">K</span>, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</div><div class="line">  from space <span class="number">10752</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</div><div class="line">  to   space <span class="number">10752</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</div><div class="line"> ParOldGen       total <span class="number">175104</span><span class="keyword">K</span>, used <span class="number">66145</span><span class="keyword">K</span> [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</div><div class="line">  object space <span class="number">175104</span><span class="keyword">K</span>, <span class="number">37</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c5e987b8</span>,<span class="number">0x00000006cc900000</span>)</div><div class="line"> Metaspace       used <span class="number">3176</span><span class="keyword">K</span>, capacity <span class="number">4494</span><span class="keyword">K</span>, committed <span class="number">4864</span><span class="keyword">K</span>, reserved <span class="number">1056768</span><span class="keyword">K</span></div><div class="line">  class space    used <span class="number">346</span><span class="keyword">K</span>, capacity <span class="number">386</span><span class="keyword">K</span>, committed <span class="number">512</span><span class="keyword">K</span>, reserved <span class="number">1048576</span><span class="keyword">K</span></div></pre></td></tr></table></figure></p>
<p>可以看出，根据gc日志[ParOldGen: 65544K-&gt;66145K(175104K)] ，gc依然没有回收bytes对象，哪怕已经不在方法区了，我们再次修改代码。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test3</span> &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * -verbose:GC</div><div class="line">	 * -XX:+PrintGCDetails</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		&#123;</div><div class="line">			<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">int</span> i = <span class="number">1</span>;</div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>gc日志输出如下:<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[GC (System.gc()) [PSYoungGen: <span class="number">3932</span><span class="keyword">K</span>-&gt;<span class="number">776</span><span class="keyword">K</span>(<span class="number">76288</span><span class="keyword">K</span>)] <span class="number">69468</span><span class="keyword">K</span>-&gt;<span class="number">66320</span><span class="keyword">K</span>(<span class="number">251392</span><span class="keyword">K</span>), <span class="number">0.0014193</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.00</span> sys=<span class="number">0.00</span>, real=<span class="number">0.00</span> secs] </div><div class="line">[<span class="keyword">Full</span> GC (System.gc()) [PSYoungGen: <span class="number">776</span><span class="keyword">K</span>-&gt;<span class="number">0</span><span class="keyword">K</span>(<span class="number">76288</span><span class="keyword">K</span>)] [ParOldGen: <span class="number">65544</span><span class="keyword">K</span>-&gt;<span class="number">609</span><span class="keyword">K</span>(<span class="number">175104</span><span class="keyword">K</span>)] <span class="number">66320</span><span class="keyword">K</span>-&gt;<span class="number">609</span><span class="keyword">K</span>(<span class="number">251392</span><span class="keyword">K</span>), [Metaspace: <span class="number">3169</span><span class="keyword">K</span>-&gt;<span class="number">3169</span><span class="keyword">K</span>(<span class="number">1056768</span><span class="keyword">K</span>)], <span class="number">0.0076485</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.02</span> sys=<span class="number">0.00</span>, real=<span class="number">0.01</span> secs] </div><div class="line">Heap</div><div class="line"> PSYoungGen      total <span class="number">76288</span><span class="keyword">K</span>, used <span class="number">655</span><span class="keyword">K</span> [<span class="number">0x000000076b500000</span>, <span class="number">0x0000000770a00000</span>, <span class="number">0x00000007c0000000</span>)</div><div class="line">  eden space <span class="number">65536</span><span class="keyword">K</span>, <span class="number">1</span>% used [<span class="number">0x000000076b500000</span>,<span class="number">0x000000076b5a3ee8</span>,<span class="number">0x000000076f500000</span>)</div><div class="line">  from space <span class="number">10752</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x000000076f500000</span>,<span class="number">0x000000076f500000</span>,<span class="number">0x000000076ff80000</span>)</div><div class="line">  to   space <span class="number">10752</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x000000076ff80000</span>,<span class="number">0x000000076ff80000</span>,<span class="number">0x0000000770a00000</span>)</div><div class="line"> ParOldGen       total <span class="number">175104</span><span class="keyword">K</span>, used <span class="number">609</span><span class="keyword">K</span> [<span class="number">0x00000006c1e00000</span>, <span class="number">0x00000006cc900000</span>, <span class="number">0x000000076b500000</span>)</div><div class="line">  object space <span class="number">175104</span><span class="keyword">K</span>, <span class="number">0</span>% used [<span class="number">0x00000006c1e00000</span>,<span class="number">0x00000006c1e987a8</span>,<span class="number">0x00000006cc900000</span>)</div><div class="line"> Metaspace       used <span class="number">3176</span><span class="keyword">K</span>, capacity <span class="number">4494</span><span class="keyword">K</span>, committed <span class="number">4864</span><span class="keyword">K</span>, reserved <span class="number">1056768</span><span class="keyword">K</span></div><div class="line">  class space    used <span class="number">346</span><span class="keyword">K</span>, capacity <span class="number">386</span><span class="keyword">K</span>, committed <span class="number">512</span><span class="keyword">K</span>, reserved <span class="number">1048576</span><span class="keyword">K</span></div></pre></td></tr></table></figure></p>
<p>见证奇迹的时候到，[ParOldGen: 65544K-&gt;609K(175104K)]，竟然被回收了！这是为什么？当创建bytes对象的时候，那是因为当我们创建bytes对象的时候，局部变量表中当然有bytes的引用，哪怕我们没有使用，但GC roots依然存在着和bytes对象的关联。根据test2和代码test3，我们大概可以猜到如果不操作局部变量表，那么GC roots依然会保留，所以test2依然没有回收，但是到了test3，就回收了。好吧，再来一个无用的测试，我们手动赋值为null看看结果。<br><br><br><figure class="highlight cs"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestMain</span> &#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * -verbose:GC</div><div class="line">	 * -XX:+PrintGCDetails</div><div class="line">	 * @param args</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</div><div class="line">		<span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">64</span> * <span class="number">1024</span> * <span class="number">1024</span>];</div><div class="line">		<span class="comment">//do something</span></div><div class="line">		bytes = <span class="literal">null</span>;</div><div class="line">		System.gc();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>其实都能想到，果然被gc干掉了……当然这只是一个实验，总结性的话就不说了，反正我也说不来，不过实践出真理！</p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> Jvm </tag>
            
            <tag> 对象 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[黑车司机发车器Java版]]></title>
      <url>http://justdoitlee.github.io/2017/02/18/%E9%BB%91%E8%BD%A6%E5%8F%B8%E6%9C%BA%E5%8F%91%E8%BD%A6%E5%99%A8Java%E7%89%88/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>既然是发的黑车，磁力链接那套就不必仔细研究了，<br>磁力链接其实类似于这样（下面的这个是真车）：</p>
<blockquote>
<p>magnet:?xt=urn:btih:3AEA94481B0A406C66083F14C6F42635C14562C2</p>
</blockquote>
<a id="more"></a>
<p>说白了就是随机填充 40 个字母或数字，不过有一定几率会发出真车。</p>
<p> <img src="https://ooo.0o0.ooo/2016/12/25/585f760101362.png " width="300" height="300" alt="图片名称" align="center"></p>
<hr>

<p>代码实现：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"> <span class="keyword">public</span> <span class="keyword">class</span> OldDriver &#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(<span class="keyword">String</span>[] args) &#123;</div><div class="line">		java.util.Scanner input = <span class="keyword">new</span> java.util.Scanner(System.in);</div><div class="line">		System.out.<span class="built_in">println</span>(<span class="string">"黑车司机虚假磁力链接发车器"</span>);</div><div class="line">		System.out.<span class="built_in">print</span>(<span class="string">"输入需要发的黑车数量："</span>);</div><div class="line">		<span class="keyword">int</span> ljs = input.nextInt();</div><div class="line">		<span class="built_in">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=ljs;i++)&#123;</div><div class="line">			System.out.<span class="built_in">println</span>(<span class="string">"magnet:?xt=urn:btih:"</span>+CLSC());</div><div class="line"><span class="comment">/*调用 CLSC 函数，获取 40 个随机生成的字符串（CLSC指 磁力生成）*/</span></div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">String</span> CLSC()&#123;</div><div class="line">		<span class="keyword">String</span> cllj = <span class="string">""</span>;</div><div class="line">		<span class="keyword">String</span> randomchar;</div><div class="line">		<span class="keyword">String</span> chars = <span class="string">"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"</span>;</div><div class="line">		<span class="built_in">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">40</span>;i++)&#123;</div><div class="line">			<span class="keyword">int</span> RandomNumber = (<span class="keyword">int</span>)(Math.<span class="built_in">random</span>()*<span class="number">35</span>);</div><div class="line"><span class="comment">/*随机生成一个范围在 [0,35] 的数字*/</span></div><div class="line">			randomchar = <span class="string">""</span> + chars.charAt(RandomNumber);</div><div class="line"><span class="comment">/*随机选择一个字符，字符位置由上一步随机数字决定*/</span></div><div class="line">			cllj = cllj+randomchar;</div><div class="line"><span class="comment">/*将随机字符附到 cllj 字符串上，重复 40 次*/</span></div><div class="line">		&#125;</div><div class="line">		<span class="built_in">return</span> cllj;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>运行效果：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">黑车司机虚假磁力链接发车器</div><div class="line">输入需要发的黑车数量：<span class="number">5</span></div><div class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span><span class="number">126</span>XT8JCPZ6ZWV1Q77OSOAD2P2UOWOAZEIGNN0UH</div><div class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>VEKIXXTDDC6STSZN2IS1IQSW6RHJ6ZGC7NEGYIAJ</div><div class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>G8Z7O3AIGY2C1PRRNJEZ6Q1VY3HGZQ34E2MOQUWR</div><div class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span>MRXYGZUFONLDPN5G4E5EDCWMWLI00PB8ZVK6IIKQ</div><div class="line"><span class="string">magnet:</span>?xt=urn:<span class="string">btih:</span><span class="number">3</span>WQ1IYXW0MD3Z32DT80NCJBLTAJ0FC837TB2HW2M</div></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> Java二三事 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Java </tag>
            
            <tag> 黑车 </tag>
            
            <tag> 种子 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Hexo]]></title>
      <url>http://justdoitlee.github.io/2017/02/17/Hello-Hexo/</url>
      <content type="html"><![CDATA[<script src="/assets/js/DPlayer.min.js"> </script><script src="/assets/js/APlayer.min.js"> </script><p>本博客由 Hexo 强力驱动，托管于 Github ，支持 https 。</p>
<a id="more"></a>
<p>早就有自己建博客的念头了，先前在把csdn和简书作为博客，写了有大半年吧，后来学生计划买了个云服务器，用ghost搭建了一个博客，但是太简洁了！！ 于是昨天天花了大半天的时间终于搞好了这个博客。</p>
<p>之后会将简书上的文章搬运过来，Markdown 语法的文章复制一下就行，富文本写的，还得转成 Markdown 语法。（csdn的Markdown复制十分好用！）</p>
<p>博客与csdn将同步更新，两边的留言都会认真回复，反正有(mei)的(you)是(nv)时(peng)间(you)</p>
<p> <img src="http://oa0thinbz.bkt.clouddn.com/0.jpeg " width="350" height="320" alt="图片名称" align="center"></p>
]]></content>
      
        <categories>
            
            <category> 蜜汁开始 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 迁移 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
