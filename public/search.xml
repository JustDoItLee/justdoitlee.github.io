<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[系统学习Spring(三)——Bean的高级装配]]></title>
    <url>%2F2017%2F05%2F15%2F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring-%E4%B8%89-%E2%80%94%E2%80%94Bean%E7%9A%84%E9%AB%98%E7%BA%A7%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[在软件开发中，常常设置不同的运行环境：开发环境、预发环境、性能测试环境和生产环境等等。 不同的环境下，应用程序的配置项也不同，例如数据库配置、远程服务地址等。以数据库配置为例子，在开发环境中你可能使用一个嵌入式的内存数据库，并将测试数据放在一个脚本文件中。例如，在一个Spring的配置类中，可能需要定义如下的bean： 1234567@Bean(destroyMethod = "shutdown")public DataSource dataSource() &#123; return new EmbeddedDatabaseBuilder() .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build();&#125; 使用EmbeddedDatabaseBuilder这个构建器可以建立一个内存数据库，通过指定路径下的schema.sql文件中的内容可以建立数据库的表定义，通过test-data.sql可以准备好测试数据。 开发环境下可以这么用，但是在生产环境下不可以。在生产环境下，你可能需要从容器中使用JNDI获取DataSource对象，这中情况下，对应的创建代码是： 123456789@Beanpublic DataSource dataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject();&#125; 使用JNDI管理DataSource对象，很适合生产环境，但是对于日常开发环境来说太复杂了。 另外，在QA环境下你也可以选择另外一种DataSource配置，可以选择使用普通的DBCP连接池，例如： 1234567891011@Bean(destroyMethod = "close")public DataSource dataSource() &#123; BasicDataSource dataSource = new BasicDataSource(); dataSource.setUrl("jdbc:h2:tcp://dbserver/~/test"); dataSource.setDriverClassName("org.h2.Driver"); dataSource.setUsername("sa"); dataSource.setPassword("password"); dataSource.setInitialSize(20); dataSource.setMaxActive(30); return dataSource;&#125; 上述三种办法可以为不同环境创建各自需要的javax.sql.DataSource实例，这个例子很适合介绍不同环境下创建bean，那么有没有一种办法：只需要打包应用一次，然后部署到不同的开发环境下就会自动选择不同的bean创建策略。一种方法是创建三个独立的配置文件，然后利用Maven profiles的预编译命令处理在特定的环境下打包哪个配置文件到最终的应用中。这种解决方法有一个问题，即在切换到不同环境时，需要重新构建应用——从开发环境到测试环境没有问题，但是从测试环境到生产环境也需要重新构建则可能引入一定风险。 Spring提供了对应的方法，使得在环境切换时不需要重新构建整个应用。 配置profile beansSpring提供的方法不是在构件时针对不同的环境决策，而是在运行时，这样，一个应用只需要构建一次，就可以在开发、QA和生产环境运行。 在Spring 3.1之中，可以使用@Profile注解来修饰JavaConfig类，当某个环境对应的profile被激活时，就使用对应环境下的配置类。 在Spring3.2之后，则可以在函数级别使用@Profile注解（是的，跟@Bean注解同时作用在函数上），这样就可以将各个环境的下的bean定义都放在同一个配置类中，还是以之前的例子： 利用注解配置 1234567891011121314151617181920212223242526272829303132package com.spring.sample.config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.Profile;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseBuilder;import org.springframework.jdbc.datasource.embedded.EmbeddedDatabaseType;import org.springframework.jndi.JndiObjectFactoryBean;import javax.sql.DataSource;@Configurationpublic class DataSourceConfig &#123; @Bean(destroyMethod = "shutdown") @Profile("dev") public DataSource embeddedDataSource() &#123; return new EmbeddedDatabaseBuilder() .setType(EmbeddedDatabaseType.H2) .addScript("classpath:schema.sql") .addScript("classpath:test-data.sql") .build(); &#125; @Bean @Profile("prod") public DataSource dataSource() &#123; JndiObjectFactoryBean jndiObjectFactoryBean = new JndiObjectFactoryBean(); jndiObjectFactoryBean.setJndiName("jdbc/myDS"); jndiObjectFactoryBean.setResourceRef(true); jndiObjectFactoryBean.setProxyInterface(javax.sql.DataSource.class); return (DataSource) jndiObjectFactoryBean.getObject(); &#125;&#125; 除了被@Profile修饰的其他bean，无论在什么开发环境下都会被创建。 利用XML文件配置 和在JavaConfig的用法一样，可以从文件级别定义环境信息，也可以将各个环境的bean放在一个XML配置文件中。 1234567891011121314151617181920212223242526272829303132333435&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:jdbc="http://www.springframework.org/schema/jdbc" xmlns:p="http://www.springframework.org/schema/p" xmlns:jee="http://www.springframework.org/schema/jee" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/jdbc http://www.springframework.org/schema/jdbc/spring-jdbc.xsd"&gt; &lt;beans profile="dev"&gt; &lt;jdbc:embedded-database id="dataSource"&gt; &lt;jdbc:script location="classpath:schema.sql"/&gt; &lt;jdbc:script location="classpath:test-data.sql"/&gt; &lt;/jdbc:embedded-database&gt; &lt;/beans&gt; &lt;beans profile="qa"&gt; &lt;bean id="dataSource" class="org.apache.commons.dbcp.BasicDataSource" destroy-method="close" p:url="jdbc:h2:tcp://dbserver/~/test" p:driverClassName="org.h2.Driver" p:username="sa" p:password="password" p:initialSize="20" p:maxActive="30" /&gt; &lt;/beans&gt; &lt;beans profile="prod"&gt; &lt;jee:jndi-lookup id="dataSource" jndi-name="jdbc/MyDatabase" resource-ref="true" proxy-interface="javax.sql.DataSource"/&gt; &lt;/beans&gt;&lt;/beans&gt; 上述三个javax.sql.DataSource的bean，ID都是dataSource，但是在运行的时候只会创建一个bean。 激活profilesSpring提供了spring.profiles.active和spring.profiles.default这两个配置项定义激活哪个profile。如果应用中设置了spring.profiles.active选项，则Spring根据该配置项的值激活对应的profile，如果没有设置spring.profiles.active，则Spring会再查看spring.profiles.default这个配置项的值，如果这两个变量都没有设置，则Spring只会创建没有被profile修饰的bean。 有下列几种方法设置上述两个变量的值： DispatcherServlet的初始化参数 web应用的上下文参数(context parameters) JNDI项 环境变量 JVM系统属性在集成测试类上使用@ActiveProfiles注解 开发人员可以按自己的需求设置spring.profiles.active和spring.profiles.default这两个属性的组合。 我推荐在web应用的web.xml文件中设置spring.profiles.default属性——通过设置DispatcherServlet的初始参数和标签。 1234567891011121314151617181920212223242526272829303132&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;web-app xmlns="http://xmlns.jcp.org/xml/ns/javaee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd" version="3.1"&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;context-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;servlet&gt; &lt;servlet-name&gt;appServletName&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;spring.profiles.default&lt;/param-name&gt; &lt;param-value&gt;dev&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;appServletName&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 按照上述方法设置spring.profiles.default属性，任何开发人员只需要下载源码就可以在开发环境中运行程序以及测试。 然后，当应用需要进入QA、生产环境时，负责部署的开发者只需要通过系统属性、环境变量或者JNDI等方法设置spring.profiles.active属性即可，因为spring.profiles.active优先级更高。 另外，在运行集成测试时，可能希望运行跟生产环境下相同的配置；但是，如果配置重需要的beans被profiles修饰的，则需要在跑单元测试之前激活对应的profiles。 Spring提供了@ActiveProfiles注解来激活指定的profiles，用法如下： Conditional beans假设你希望只有在项目中引入特定的依赖库时、或者只有当特定的bean已经被创建时、或者是设置了某个环境变量时，某个bean才被创建。 Spring 4之前很难实现这种需求，不过在Spring 4中提出了一个新的注解——@Conditional，该注解作用于@Bean注解修饰的方法上，通过判断指定的条件是否满足来决定是否创建该bean。 举个例子，工程中有一个MagicBean，你希望只有当magic环境变量被赋值时才创建MagicBean，否则该Bean的创建函数被忽略。 12345@Bean@Conditional(MagicExistsCondition.class)public MagicBean magicBean() &#123; return new MagicBean();&#125; 这个例子表示：只有当MagicExistsCondition类已经存在时，才会创建MagicBean。 @Conditional注解的源码列举如下： 12345678910111213package org.springframework.context.annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;import org.springframework.context.annotation.Condition;@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)public @interface Conditional &#123; Class&lt;? extends Condition&gt;[] value();&#125; 可以看出，传入@Conditional注解的类一定要实现Condition接口，该接口提供matchs()方法——如果matches()方法返回true，则被@Conditional注解修饰的bean就会创建，否则对应的bean不会创建。 在这个例子中，MagicExistsCondition类应该实现Condition接口，并在matches()方法中实现具体的判断条件，代码如下所示： 12345678910111213package com.spring.sample.config;import org.springframework.context.annotation.Condition;import org.springframework.context.annotation.ConditionContext;import org.springframework.core.env.Environment;import org.springframework.core.type.AnnotatedTypeMetadata;public class MagicExistsCondition implements Condition &#123; public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) &#123; Environment env = conditionContext.getEnvironment(); return env.containsProperty("magic"); //检查magic环境变量是否被设置 &#125;&#125; 上述代码中的matchs()方法简单且有效：它首先获取环境变量，然后再判断环境变量中是否存在magic属性。在这个例子中，magic的值是多少并不重要，它只要存在就好。 MagicExistsCondition的matchs()方法是通过ConditionContext获取了环境实例。matchs()方法的参数有两个：ConditionContext和AnnotatedTypeMetadata，分别看下这两个接口的源码： 12345678//ConditionContextpublic interface ConditionContext &#123; BeanDefinitionRegistry getRegistry(); ConfigurableListableBeanFactory getBeanFactory(); Environment getEnvironment(); ResourceLoader getResourceLoader(); ClassLoader getClassLoader();&#125; 利用ConditionContext接口可做的事情很多，列举如下： 通过getRegistry()方法返回的BeanDefinitionRegistry实例，可以检查bean的定义； 通过getBeanFactory()方法返回的ConfigurableListableBeanFactory实例，可以检查某个bean是否存在于应用上下文中，还可以获得该bean的属性； 通过getEnvironment()方法返回的Environment实例，可以检查指定环境变量是否被设置，还可以获得该环境变量的值； 通过getResourceLoader()方法返回的ResourceLoader实例，可以得到应用加载的资源包含的内容； 通过getClassLoader()方法返回的ClassLoader实例，可以检查某个类是否存在。 12345678//AnnotatedTypeMetadatapublic interface AnnotatedTypeMetadata &#123; boolean isAnnotated(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1); Map&lt;String, Object&gt; getAnnotationAttributes(String var1, boolean var2); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1); MultiValueMap&lt;String, Object&gt; getAllAnnotationAttributes(String var1, boolean var2);&#125; 通过isAnnotated()方法可以检查@Bean方法是否被指定的注解类型修饰；通过其他方法可以获得修饰@Bean方法的注解的属性。 从Spring 4开始，@Profile注解也利用@Conditional注解和Condition接口进行了重构。作为分析@Conditional注解和Condition接口的另一个例子，我们可以看下在Spring 4中@Profile注解的实现。 1234567@Retention(RetentionPolicy.RUNTIME)@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)@Documented@Conditional(&#123;ProfileCondition.class&#125;)public @interface Profile &#123; String[] value();&#125; 可以看出，@Profile注解的实现被@Conditional注解修饰，并且依赖于ProfileCondition类——该类是Condition接口的实现。如下列代码所示，ProfileCondition利用ConditionContext和AnnotatedTypeMetadata两个接口提供的方法进行决策。 12345678910111213141516171819202122232425class ProfileCondition implements Condition &#123; ProfileCondition() &#123; &#125; public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) &#123; if(context.getEnvironment() != null) &#123; MultiValueMap attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); if(attrs != null) &#123; Iterator var4 = ((List)attrs.get("value")).iterator(); Object value; do &#123; if(!var4.hasNext()) &#123; return false; &#125; value = var4.next(); &#125; while(!context.getEnvironment().acceptsProfiles((String[])((String[])value))); return true;//传给@Profile注解的参数对应的环境profiles已激活 &#125; &#125; return true; //默认为true &#125;&#125; 可以看出，这代码写得不太好理解:ProfileCondition通过AnnotatedTypeMetadata实例获取与@Profile注解相关的所有注解属性；然后检查每个属性的值（存放在value实例中），对应的profiles别激活——即context.getEnvironment().acceptsProfiles(((String[]) value))的返回值是true，则matchs()方法返回true。 Environment类提供了可以检查profiles的相关方法，用于检查哪个profile被激活： String[] getActiveProfiles()——返回被激活的profiles数组； String[] getDefaultProfiles()——返回默认的profiles数组； boolean acceptsProfiles(String… profiles)——如果某个profiles被激活，则返回true。 处理自动装配的歧义在一文中介绍了如何通过自动装配让Spring自动简历bean之间的依赖关系——自动装配非常有用，通过自动装配可以减少大量显式配置代码。不过，自动装配（autowiring）要求bean的匹配具备唯一性，否则就会产生歧义，从而抛出异常。 举个例子说明自动装配的歧义性，假设你有如下自动装配的代码： 1234@Autowiredpublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; Dessert是一个接口，有三个对应的实现： 123456@Componentpublic class Cake implements Dessert &#123; ... &#125;@Componentpublic class Cookies implements Dessert &#123; ... &#125;@Componentpublic class IceCream implements Dessert &#123; ... &#125; 因为上述三个类都被@Component注解修饰，因此都会被component-scanning发现并在应用上下文中创建类型为Dessert的bean；然后，当Spring试图为setDessert()方法装配对应的Dessert参数时，就会面临多个选择；然后Spring就会抛出异常——NoUniqueBeanDefinitionException。 虽然在实际开发中并不会经常遇到这种歧义性，但是它确实是个问题，幸运的是Spring也提供了对应的解决办法。 @Primary指定优先bean在定义bean时，可以通过指定一个优先级高的bean来消除自动装配过程中遇到的歧义问题。 在上述例子中，可以选择一个最重要的Bean，用@Primary注解修饰： 123@Component@Primarypublic class IceCream implements Dessert &#123; ... &#125; 如果你没有使用自动扫描，而是使用基于Java的显式配置文件，则如下定义@Bean方法： 12345@Bean@Primarypublic Dessert iceCream() &#123; return new IceCream();&#125; 如果使用基于XML文件的显式配置，则如下定义： 123&lt;bean id="iceCream" class="com.dasserteater.IceCream" primary="true" /&gt; 不论哪种形式，效果都一样：告诉Spring选择primary bean来消除歧义。不过，当应用中指定多个Primary bean时，Spring又不会选择了，再次遇到歧义。Spring还提供了功能更强大的歧义消除机制——@Qualifiers注解。 @Qualifier指定bean的ID@Qualifier注解可以跟@Autowired或@Inject一起使用，指定需要导入的bean的ID，例如，上面例子中的setDessert()方法可以这么写： 12345@Autowired@Qualifier("iceCream")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 每个bean都具备唯一的ID，因此此处彻底消除了歧义。 如果进一步深究，@Qualifier(“iceCream”)表示以”iceCream”字符串作为qualifier的bean。每个bean都有一个qualifier，内容与该bean的ID相同。因此，上述装配的实际含义是：setDessert()方法会装配一个以”iceCream”为qualifier的bean，只不过碰巧是该bean的ID也是iceCream。 以默认的bean的ID作为qualifier非常简单，但是也会引发新的问题：如果将来对IceCream类进行重构，它的类名发生改变（例如Gelato）怎么办？在这种情况下，该bean对应的ID和默认的qualifier将变为”gelato”，然后自动装配就会失败。 问题的关键在于：你需要指定一个qualifier，该内容不会受目标类的类名的限制和影响。 开发者可以给某个bean设定自定义的qualifier，形式如下： 123@Component@Qualifier("cold")public class IceCream implements Dessert &#123; ... &#125; 然后，在要注入的地方也使用”cold”作为qualifier来获得该bean： 12345@Autowired@Qualifier("cold")public void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; 即使在JavaConfig中，也可以使用@Qualifier指定某个bean的qualifier，例如： 12345@Bean@Qualifier("cold")public Dessert iceCream() &#123; return new IceCream();&#125; 在使用自定义的@Qualifier值时，最好选择一个含义准确的名词，不要随意使用名词。在这个例子中，我们描述IceCream为”cold”bean，在装配时，可以读作：给我来一份cold dessert，恰好指定为IceCream。类似的，我们把Cake叫作”soft”，把Cookies*叫作”crispy”。 使用自定义的qualifiers优于使用基于bean的ID的默认qualifier，但是当你有多个bean共享同一个qualifier时，还是会有歧义。例如，假设你定义一个新的Dessertbean： 123@Component@Qualifier("cold")public class Popsicle implements Dessert &#123; ... &#125; 现在你又有两个”cold”为qualifier的bean了，再次遇到歧义：最直白的想法是多增加一个限制条件，例如IceCream会成为下面的定义： 1234@Component@Qualifier("cold")@Qualifier("creamy")public class IceCream implements Dessert &#123; ... &#125; 而Posicle类则如下定义： 1234@Component@Qualifier("cold")@Qualifier("fruity")public class Popsicle implements Dessert &#123; ... &#125; 在装配bean的时候，则需要使用两个限制条件，如下： 123456@Bean@Qualifier("cold")@Qualifier("creamy")public Dessert iceCream() &#123; return new IceCream();&#125; 这里有个小问题：Java 不允许在同一个item上加多个相同类型的注解（Java 8已经支持），但是这种写法显然很啰嗦。 解决办法是：通过定义自己的qualifier注解，例如，可以创建一个@Cold注解来代替@Qualifier(“cold”)： 12345@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE&#125;)@Rentention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Cold &#123; &#125; 可以创建一个@Creamy注解来代替@Qualifier(“creamy”)： 12345@Target(&#123;ElementType.CONSTRUCTOR, ElementType.FIELD, ElementType.METHOD, ElementType.TYPE&#125;)@Rentention(RetentionPolicy.RUNTIME)@Qualifierpublic @interface Creamy &#123; &#125; 这样，就可以使用@Cold和@Creamy修饰IceCream类，例如： 1234@Component@Cold@Creamypublic class IceCream implements Dessert &#123; ... &#125; 类似的，可以使用@Cold和@Fruity修饰Popsicle类，例如： 1234@Component@Cold@Fruitypublic class Popsicle implements Dessert &#123; ... &#125; 最后，在装配的时候，可以使用@Cold和@Creamy限定IceCream类对应的bean： 123456@Autowired@Cold@Creamypublic void setDessert(Dessert dessert) &#123; this.dessert = dessert;&#125; bean的作用域默认情况下，Spring应用上下文中的bean都是单例对象，也就是说，无论给某个bean被多少次装配给其他bean，都是指同一个实例。 大部分情况下，单例bean很好用：如果一个对象没有状态并且可以在应用中重复使用，那么针对该对象的初始化和内存管理开销非常小。 但是，有些情况下你必须使用某中可变对象来维护几种不同的状态，因此形成非线程安全。在这种情况下，把类定义为单例并不是一个好主意——该对象在重入使用的时候可能遇到线程安全问题。 Spring定义了几种bean的作用域，列举如下： Singleton——在整个应用中只有一个bean的实例； Prototype——每次某个bean被装配给其他bean时，都会创建一个新的实例； Session——在web应用中，在每次会话过程中只创建一个bean的实例；Request——在web应用中，在每次http请求中创建一个bean的实例。Singleton域是默认的作用域，如前所述，对于可变类型来说并不理想。我们可以使用@Scope注解——和@Component或@Bean注解都可以使用。 例如，如果你依赖component-scanning发现和定义bean，则可以用如下代码定义prototype bean： 123@Component@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public class Notepad&#123; ... &#125; 除了使用SCOPE_PROTOTYPE字符串指定bean的作用域，还可以使用@Scope(“prototype”)，但使用ConfigurableBeanFactory.SCOPE_PROTOTYPE更安全，不容易遇到拼写错误。 另外，如果你使用JavaConfig定义Notepad的bean，也可以给出下列定义： 12345@Bean@Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)public Notepad notepad() &#123; return new Notepad();&#125; 如果你使用xml文件定义Notepad的bean，则有如下定义： 123&lt;bean id="notepad" class="com.myapp.Notepad" scope="prototype" /&gt; 无论你最后采取上述三种定义方式的哪一种定义prototype类型的bean，每次Notepad被装配到其他bean时，都会重新创建一个新的实例。 request和session作用域在Web应用中，有时需要在某个request或者session的作用域范围内共享同一个bean的实例。举个例子，在一个典型的电子商务应用中，可能会有一个bean代表用户的购物车，如果购物车是单例对象，则所有的用户会把自己要买的商品添加到同一个购物车中；另外，如果购物车bean设置为prototype，则在应用中某个模块中添加的商品在另一个模块中将不能使用。 对于这个例子，使用session scope更合适，因为一个会话（session）唯一对应一个用户，可以通过下列代码使用session scope: 1234@Bean@Scope(value=WebApplicationContext.SCOPE_SESSION, proxyMode=ScopedProxyMode.INTERFACES)public ShoppingCart cart() &#123; ... &#125; 在这里你通过value属性设置了WebApplicationContext.SCOPE_SESSION，这告诉Spring为web应用中的每个session创建一个ShoppingCartbean的实例。在整个应用中会有多个ShoppingCart实例，但是在某个会话的作用域中ShoppingCart是单例的。 这里还用proxyMode属性设置了ScopedProxyMode.INTERFACES值，这涉及到另一个问题：把request/session scope的bean装配到singleton scope的bean时会遇到。首先看下这个问题的表现。 假设在应用中需要将ShoppingCartbean装配给单例StoreServicebean的setter方法： 123456789@Componentpublic class StoreService &#123; @Autowired public void setShoppingCart(ShoppingCart shoppingCart) &#123; this.shoppingCart = shoppingCart; &#125; ...&#125; 因为StoreService是单例bean，因此在Spring应用上下文加载时该bean就会被创建。在创建这个bean时 ，Spring会试图装配对应的ShoppingCartbean，但是这个bean是session scope的，目前还没有创建——只有在用户访问时并创建session时，才会创建ShoppingCartbean。 而且，之后肯定会有多个ShoppingCartbean：每个用户一个。理想的情景是：在需要StoreService操作购物车时，StoreService能够和ShoppingCartbean正常工作。 针对这种需求，Spring应该给StoreServicebean装配一个ShoppingCartbean的代理，如下图所示。代理类对外暴露的接口和ShoppingCart中的一样，用于告诉StoreService关于ShoppingCart的接口信息——当StoreService调用对应的接口时，代理采取延迟解析策略，并把调用委派给实际的session-scoped ShoppingCartbean。 Scoped proxies enable deferred injected of request- and session-coped beans因为ShoppingCart是一个接口，因此这里工作正常，但是，如果ShoppingCart是具体的类，则Spring不能创建基于接口的代理。这里必须使用CGLib创建class-based的bean，即使用ScopedProxyMode.TARGET_CLASS指示代理类应该基础自目标类。 这里使用session scope作为例子，在request scope中也有同样的问题，当然解决办法也相同。 在XML文件中定义scoped代理如果你在xml配置文件中定义session-scoped或者request-scoped bean，则不能使用@Scope注解以及对应的proxyMode属性。元素的scope属性可以用来指定bean的scope，但是如何指定代理模式？ 可以使用Spring aop指定代理模式： 12345&lt;bean id="cart" class="com.myapp.ShoppingCart" scope="session" &lt;aop: scoped-proxy /&gt;&lt;/bean&gt; 在XML配置方式扮演的角色与proxyMode属性在注解配置方式中的相同，需要注意的是，这里默认使用CGLIB库创建代理，因此，如果需要创建接口代理，则需要设置proxy-target-class属性为false: 12345&lt;bean id="cart" class="com.myapp.ShoppingCart" scope="session" &lt;aop: scoped-proxy proxy-target-class="false" /&gt;&lt;/bean&gt; 为了使用元素，需要在XML配置文件中定义Spring的aop名字空间： 12345678910&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="htttp://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocations=" http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; ........ 运行时值注入一般而言，讨论依赖注入和装配时，我们多关注的是如何（how）实现依赖注入（构造函数、setter方法），即如何建立对象之间的联系。 依赖注入的另一个方面是何时（when）将值装配给bean的属性或者构造函数。在装配bean—依赖注入的本质一文中，我们执行了很多值装配的任务，例如有如下代码： 123456@Beanpublic CompactDisc sgtPeppers() &#123; return new BlankDisc( "Sgt. Pepper's Lonely Hearts Club Band", "The Beatles");&#125; 这种硬编码的方式有时可以，有时却需要避免硬编码——在运行时决定需要注入的值。Spring提供以下两种方式实现运行时注入： Property placeholders he Spring Expression Language(SpEL) 注入外部的值在Spring中解析外部值的最好方法是定义一个配置文件，然后通过Spring的环境实例获取配置文件中的配置项的值。例如，下列代码展示如何在Spring 配置文件中使用外部配置项的值。 123456789101112131415161718192021package com.spring.sample.config;import com.spring.sample.soundsystem.CompactDisc;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;import org.springframework.core.env.Environment;@Configuration@PropertySource("classpath:/app.properties")public class ExpressiveConfig &#123; @Autowired Environment env; @Bean public CompactDisc disc() &#123; return new BlankDisc(env.getProperty("disc.title"), env.getProperty("disc.artist")); &#125;&#125; 这里，@PropertySource注解引用的配置文件内容如下： 12disc.title=Sgt. Pepper's Lonely Hearts Club Banddisc.artist=The Beatles 属性文件被加载到Spring的Environment实例中，然后通过getProperty()方法解析对应配置项的值。 在Environment类中，getProperty()方法有如下几种重载形式： String getProperty(String var1); String getProperty(String var1, String var2); T getProperty(String var1, Class var2); T getProperty(String var1, Class var2, T var3); 前两个方法都是返回String值，利用第二个参数，可以设置默认值；后两个方法可以指定返回值的类型，举个例子：假设你需要从连接池中获取连接个数，如果你使用前两个方法，则返回的值是String，你需要手动完成类型转换；但是使用后两个方法，可以由Spring自动完成这个转换： 1int connection = env.getProperty("db.connection.count", Integer.class, 30) 除了getProperty()方法，还有其他方法可以获得配置项的值，如果不设置默认值参数，则在对应的配置项不存在的情况下对应的属性会配置为null，如果你不希望这种情况发生——即要求每个配置项必须存在，则可以使用getRequiredProperty()方法： 123456@Beanpublic CompactDisc disc() &#123; return new BlankDisc( env.getRequiredProperty("disc.title"), env.getRequiredProperty("disc.artist"));&#125; 在上述代码中，如果disc.title或者disc.artist配置项不存在，Spring都会抛出IllegalStateException异常。 如果你希望检查某个配置项是否存在，则可以调用containsProperty()方法：boolean titleExists = env.containsProperty(“disc.title”);。如果你需要将一个属性解析成某个类，则可以使用getPropertyAsClass()方法：Class cdClass = env.getPropertyAsClass(“disc.class”, CompactDisc.class); 在Spring中，可以使用${ … }将占位符包裹起来，例如，在XML文件中可以定义如下代码从配置文件中解析对应配置项的值： 1234&lt;bean id="sgtPeppers" class="soundsystem.BlankDisc" c:_title="$&#123;disc.title&#125;" c:_artist="$&#123;disc.artist&#125;" /&gt; 如果你使用component-scanning和自动装配创建和初始化应用组件，则可以使用@Value注解获取配置文件中配置项的值，例如BlankDisc的构造函数可以定义如下： 123456public BlankDisc( @Value("$&#123;disc.title&#125;") String title, @Value("$&#123;disc.artist&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; 为了使用占位符的值，需要配置PropertyPlaceholderConfigerbean或者PropertySourcesPlaceholderConfigurerbean。从Spring 3.1之后，更推荐使用PropertySourcesPlaceholderConfigurer，因为这个bean和Spring 的Environment的来源一样，例子代码如下： 1234@Beanpublic static PropertySourcesPlaceholderConfigurer placeholderConfigurer() &#123; return new PropertySourcesPlaceholderConfigurer();&#125; 如果使用XML配置文件，则通过元素可以获得PropertySourcesPlaceholderConfigurerbean： 123456&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:property-placeholder location="classpath:/app.properties" /&gt;&lt;/beans&gt; 使用SpEL装配Spring 3引入了Spring Expression Language（SpEL），这是一种在运行时给bean的属性或者构造函数参数注入值的方法。 SpEL有很多优点，简单列举如下： 可以通过bean的ID引用bean； 可以调用某个对象的方法或者访问它的属性； 支持数学、关系和逻辑操作； 正则表达式匹配； 支持集合操作在后续的文章中，可以看到SpEL被用到依赖注入的其他方面，例如在Spring Security中，可以使用SpEL表达式定义安全限制；如果在Spring MVC中使用Thymeleaf模板，在模板中可以使用SpEL表达式获取模型数据。SpEL是一门非常灵活的表达式语言，在这里不准备花大量篇幅来涵盖它的所有方面，可以通过一些例子来感受一下它的强大能力。 首先，SpEL表达式被#{ … }包围，跟placeholders中的${ … }非常像，最简单的SpEL表达式可以写作#{1}。在应用中，你可能回使用更加有实际含义的SpEL表达式，例如#{T(System).currentTimeMillis()}——这个表达式负责获得当前的系统时间，而T()操作符负责将java.lang.System解析成类，以便可以调用currentTimeMillis()方法。 SpEL表达式可以引用指定ID的bean或者某个bean的属性，例如下面这个例子可以获得ID为sgtPeppers的bean的artist属性的值：#{sgtPeppers.artist}；也可以通过#{systemProperties[‘disc.title’]}引用系统属性。 上述这些例子都非常简单，我们接下来看下如何在bean装配中使用SpEL表达式，之前提到过，如果你使用component-scanning和自动装配创建应用组件，则可以使用@Value注解获得配置文件中配置项的值；除了使用placeholder表达式，还可以使用SpEL表达式，例如BlankDisc的构造函数可以按照下面这种方式来写： 123456public BlankDisc( @Value("#&#123;systemProperties['disc.title']&#125;") String title, @Value("#&#123;systemProperties['disc.artist']&#125;") String artist) &#123; this.title = title; this.artist = artist;&#125; SpEL表达式可以表示整数值，也可以表示浮点数、String值和Boolean值。例如可以使用#{3.14159}表式浮点数3.14159，并且还支持科学计数法——#{9.87E4}表示98700；#{‘Hello’}可以表示字符串值、#{false}可以表示Boolean值。 单独使用字面值是乏味的，一般不会使用到只包含有字面值的SpEL表达式，不过在构造更有趣、更复杂的表达式时支持字面值这个特性非常有用。 SpEL表达式可以通过bean的ID引用bean，例如#{sgtPeppers}；也可以引用指定bean的属性，例如#{sgtPeppers.artist}；还可以调用某个bean的方法，例如#{artistSelector.selectArtist()}表达式可以调用artistSelector这个bean的selectArtist()方法。 SpEL表达式也支持方法的连续调用，例如#{artistSelector.selectArtist().toUpperCase()},为了防止出现NullPointerException异常，最好使用类型安全的操作符，例如#{artistSelector.selectArtist()?.toUpperCase()}。?.操作符在调用右边的函数之前，会确保左边的函数返回的值不为null。 在SpEL中能够调用类的方法或者常量的关键是T()操作符，例如通过T(java.lang.Math)可以访问Math类中的方法和属性——#{(java.lang.Math).random()}和#{T(java.lang.Math).PI}。 在操作文本字符串时，最常用的是检查某个文本是否符合某种格式。SpEL通过matches操作符支持正则表达式匹配。例如：#{admin.email matches ‘[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+.com’}可以检查admin.email表示的邮件地址是否正确。 通过SpEL表达式还可以操作集合和数组，例如#{jukebox.songs[4].title}这个表达式可以访问jukebox的songs数组的第5个元素。 也可以实现更复杂的功能：随机选择一首歌——#{jukebox.songs[T(java.lang.Math).random() * jukebox.songs.size()].title}。 SpEL提供了一个选择操作符——.?[]，可以获得某个集合的子集，举个例子，假设你获得jukebox中所有artist为Aerosmith的歌，则可以使用这个表达式：#{jukebox.songs.?[artist eq ‘Aerosmith’]}。可以看出，.?[]操作符支持在[]中嵌套另一个SpEL表达式。 SpEL还提供了其他两个选择操作符：.^[]用于选择第一个匹配的元素；.$[]用于选择最后一个匹配的元素。 最后，SpEL还提供了一个提取操作符：.![]，可以根据指定的集合新建一个符合某个条件的新集合，例如#{jukebox.songs.![title]}可以将songs的title都提取出来构成一个新的字符串集合。 OK，SpEL的功能非常强大，但是这里需要给开发人员提个醒：别让你的SpEL表达式过于智能。你的表达式越智能，就越难对它们进行单元测试，因此，尽量保证你的SpEL表达式简单易理解。 总结首先我们介绍了通过Spring的profiles解决多环境部署的问题，通过在运行时根据代表指定环境的profile选择性创建某个bean，Spring可以实现无需重新构建就可以在多个环境下部署同一个应用。 Profiles bean是运行时创建bean的一种解决方案，不过Spring 4提供了一个更普遍的解决方案：利用@Conditional注解和Condition接口实现条件性创建bean。 我们还介绍了两种机制来解决自动装配时可能遇到的歧义性问题：primary beans和qualifiers。尽管定义一个primary bean非常简单，但它仍然有局限，因此我们需要利用qualifier缩小自动装配的bean的范围，而且，我们也演示了如何创建自己的qualifiers。 尽管大多数Spring bean是单例对象，但是在某些情况下具备其他作用域的对象更加合适。Spring 应用中可以创建singletons、prototypes、request-scoped或session-scoped。在使用request-scoped或者session-scoped类型的bean时，还需要解决将非单例对象注入到单例对象时遇到的问题——利用代理接口或代理类。 最后，我们也介绍了Spring表达式语言（SpEL），利用SpEL可以实现在运行时给bean注入值。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习Spring（二）——装配Bean]]></title>
    <url>%2F2017%2F05%2F10%2F%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0Spring%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E8%A3%85%E9%85%8DBean%2F</url>
    <content type="text"><![CDATA[任何一个成功的应用都是由多个为了实现某个业务目标而相互协作的组件构成的，这些组件必须相互了解、能够相互协作完成工作。例如，在一个在线购物系统中，订单管理组件需要与产品管理组件以及信用卡认证组件协作；这些组件还需要跟数据库组件协作从而进行数据库读写操作。在Spring应用中，对象无需自己负责查找或者创建与其关联的其他对象，由容器负责将创建各个对象，并创建各个对象之间的依赖关系。通俗的来说，Spring就是一个工厂，Bean就是Spring工厂的产品，对于Spring工厂能够生产那些产品，这个取决于领导的决策，也就是配置文件中配置。因此，对于开发者来说，我们需要关注的只是告诉Spring容器需要创建哪些bean以及如何将各个bean装配到一起。对于Spring来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成“依赖注入”。 Bean的定义 &lt; beans/&gt;是Sring配置文件的根节点 一个&lt; beans/&gt;节点里面可以有多个节点在定义Bean的时候，通常要指定两个属性：id和class。其中id用来指明bean的标识符，这个标识符具有唯一性，Spring对bean的管理以及bean之间这种依赖关系都需要这个属性；而class指明该bean的具体实现类，这里不能是接口（可以是接口实现类）全路径包名.类名。12//一个Bean的配置 &lt;bean id="bean" class="实现类" /&gt;或者1234@Component("bean")public class Bean &#123; ...&#125;当我们用XML配置了这个bean的时候，该bean实现类中必须有一个无参构造器，故Spring底层相当于调用了如下代码：1bean = new 实现类（）;如果在bean的配置文件中，通过构造注入如：123&lt;bean id="bean" class="实现类" /&gt; &lt;constructor-arg value="bean"/&gt; &lt;/bean&gt;那么Spring相当于调用了1Bean bean = new 实现类（"bean"）;Spring的配置方法Spring容器负责创建应用中的bean，并通过DI维护这些bean之间的协作关系。作为开发人员，你应该负责告诉Spring容器需要创建哪些bean以及如何将各个bean装配到一起。Spring提供三种装配bean的方式：基于XML文件的显式装配基于Java文件的显式装配隐式bean发现机制和自动装配绝大多数情况下，开发人员可以根据个人品味选择这三种装配方式中的一种。Spring也支持在同一个项目中混合使用不同的装配方式。《Spring实战》的建议是：尽可能使用自动装配，越少写显式的配置文件越好；当你必须使用显式配置时（例如，你要配置一个bean，但是该bean的源码不是由你维护），尽可能使用类型安全、功能更强大的基于Java文件的装配方式；最后，在某些情况下只有XML文件中才又你需要使用的名字空间时，再选择使用基于XML文件的装配方式。自动装配Bean Spring通过两个角度来实现自动装配： 组件扫描，Spring会自动发现应用上下文中所创建的bean 自动装配，Spring自动满足bean之间的依赖 《Spring实战》中用了一个例子来说明，假设你需要实现一个音响系统，该系统中包含CDPlayer和CompactDisc两个组件，Spring将自动发现这两个bean，并将CompactDisc的引用注入到CDPlayer中。 首先创建CD的概念——CompactDisc接口，如下所示：123456789package soundsystem;/** * @author 李智 * @date 2017/5/9 */public interface CompactDisc &#123; void play();&#125; CompactDisc接口的作用是将CDPlayer与具体的CD实现解耦合，即面向接口编程。这里还需定义一个具体的CD实现，如下所示：1234567891011121314151617package soundsystem;import org.springframework.stereotype.Component;/** * @author 李智 * @date 2017/5/9 */@Componentpublic class SgtPeppers implements CompactDisc &#123; private String title = "Sgt.Pepper's Lonely Hearts Club Band"; private String artist = "The Beatles"; public void play() &#123; System.out.println("Playing" + title + "by" + artist); &#125;&#125; 这里最重要的是@Component注解，它告诉Spring需要创建SgtPeppers bean。除此之外，还需要启动自动扫描机制，有两种方法：基于XML配置文件；基于Java配置文件，代码如下（二选一）：123456789//这是XML配置&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="soundsystem"/&gt;&lt;/beans&gt; 或1234567891011121314//这是Java配置package soundsystem;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;/** * @author 李智 * @date 2017/5/9 */@Configuration@ComponentScan()public class CDPlayerConfig &#123;&#125; 在这个Java配置文件中有两个注解值得注意：@Configuration表示这个.java文件是一个配置文件；@ComponentScan表示开启Component扫描，Spring将会设置该目录以及子目录下所有被@Component注解修饰的类。 自动配置的另一个关键注解是@Autowired，基于之前的两个类和一个Java配置文件，可以写个测试123456789101112131415161718192021222324package com.spring.sample.soundsystem;import com.spring.sample.config.SoundSystemConfig;import org.junit.Assert;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;/** * @author 李智 * @date 2017/5/9 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SoundSystemConfig.class)public class SoundSystemTest &#123; @Autowired private CompactDisc cd; @Test public void cdShouldNotBeNull() &#123; Assert.assertNotNull(cd); &#125;&#125; 运行测试，看到绿色就成功了，说明@Autowired注解起作用了：自动将扫描机制创建的CompactDisc类型的bean注入到SoundSystemTest这个bean中。 这里需要注意两个点，一个是junit需要用高级一点的版本，之前用3.8一直有问题，换成4.12之后就好了；还一个是SpringTest的测试包。12345678910111213141516171819&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- Sprint-test 相关测试包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;3.2.11.RELEASE&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 简单得说，自动装配的意思就是让Spring从应用上下文中找到对应的bean的引用，并将它们注入到指定的bean。通过@Autowired注解可以完成自动装配。 例如，考虑下面代码中的CDPlayer类，它的构造函数被@Autowired修饰，表明当Spring创建CDPlayer的bean时，会给这个构造函数传入一个CompactDisc的bean对应的引用。 12345678910111213141516171819202122package soundsystem;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Component;/** * @author 李智 * @date 2017/5/9 */@Componentpublic class CDPlayer implements MediaPlay &#123; private CompactDisc cd; @Autowired public CDPlayer(CompactDisc cd) &#123; this.cd = cd; &#125; public void play() &#123; cd.play(); &#125;&#125; 还有别的实现方法，例如将@Autowired注解作用在setCompactDisc()方法上: 1234@Autowiredpublic void setCd(CompactDisc cd) &#123; this.cd = cd;&#125; 或者是其他名字的方法上，例如：1234@Autowiredpublic void insertCD(CompactDisc cd) &#123; this.cd = cd;&#125; 更简单的用法是，可以将@Autowired注解直接作用在成员变量之上，我们开发一般都是直接这么用的吧，例如：12@Autowiredprivate CompactDisc cd; 只要对应类型的bean有且只有一个，则会自动装配到该属性上。如果没有找到对应的bean，应用会抛出对应的异常，如果想避免抛出这个异常，则需要设置@Autowired(required=false)。不过，在应用程序设计中，应该谨慎设置这个属性，因为这会使得你必须面对NullPointerException的问题。 如果存在多个同一类型的bean，则Spring会抛出异常，表示装配有歧义，解决办法有两个：（1）通过@Qualifier注解指定需要的bean的ID；（2）通过@Resource注解指定注入特定ID的bean； 现在我们验证一下上述代码，通过下列代码，可以验证：CompactDisc的bean已经注入到CDPlayer的bean中，同时在测试用例中是将CDPlayer的bean注入到当前测试用例。 123456789101112131415161718192021222324252627282930313233343536373839import static org.junit.Assert.*;import org.junit.Rule;import org.junit.Test;import org.junit.contrib.java.lang.system.StandardOutputStreamLog;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import soundsystem.CDPlayerConfig;import soundsystem.CompactDisc;import soundsystem.MediaPlay;/** * @author 李智 * @date 2017/5/9 */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = CDPlayerConfig.class)//@ContextConfiguration(locations = &#123;"classpath:/applicationContext.xml"&#125;)public class CDPlayerTest &#123; @Rule public final StandardOutputStreamLog log = new StandardOutputStreamLog(); @Autowired private CompactDisc cd; @Autowired private MediaPlay player; @Test public void cdShouldNotBeNull() &#123; assertNotNull(cd); &#125; @Test public void play() &#123; player.play(); assertEquals("Playing" + "Sgt.Pepper's Lonely Hearts Club Band" + "by" + "The Beatles\n", log.getLog()); &#125;&#125; 这里可以使用 public final Logger log = LoggerFactory.getLogger(CDPlayerTest.class);来替代 public final StandardOutputStreamLog log = new StandardOutputStreamLog();，要使用StandardOutputStreamLog，需要添加Jar包如下： 12345&lt;dependency&gt; &lt;groupId&gt;com.github.stefanbirkner&lt;/groupId&gt; &lt;artifactId&gt;system-rules&lt;/artifactId&gt; &lt;version&gt;1.16.0&lt;/version&gt; &lt;/dependency&gt; 基于Java配置文件装配BeanJava配置文件不同于其他用于实现业务逻辑的Java代码，因此不能将Java配置文件业务逻辑代码混在一起。一般都会给Java配置文件新建一个单独的package，实际上之前就用了Java配置的。1234@Configuration@ComponentScan(basePackageClasses = &#123;CDPlayer.class, DVDPlayer.class&#125;)public class SoundSystemConfig &#123;&#125;@Configuration注解表示这个类是配置类，之前我们是通过@ComponentScan注解实现bean的自动扫描和创建，这里我们重点是学习如何显式创建bean，因此首先将@ComponentScan(basePackageClasses = {CDPlayer.class, DVDPlayer.class})这行代码去掉。我们先通过@Bean注解创建一个Spring bean，该bean的默认ID和函数的方法名相同，即sgtPeppers。例如：123456789@Beanpublic CompactDisc sgtPeppers() &#123; return new SgtPeppers();&#125;//或注明id@Bean(name = "lonelyHeartsClub")public CompactDisc sgtPeppers() &#123; return new SgtPeppers();&#125;可以利用Java语言的表达能力，实现类似工厂模式的代码如下：1234567891011121314@Beanpublic CompactDisc randomBeatlesCD() &#123; int choice = (int)Math.floor(Math.random() * 4); if (choice == 0) &#123; return new SgtPeppers(); &#125; else if (choice == 1) &#123; return new WhiteAlbum(); &#125; else if (choice == 2) &#123; return new HardDaysNight(); &#125; else if (choice == 3) &#123; return new Revolover(); &#125;&#125;然后在JavaConfig中的属性注入：1234@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers());&#125;看起来是函数调用，实际上不是：由于sgtPeppers()方法被@Bean注解修饰，所以Spring会拦截这个函数调用，并返回之前已经创建好的bean——确保该SgtPeppers bean为单例。123456789@Beanpublic CDPlayer cdPlayer() &#123; return new CDPlayer(sgtPeppers());&#125;@Beanpublic CDPlayer anotherCDPlayer() &#123; return new CDPlayer(sgtPeppers());&#125;如上代码所示：如果把sgtPeppers()方法当作普通Java方法对待，则cdPlayerbean和anotherCDPlayerbean会持有不同的SgtPeppers实例——结合CDPlayer的业务场景看：就相当于将一片CD同时装入两个CD播放机中，显然这不可能。默认情况下，Spring中所有的bean都是单例模式，因此cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例。当然，还有一种更清楚的写法：123456789@Beanpublic CDPlayer cdPlayer(CompactDisc compactDisc) &#123; return new CDPlayer(compactDisc);&#125;@Beanpublic CDPlayer anotherCDPlayer() &#123; return new CDPlayer(sgtPeppers());&#125;这种情况下，cdPlayer和anotherCDPlayer这俩bean持有相同的SgtPeppers实例，该实例的ID为lonelyHeartsClub。这种方法最值得使用，因为它不要求CompactDisc bean在同一个配置文件中定义——只要在应用上下文容器中即可（不管是基于自动扫描发现还是基于XML配置文件定义）。基于XML的配置方法在之前Bean的定义有提到过，这里就不复述了。混合使用多种配置方法之前有提到过，开发过程中也可能使用混合配置，首先明确一点：对于自动配置，它从整个容器上下文中查找合适的bean，无论这个bean是来自JavaConfig还是XML配置。在JavaConfig中解析XML配置123456789101112//通过@Import注解导入其他的JavaConfig，并且支持同时导入多个配置文件；@Configuration@Import(&#123;CDPlayerConfig.class, CDConfig.class&#125;)public class SoundSystemConfig &#123;&#125;//通过@ImportResource注解导入XML配置文件；@Configuration@Import(CDPlayerConfig.class)@ImportResource("classpath: cd-config.xml")public class SoundSystemConfig &#123;&#125;在XML配置文件中应用JavaConfig123//通过&lt;import&gt;标签引入其他的XML配置文件；//通过&lt;bean&gt;标签导入Java配置文件到XML配置文件，例如&lt;bean class="soundsystem.CDConfig" /&gt;通常的做法是：无论使用JavaConfig或者XML装配，都要创建一个root configuration，即模块化配置定义；并且在这个配置文件中开启自动扫描机制：或者@ComponentScan。总结 由于自动装配几乎不需要手动定义bean，建议优先选择自动装配；如何必须使用显式配置，则优先选择基于Java文件装配这种方式，因为相比于XML文件，Java文件具备更多的能力、类型安全等特点；但是也有一种情况必须使用XML配置文件，即你需要使用某个名字空间（name space），该名字空间只在XML文件中可以使用。 ps:上述例子都是直接用的《Spring实战》]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[系统学习Spring（一）]]></title>
    <url>%2F2017%2F05%2F09%2FSpring%E5%88%9D%E6%8E%A2%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[对于Java开发者来说，这是一个好的时代。 在过去的20年中，Java经历了好的时候，也经历了坏的时候。尽管有一些粗糙的地方，比如：Applets、EJB、JDO和无数的日志框架，Java有丰富多样的历史，有很多企业已经建立的平台。其中，spring一直都是其中最重要的组成部分。 在早期，Spring被创建用于替代笨重的Java企业技术，比如EJB。相比于EJB，Spring提供了一个更加精简的编程模型。它提供了简单Java对象（POJO）更大的权力，相对于EJB及其他Java企业规范。 随着时间的推移，EJB及Java企业规范2.0版本本身也提供了一个简单的POJO模型。现在，EJB的一些概念，如DI和AOP都来自于Spring。 尽管现在J2EE（即总所周知的JEE）能够赶上Spring，但是Spring从未停止演进。即使是现在，Spring开始进步的时候，J2EE都是开始在探索，而不是创新。移动开发、社交API的集成、NoSql数据库、云计算和大数据，仅仅是Spring创新的一些方面。而且未来，Spring会继续发展。 就像我说的，对于Java程序员来说，这是一个好的时代。 摘自《Spring实战》 顾名思义，Spring就是为了简化我们Java开发而来的，而Spring主要还是围绕着两个点：一个DI（依赖注入），一个AOP（面向切面），或者说IOC（控制反转）和AOP（面向切面）。 IOC主要的实现方式有两种：依赖查找，依赖注入依赖注入是一种更可取的方式 依赖注入——Injecting Dependencies刚接触时，DI这个词刚听起来觉得是害怕的，它可能是相当复杂的编程技术或者设计模式。但事实证明，DI一点都不像 ，它听起来那么难。通过在应用中使用DI，你会发现你的应用程序变淡简单、容易理解并且易于测试。那么DI是怎么工作的呢？一个正常的应用程序都是有两个或者更多个相互协作的类组合起来的。传统上，每个对象都会保存它所以来的对象的引用。这个会导致高度耦合并且难于测试。 例如：123456789101112package knights;public class DamselRescuingKnight implements Knight&#123; private RescueDamselQuest quest; public DamselRescuingKnight()&#123; this.quest = new RescueDamselQuest(); &#125; public void embarkOnQuest()&#123; quest.embark(); &#125;&#125; 如上所示，骑士创建了一个少女需要营救的请求（RescueDamselQuest）在它自己的构造函数中。这个会使骑士与少女请求绑定到一起，这严重限制了骑士的能力。如果一个少女需要营救，那没有问题。但是如果一头巨龙需要被杀死，那么骑士什么都做不了，只能坐在旁边观看。 所以耦合是一个特别难以拓展的问题，一方面，耦合的代码难于测试、难于重用、难以理解并且他经常导致“打地鼠”的Bug行为（一种修改一个Bug通常会引起其他新的一个甚至更多的新bug的行为）。另一方面，一定数量的耦合代码是必须的，完全不耦合的代码将什么事情都不做。为了去做一些有用的事情，类需要知道彼此。耦合是必须的，但是必须被小心的管理。 因此使用DI，对象在创建的时候被一些确定系统对象坐标的第三方去给予出其依赖，对象不需要去创建或者获取其依赖，像下图描述的那样，依赖被注入进了需要他们的对象。 所以针对上面的问题，我们修改了代码：12345678910111213141516//一个灵活的骑士package knights;public class BraveKnight implements Knight &#123; private Quest quest; public BraveKnight(Quest quest) &#123; this.quest = quest; &#125; @Override public void embarkOnQuest() &#123; quest.embark(); &#125;&#125; 就像在上面看到的一样，BraveKnight不像DamselRescuingKnight 一样创建自己的Quest，而是在构造函数的参数中传入Quest，这样的DI就是著名的构造函数注入（Constructor injection）。 更重要的是，那个Quest只是一个接口，所有实现该接口的实现都可以传入。所以BraveKnight可以处理不同的 需求。 关键点就是BraveKnight没有跟任何特定的Quest进行绑定。它不在乎是什么样的请求，只要该请求实现了Quest接口就可以。这个就是DI的好处–松耦合。如果一个对象的依赖只是一个接口，那么你可以将他的实 现从一个换成另外一个。 既然你BraveKnight对象可以处理任何你想传递给他的Quest对象，假设你想传递一个杀死巨龙的Quest，那么 你可以传递一个SlayDragonQuest给他是合适的。123456789101112public class SlayDragonQuest implements Quest &#123; private PrintStream stream; public SlayDragonQuest(PrintStream stream) &#123; this.stream = stream; &#125; @Override public void embark() &#123; stream.println("Embarking on quest to slay the dragon"); &#125;&#125; 就像你所看到的一样，SlayDragonQuest实现了Quest接口，使得它适合BraveKnight。 应用组件之间创建关联的行为通常称为布线或者装配（wiring）。在Spring中，组件之间的装配方式有很多种，但是一个通常的方式是使用XML。接下来的清单展示了一个简单的Spring配置文件–knights.xml，它将一个SlayDragonQuest、BraveKnight和一个PrintStream装配起来。 12345678910111213&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;bean id="knight" class="com.springinaction.knights.BraveKnight"&gt; &lt;!--quest注入quest的Bean--&gt; &lt;constructor-arg ref="quest"/&gt; &lt;/bean&gt; &lt;!--创建Quest--&gt; &lt;bean id="quest" class="com.springinaction.knights.SlayDragonQuest"&gt; &lt;constructor-arg value="#&#123;$(System).out&#125;"/&gt; &lt;/bean&gt;&lt;/beans&gt; 这里，BraveKnight和SlayDragonQuest被声明为Bean，在BraveKnight Bean中，通过传递一个Quest的引用作为构造函数的参数。同时，SlayDragonQuest使用Spring表达式语言传递一个System.out的构造函数参数给SlayDragonQuest对象。如果XML配置文件不适合你的口味，你可以使用Java方式进行配置。如下：123456789101112@Configurationpublic class KnightConfig &#123; @Bean public Knight knight() &#123; return new BraveKnight(quest()); &#125; @Bean public Quest quest() &#123; return new SlayDragonQuest(System.out); &#125;&#125; 不管使用xml还是java，依赖注入的好处都是一样的。尽管BraveKnight依赖Quest，但是它不需要知道具体是什么Quest，同样的SlayDragonQuest也不需要知道具体的PrintStream类型。在Spring中，仅仅通过配置使得所有的片段组装在一起。这个就使得可以去改变他们之间的依赖关系而不需要去修改类的实现。 AOP——Aspect-OrientedProgramming虽然DI可以使得你的应用程序组件之间是松耦合的，但是AOP可以使得你可以在你应用程序中去捕获Bean的功能。 AOP通常被定义为分离软件关注点的一种技术。系统通常由一些具有特定功能的组件组成。但是，通常这些组件也附带一些除了核心功能之外的一些功能。系统服务，如日志记录、事务管理和安全性，通常会在每个组件中都是需要的。这些系统服务通常被称为横切关注点（cross-cutting concerns），因为他们会在系统中切割多个组件。 通过传递这些横切关注点，你会提供你应用程序的复杂性： 代码重复。这就意味着你如果修改其中一个功能，你修改需要许多的组件。即使你把关注点抽象为一个单独的模块，这样对你组件的影响是一个单一的方法，该方法调用也会在多个地方重复。 你的组件中充斥这与它核心功能不一致的代码。如添加一个条目到一个地址簿中，我们应该只关心如何添加地址，而不是关心是否安全或者是否具有事务一致性。 AOP可以模块化这些服务，并且通过声明式的方式应用这些服务，这将导致组件更加具有凝聚力，并且组件专注于自己特定的功能，对可能涉及的系统服务完全不知情。简单来说，就是让POJO始终保持扁平。 下面一个例子来演示分离核心功能与系统服务：1234567891011121314151617public class Minstrel &#123; private PrintStream stream; public Minstrel(PrintStream stream) &#123; this.stream = stream; &#125; //called before quest public void singleBeforeQuest() &#123; stream.println("Fa la la, the knight is so brave"); &#125; //called after quest public void singleAfterQuest() &#123; stream.println("Tee hee hee, the brave knight did embark on a quest"); &#125;&#125; 就像你看到的一样，Minstrel是一个包含两个方法的简单对象，这是简单的，将这个注入进我们之前的代码，如下所示：123456789101112131415public class BraveKnight implements Knight &#123; private Quest quest; private Minstrel minstrel; public BraveKnight(Quest quest, Minstrel minstrel) &#123; this.quest = quest; this.minstrel = minstrel; &#125; public void embarkOnQuest() &#123; minstrel.singleBeforeQuest(); quest.embark(); minstrel.singleAfterQuest(); &#125;&#125; 现在，你需要做的就是在Spring的配置文件中加入Ministrel的构造函数参数。但是，等等…. 好像看起来不对，这个真的是骑士本身关注的吗？骑士应该不必要做这个工作。毕竟，这是一个歌手的工作，歌颂骑士的努力，为什么其实一直在提醒歌手呢？ 另外，由于骑士必须知道歌手，你被迫传递歌手给骑士，这个不仅使骑士的代码复杂，而且让我很困惑，当我需要一个骑士而没有一个歌手的时候，如果Ministrel为null，在代码中还得进行非空判断，简单的BraveKnight代码开始变得复杂。但是使用AOP，你可以宣布歌手必须歌唱骑士的任务，并且，释放骑士，直接处理歌手的方法。 在Spring配置文件中，你需要做的就是将歌手声明为一个切面。如下：123456789101112131415161718192021222324252627282930313233&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;bean id="knight" class="com.springinaction.knights.BraveKnight"&gt; &lt;!--quest注入quest的Bean--&gt; &lt;constructor-arg ref="quest"/&gt; &lt;/bean&gt; &lt;!--创建Quest--&gt; &lt;bean id="quest" class="com.springinaction.knights.SlayDragonQuest"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;/bean&gt; &lt;!--定义歌手的Bean--&gt; &lt;bean id="ministrel" class="com.springinaction.knights.Minstrel"&gt; &lt;constructor-arg value="#&#123;T(System).out&#125;"/&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;aop:aspect ref="ministrel"&gt; &lt;!--定义切点--&gt; &lt;aop:pointcut id="embark" expression="execution(* *.embarkOnQuest(..))"/&gt; &lt;!--定义前置通知--&gt; &lt;aop:before pointcut-ref="embark" method="singleBeforeQuest"/&gt; &lt;!--定义后置通知--&gt; &lt;aop:after method="singleAfterQuest" pointcut-ref="embark"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 使用Spring的AOP配置一个Ministrel作为切面，在切面里面，定义一个切点，然后定义前置通知（before advice）和后置通知（after advice）。在两个例子中，pointcut-ref属性都使用了一个embark的引用，这个切点是通过pointcut元素定义的，它表明通知应该应用在什么地方，表达式的语法遵循AspectJ的切点表达式语法。 首先，Ministrel始终是一个POJO，没有任何说明他是用来作为切面的。作为一个切面是通过Spring配置文件实现的。其次，也是最重要的，Ministrel可以应用到BraveKnight而不需要BraveKnight直接调用它，实际上，BraveKnight根本不知道Ministrel的存在。 需要指出的是，你可以使用Spring的魔法使得Ministrel作为一个切面，但是Ministrel必须首先是一个Spring的Bean，关键的就是你可以使用任何Spring Bean作为切面，而且可以将其注入其他的Bean中。 这些基础的理论都是从《Spring实战第四版》一书中记录下来的，以后的学习中，将会掺杂以自己视角来写。 ps:其实之前有写过Spring的一些理解，但是开发过程中还是发现很多细节都不理解不明白，因为之前Spring的学习都是基于开发过程中边做边学，所以决定从头开始系统的学习。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[userId分库，怎么通过其他字段查询]]></title>
    <url>%2F2017%2F04%2F18%2FuserId%E5%88%86%E5%BA%93%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%9A%E8%BF%87%E5%85%B6%E4%BB%96%E5%AD%97%E6%AE%B5%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[用户中心是几乎每一个公司必备的基础服务，用户注册、登录、信息查询与修改都离不开用户中心。 当数据量越来越大时，需要多用户中心进行水平切分。最常见的水平切分方式，按照userId取模分库： 例如： 通过userId取模，将数据分布到多个数据库实例上去，提高服务实例个数，降低单库数据量，以达到扩容的目的。 这样水平切分之后，userId属性上的查询可以直接路由到库，如上图，假设访问uid=10的数据，取模后能够直接定位db1。 但是分库之后，对于其他字段的查询，就不能这么幸运了。假设访问userName=”lizhi”的数据，由于不知道数据落在哪个库上，往往需要遍历所有库，当分库数量多起来，性能会显著降低。 所以我要们寻找如何高效查询的方法！（以下用userName为例） 索引表法 思路：userId直接定位到库，userName不能直接定位到库，如果通过userName能查询到userId，问题解决。 解决方案：1）建立一个索引表记录userName-&gt;userId的映射关系2）用userName来访问时，先通过索引表查询到userId，再定位相应的库3）索引表属性较少，可以容纳非常多数据，一般不需要分库4）如果数据量过大，可以通过userName来分库 潜在不足：多一次数据库查询，性能下降一倍。 缓存映射法思路：访问索引表性能较低，把映射关系放在缓存里性能更佳。 解决方案：1）userName查询先到cache中查询userId，再根据userId定位数据库2）假设cache miss，采用扫全库法获取userName对应的userId，放入cache3）userName到userId的映射关系不会变化，映射关系一旦放入缓存，不会更改，无需淘汰，缓存命中率超高4）如果数据量过大，可以通过userName进行cache水平切分 潜在不足：多一次cache查询 userName生成userId思路：不进行远程查询，由userName直接得到userId 解决方案：1）在用户注册时，设计函数userName生成userId，userId=f(userName)，按userId分库插入数据2）用userName来访问时，先通过函数计算出userId，即userId=f(userName)再来一遍，由userId路由到对应库 潜在不足：该函数设计需要非常讲究技巧，有userId生成冲突风险 userName基因融入userId思路：不能用userName生成userId，可以从userName抽取“基因”，融入userId中 假设分8库，采用userId%8路由，潜台词是，userId的最后3个bit决定这条数据落在哪个库上，这3个bit就是所谓的“基因”。 解决方案：1）在用户注册时，设计函数userName生成3bit基因，userName_gene=f(userName)2）同时，生成61bit的全局唯一id，作为用户的标识3）接着把3bit的userName_gene也作为userId的一部分4）生成64bit的userId，由id和userName_gene拼装而成，并按照userId库插入数据5）用userName来访问时，先通过函数由userName再次复原3bit基因，userName_gene=f(userName)，通过userName_gene%8直接定位到库]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>分库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java基于zxing生成二维码demo]]></title>
    <url>%2F2017%2F03%2F23%2FJava%E5%9F%BA%E4%BA%8Ezxing%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81demo%2F</url>
    <content type="text"><![CDATA[QR码属于矩阵式二维码中的一个种类，由DENSO(日本电装)公司开发，由JIS和ISO将其标准化。QR码的样子其实在很多场合已经能够被看到了，我这还是贴个图展示一下： 这个图如果被正确解码，应该看到百度。 具体的也不说什么了，百度一大把，直接上源码~ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.lincoln.Untils;import com.google.zxing.BarcodeFormat;import com.google.zxing.EncodeHintType;import com.google.zxing.MultiFormatWriter;import com.google.zxing.common.BitMatrix;import javax.imageio.ImageIO;import java.io.File;import java.io.OutputStream;import java.io.IOException;import java.awt.image.BufferedImage;import java.util.Hashtable;public class QRUtil &#123; private static final int BLACK = 0xFF000000; private static final int WHITE = 0xFFFFFFFF; /** * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; String text = "http://www.baidu.com"; int width = 300; int height = 300; //二维码的图片格式 String format = "gif"; Hashtable hints = new Hashtable(); //内容所使用编码 hints.put(EncodeHintType.CHARACTER_SET, "utf-8"); BitMatrix bitMatrix = new MultiFormatWriter().encode(text, BarcodeFormat.QR_CODE, width, height, hints); //生成二维码 File outputFile = new File("/Users/lizhi/Downloads" + File.separator + "new.gif"); QRUtil.writeToFile(bitMatrix, format, outputFile); &#125; private QRUtil() &#123; &#125; public static BufferedImage toBufferedImage(BitMatrix matrix) &#123; int width = matrix.getWidth(); int height = matrix.getHeight(); BufferedImage image = new BufferedImage(width, height, BufferedImage.TYPE_INT_RGB); for (int x = 0; x &lt; width; x++) &#123; for (int y = 0; y &lt; height; y++) &#123; image.setRGB(x, y, matrix.get(x, y) ? BLACK : WHITE); &#125; &#125; return image; &#125; public static void writeToFile(BitMatrix matrix, String format, File file) throws IOException &#123; BufferedImage image = toBufferedImage(matrix); if (!ImageIO.write(image, format, file)) &#123; throw new IOException("Could not write an image of format " + format + " to " + file); &#125; &#125; public static void writeToStream(BitMatrix matrix, String format, OutputStream stream) throws IOException &#123; BufferedImage image = toBufferedImage(matrix); if (!ImageIO.write(image, format, stream)) &#123; throw new IOException("Could not write an image of format " + format); &#125; &#125;&#125; 恩，就这么简单。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>二维码</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java网易短信接入demo]]></title>
    <url>%2F2017%2F03%2F23%2FJava%E7%BD%91%E6%98%93%E7%9F%AD%E4%BF%A1%E6%8E%A5%E5%85%A5demo%2F</url>
    <content type="text"><![CDATA[由于最近使用云信添加短信接入功能，记录一下一些点避免时间久了忘记。 发短信 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.lincoln.Untils;import com.alibaba.fastjson.JSON;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;import java.io.IOException;import java.util.ArrayList;import java.util.Date;import java.util.List;import java.util.Map;public class Yunxin &#123; public static void main(String[] args) throws Exception &#123; System.out.println(sendMsg("158********")); &#125; private static final String SERVER_URL = "https://api.netease.im/sms/sendcode.action";//发送验证码的请求路径URL private static final String APP_KEY = "*******";//网易云信分配的账号 private static final String APP_SECRET = "*******";//网易云信分配的密钥 private static final String NONCE = "123456";//随机数 public static String sendMsg(String phone) throws IOException &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); HttpPost post = new HttpPost(SERVER_URL); String curTime = String.valueOf((new Date().getTime() / 1000L)); String checkSum = CheckSumBuilder.getCheckSum(APP_SECRET, NONCE, curTime); //设置请求的header post.addHeader("AppKey", APP_KEY); post.addHeader("Nonce", NONCE); post.addHeader("CurTime", curTime); post.addHeader("CheckSum", checkSum); post.addHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); //设置请求参数 List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(); nameValuePairs.add(new BasicNameValuePair("mobile", phone)); post.setEntity(new UrlEncodedFormEntity(nameValuePairs, "utf-8")); //执行请求 HttpResponse response = httpclient.execute(post); String responseEntity = EntityUtils.toString(response.getEntity(), "utf-8"); //判断是否发送成功，发送成功返回true String code = JSON.parseObject(responseEntity).getString("code"); if (code.equals("200")) &#123; return "success"; &#125; return "error"; &#125;&#125; 验证 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273package com.lincoln.Untils;/** * @author 李智 * @date 2017/3/22 */import java.io.IOException;import java.util.ArrayList;import java.util.Date;import java.util.List;import com.alibaba.fastjson.JSON;import org.apache.http.HttpResponse;import org.apache.http.NameValuePair;import org.apache.http.client.entity.UrlEncodedFormEntity;import org.apache.http.client.methods.HttpPost;import org.apache.http.impl.client.CloseableHttpClient;import org.apache.http.impl.client.HttpClients;import org.apache.http.message.BasicNameValuePair;import org.apache.http.util.EntityUtils;/** * 校验验证码工具类 * * @author Administrator */public class MobileMessageCheck &#123; public static void main(String[] args) throws Exception &#123; System.out.println(checkMsg("158********","1234")); &#125; private static final String SERVER_URL = "https://api.netease.im/sms/verifycode.action";//校验验证码的请求路径URL private static final String APP_KEY = "*******";//网易云信分配的账号 private static final String APP_SECRET = "*******";//网易云信分配的密钥 private static final String NONCE = "123456";//随机数 public static String checkMsg(String phone, String sum) throws IOException &#123; CloseableHttpClient httpclient = HttpClients.createDefault(); HttpPost post = new HttpPost(SERVER_URL); String curTime = String.valueOf((new Date().getTime() / 1000L)); String checkSum = CheckSumBuilder.getCheckSum(APP_SECRET, NONCE, curTime); //设置请求的header post.addHeader("AppKey", APP_KEY); post.addHeader("Nonce", NONCE); post.addHeader("CurTime", curTime); post.addHeader("CheckSum", checkSum); post.addHeader("Content-Type", "application/x-www-form-urlencoded;charset=utf-8"); //设置请求参数 List&lt;NameValuePair&gt; nameValuePairs = new ArrayList&lt;NameValuePair&gt;(); nameValuePairs.add(new BasicNameValuePair("mobile", phone)); nameValuePairs.add(new BasicNameValuePair("code", sum)); post.setEntity(new UrlEncodedFormEntity(nameValuePairs, "utf-8")); //执行请求 HttpResponse response = httpclient.execute(post); String responseEntity = EntityUtils.toString(response.getEntity(), "utf-8"); //判断是否发送成功，发送成功返回true String code = JSON.parseObject(responseEntity).getString("code"); if (code.equals("200")) &#123; return "success"; &#125; return "error"; &#125;&#125; 获取计算checksum 123456789101112131415161718192021222324252627282930313233343536373839404142434445package com.lincoln.Untils;import java.security.MessageDigest;/** * @author 李智 * @date 2017/3/22 */public class CheckSumBuilder &#123; // 计算并获取CheckSum public static String getCheckSum(String appSecret, String nonce, String curTime) &#123; return encode("sha1", appSecret + nonce + curTime); &#125; // 计算并获取md5值 public static String getMD5(String requestBody) &#123; return encode("md5", requestBody); &#125; private static String encode(String algorithm, String value) &#123; if (value == null) &#123; return null; &#125; try &#123; MessageDigest messageDigest = MessageDigest.getInstance(algorithm); messageDigest.update(value.getBytes()); return getFormattedText(messageDigest.digest()); &#125; catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; private static String getFormattedText(byte[] bytes) &#123; int len = bytes.length; StringBuilder buf = new StringBuilder(len * 2); for (int j = 0; j &lt; len; j++) &#123; buf.append(HEX_DIGITS[(bytes[j] &gt;&gt; 4) &amp; 0x0f]); buf.append(HEX_DIGITS[bytes[j] &amp; 0x0f]); &#125; return buf.toString(); &#125; private static final char[] HEX_DIGITS = &#123;'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'&#125;;&#125; 亲测有效。 ps:这里用的是默认的短信模板，如果自定义了短信模板，传入参数的时候多加一个模板id就行了。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java使用websocket和WebRTC实现视频通话]]></title>
    <url>%2F2017%2F03%2F11%2FJava%E4%BD%BF%E7%94%A8websocket%E5%92%8CWebRTC%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[最近这段时间折腾了一下WebRTC，这两天终于是抽了时间把WebRTC搞定了，去年就想弄的，但是确实没时间。看了网上的https://apprtc.appspot.com/的例子（可能需要翻墙访问），这个例子是部署在Google App Engine上的应用程序，依赖与GAE的环境，后台的语言是python，而且还依赖Google App Engine Channel API，所以无法在本地运行，也无法扩展。费了一番功夫研读了例子的python端的源代码，决定用Java实现，Tomcat7之后开始支持WebSocket，打算用WebSocket代替Google App Engine Channel API实现前后台的通讯，在整个例子中Java+WebSocket起到的作用是负责客户端之间的通信，并不负责视频的传输，视频的传输依赖于WebRTC。 首先WebRTC,这个可以百度一下，大概就是一个音频和视频通讯技术，可以跨平台，只要能用浏览器的基本都可以使用，当然要你的浏览器支持。 这里引用了google的js库：channel.js。不过还是下载下来放到本地服务器吧，因为很多地方访问google.com很吃力啊。最开始就是这个js没有加载完郁闷了很久，还一直以为是代码写错了。 另外在进入页面的时候，注意初始化页面js中的一个参数：initiator：如果是创建人这个参数设为false；如果是加入的时候这个设置为true。为true的时候，才会发起视频通话的请求。 实现 对于前端JS代码及用到的对象大家可以去查看详细的代码介绍，我就贴一个连接的方法。首先建立一个客户端实时获取状态的连接，在GAE的例子上是通过GAE Channel API实现，我在这里用WebSocket实现，代码： 12345678function openChannel() &#123; console.log("打开websocket"); socket = new WebSocket("ws://192.168.1.158:8080/WebRTC/acgist.video/$&#123;requestScope.uid&#125;"); socket.onopen = onChannelOpened; socket.onmessage = onChannelMessage; socket.onclose = onChannelClosed; socket.onerror = onChannelError(); &#125; 服务端代码很简单，就是收到用户的请求，发送给另外一个用户就可以了，这里处理的其实是用户WebRTC的一些信息，并不是去传输视频，如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138import java.io.IOException;import java.util.Collections;import java.util.HashMap;import java.util.Map; import javax.websocket.OnClose;import javax.websocket.OnMessage;import javax.websocket.OnOpen;import javax.websocket.Session;import javax.websocket.server.PathParam;import javax.websocket.server.ServerEndpoint;/** * @author 李智 * @date 2017/3/11 * * WebRTC视频通话 */ @ServerEndpoint("/acgist.video/&#123;uid&#125;")public class AcgistVideo &#123; // 最大通话数量 private static final int MAX_COUNT = 10; private static final long MAX_TIME_OUT = 1 * 60 * 1000; // 用户和用户的对话映射 private static final Map&lt;String, String&gt; user_user = Collections.synchronizedMap(new HashMap&lt;String, String&gt;()); // 用户和websocket的session映射 private static final Map&lt;String, Session&gt; sessions = Collections.synchronizedMap(new HashMap&lt;String, Session&gt;()); /** * 打开websocket * @param session websocket的session * @param uid 打开用户的UID */ @OnOpen public void onOpen(Session session, @PathParam("uid")String uid) &#123; session.setMaxIdleTimeout(MAX_TIME_OUT); sessions.put(uid, session); &#125; /** * websocket关闭 * @param session 关闭的session * @param uid 关闭的用户标识 */ @OnClose public void onClose(Session session, @PathParam("uid")String uid) &#123; remove(session, uid); &#125; /** * 收到消息 * @param message 消息内容 * @param session 发送消息的session * @param uid */ @OnMessage public void onMessage(String message, Session session, @PathParam("uid")String uid) &#123; try &#123; if(uid != null &amp;&amp; user_user.get(uid) != null &amp;&amp; AcgistVideo.sessions.get(user_user.get(uid)) != null) &#123; Session osession = sessions.get(user_user.get(uid)); // 被呼叫的session if(osession.isOpen()) osession.getAsyncRemote().sendText(new String(message.getBytes("utf-8"))); else this.nowaiting(osession); &#125; else &#123; this.nowaiting(session); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; /** * 没有人在等待 * @param session 发送消息的session */ private void nowaiting(Session session) &#123; session.getAsyncRemote().sendText("&#123;\"type\" : \"nowaiting\"&#125;"); &#125; /** * 是否可以继续创建通话房间 * @return 可以：true；不可以false； */ public static boolean canCreate() &#123; return sessions.size() &lt;= MAX_COUNT; &#125; /** * 判断是否可以加入 * @param oid 被申请对话的ID * @return 如果能加入返回：true；否则返回false； */ public static boolean canJoin(String oid) &#123; return !(oid != null &amp;&amp; user_user.containsKey(oid) &amp;&amp; user_user.get(oid) != null); &#125; /** * 添加视频对象 * @param uid 申请对话的ID * @param oid 被申请对话的ID * @return 是否是创建者：如果没有申请对话ID为创建者，否则为为加入者。创建者返回：true；加入者返回：false； */ public static boolean addUser(String uid, String oid) &#123; if(oid != null &amp;&amp; !oid.isEmpty()) &#123; AcgistVideo.user_user.put(uid, oid); AcgistVideo.user_user.put(oid, uid); return false; &#125; else &#123; AcgistVideo.user_user.put(uid, null); return true; &#125; &#125; /** * 移除聊天用户 * @param session 移除的session * @param uid 移除的UID */ private static void remove(Session session, String uid) &#123; String oid = user_user.get(uid); if(oid != null) user_user.put(oid, null); // 设置对方无人聊天 sessions.remove(uid); // 异常session user_user.remove(uid); // 移除自己 try &#123; if(session != null &amp;&amp; session.isOpen()) session.close(); // 关闭session &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 自己测试的时候搞个公用的stun服务器弄一弄就好了。不过人多的时候会延迟很就是了，成功截图就不放了，人丑家贫。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>WebSocket</tag>
        <tag>WebRTC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring ioc原理（自己也可以写个spring）]]></title>
    <url>%2F2017%2F03%2F10%2Fspring-ioc%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[最近，买了本spring入门书：spring In Action 。大致浏览了下感觉还不错。就是入门了点。Manning的书还是不错的，我虽然不像哪些只看Manning书的人那样专注于Manning,但怀着崇敬的心情和激情通览了一遍。又一次接受了IOC 、DI、AOP等Spring核心概念。 先就IOC和DI谈一点我的看法。IOC（DI）：其实这个Spring架构核心的概念没有这么复杂，更不像有些书上描述的那样晦涩。Java程序员都知道：java程序中的每个业务逻辑至少需要两个或以上的对象来协作完成，通常，每个对象在使用他的合作对象时，自己均要使用像new object（） 这样的语法来完成合作对象的申请工作。你会发现：对象间的耦合度高了。而IOC的思想是：Spring容器来实现这些相互依赖对象的创建、协调工作。对象只需要关系业务逻辑本身就可以了。从这方面来说，对象如何得到他的协作对象的责任被反转了（IOC、DI）。 这是我对Spring的IOC的体会。DI其实就是IOC的另外一种说法。DI是由Martin Fowler 在2004年初的一篇论文中首次提出的。他总结：控制的什么被反转了？就是：获得依赖对象的方式反转了。 如果对这一核心概念还不理解：这里引用一个叫Bromon的blog上找到的浅显易懂的答案： IoC与DI 首先想说说IoC（Inversion of Control，控制倒转）。这是spring的核心，贯穿始终。所谓IoC，对于spring框架来说，就是由spring来负责控制对象的生命周期和对象间的关系。这是什么意思呢，举个简单的例子，我们是如何找女朋友的？常见的情况是，我们到处去看哪里有长得漂亮身材又好的mm，然后打听她们的兴趣爱好、qq号、电话号、ip号、iq号………，想办法认识她们，投其所好送其所要，然后嘿嘿……这个过程是复杂深奥的，我们必须自己设计和面对每个环节。传统的程序开发也是如此，在一个对象中，如果要使用另外的对象，就必须得到它（自己new一个，或者从JNDI中查询一个），使用完之后还要将对象销毁（比如Connection等），对象始终会和其他的接口或类藕合起来。 那么IoC是如何做的呢？有点像通过婚介找女朋友，在我和女朋友之间引入了一个第三者：婚姻介绍所。婚介管理了很多男男女女的资料，我可以向婚介提出一个列表，告诉它我想找个什么样的女朋友，比如长得像李嘉欣，身材像林熙雷，唱歌像周杰伦，速度像卡洛斯，技术像齐达内之类的，然后婚介就会按照我们的要求，提供一个mm，我们只需要去和她谈恋爱、结婚就行了。简单明了，如果婚介给我们的人选不符合要求，我们就会抛出异常。整个过程不再由我自己控制，而是有婚介这样一个类似容器的机构来控制。Spring所倡导的开发方式就是如此，所有的类都会在spring容器中登记，告诉spring你是个什么东西，你需要什么东西，然后spring会在系统运行到适当的时候，把你要的东西主动给你，同时也把你交给其他需要你的东西。所有的类的创建、销毁都由 spring来控制，也就是说控制对象生存周期的不再是引用它的对象，而是spring。对于某个具体的对象而言，以前是它控制其他对象，现在是所有对象都被spring控制，所以这叫控制反转。如果你还不明白的话，我决定放弃。 IoC的一个重点是在系统运行中，动态的向某个对象提供它所需要的其他对象。这一点是通过DI（Dependency Injection，依赖注入）来实现的。比如对象A需要操作数据库，以前我们总是要在A中自己编写代码来获得一个Connection对象，有了 spring我们就只需要告诉spring，A中需要一个Connection，至于这个Connection怎么构造，何时构造，A不需要知道。在系统运行时，spring会在适当的时候制造一个Connection，然后像打针一样，注射到A当中，这样就完成了对各个对象之间关系的控制。A需要依赖 Connection才能正常运行，而这个Connection是由spring注入到A中的，依赖注入的名字就这么来的。那么DI是如何实现的呢？ Java 1.3之后一个重要特征是反射（reflection），它允许程序在运行的时候动态的生成对象、执行对象的方法、改变对象的属性，spring就是通过反射来实现注入的。关于反射的相关资料请查阅java doc。 理解了IoC和DI的概念后，一切都将变得简单明了，剩下的工作只是在spring的框架中堆积木而已。 如果还不明白，放弃java吧！ 下面来让大家了解一下Spring到底是怎么运行的。 123456public static void main(String[] args) &#123; ApplicationContext context = new FileSystemXmlApplicationContext( "applicationContext.xml"); Animal animal = (Animal) context.getBean("animal"); animal.say(); &#125; 这段代码你一定很熟悉吧，不过还是让我们分析一下它吧，首先是applicationContext.xml 123&lt;bean id="animal" class="phz.springframework.test.Cat"&gt; &lt;property name="name" value="kitty" /&gt; &lt;/bean&gt; 他有一个类Cat 123456789public class Cat implements Animal &#123; private String name; public void say() &#123; System.out.println("I am " + name + "!"); &#125; public void setName(String name) &#123; this.name = name; &#125; &#125; 实现了Animal接口 123public interface Animal &#123; public void say(); &#125; 很明显上面的代码输出I am kitty! 那么到底Spring是如何做到的呢？接下来就让我们自己写个Spring 来看看Spring 到底是怎么运行的吧！ 首先，我们定义一个Bean类，这个类用来存放一个Bean拥有的属性 123456/* Bean Id */ private String id; /* Bean Class */ private String type; /* Bean Property */ private Map&lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;(); 一个Bean包括id,type,和Properties。 接下来Spring 就开始加载我们的配置文件了，将我们配置的信息保存在一个HashMap中，HashMap的key就是Bean 的 Id ，HasMap 的value是这个Bean，只有这样我们才能通过context.getBean(“animal”)这个方法获得Animal这个类。我们都知道Spirng可以注入基本类型，而且可以注入像List，Map这样的类型，接下来就让我们以Map为例看看Spring是怎么保存的吧 Map配置可以像下面的 123456789101112&lt;bean id="test" class="Test"&gt; &lt;property name="testMap"&gt; &lt;map&gt; &lt;entry key="a"&gt; &lt;value&gt;1&lt;/value&gt; &lt;/entry&gt; &lt;entry key="b"&gt; &lt;value&gt;2&lt;/value&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;/bean&gt; Spring是怎样保存上面的配置呢？，代码如下： 1234567891011121314151617181920212223242526if (beanProperty.element("map") != null) &#123; Map&lt;String, Object&gt; propertiesMap = new HashMap&lt;String, Object&gt;(); Element propertiesListMap = (Element) beanProperty .elements().get(0); Iterator&lt;?&gt; propertiesIterator = propertiesListMap .elements().iterator(); while (propertiesIterator.hasNext()) &#123; Element vet = (Element) propertiesIterator.next(); if (vet.getName().equals("entry")) &#123; String key = vet.attributeValue("key"); Iterator&lt;?&gt; valuesIterator = vet.elements() .iterator(); while (valuesIterator.hasNext()) &#123; Element value = (Element) valuesIterator.next(); if (value.getName().equals("value")) &#123; propertiesMap.put(key, value.getText()); &#125; if (value.getName().equals("ref")) &#123; propertiesMap.put(key, new String[] &#123; value .attributeValue("bean") &#125;); &#125; &#125; &#125; &#125; bean.getProperties().put(name, propertiesMap); &#125; 接下来就进入最核心部分了，让我们看看Spring 到底是怎么依赖注入的吧，其实依赖注入的思想也很简单，它是通过反射机制实现的，在实例化一个类时，它通过反射调用类中set方法将事先保存在HashMap中的类属性注入到类中。让我们看看具体它是怎么做的吧。首先实例化一个类，像这样 123456789101112131415public static Object newInstance(String className) &#123; Class&lt;?&gt; cls = null; Object obj = null; try &#123; cls = Class.forName(className); obj = cls.newInstance(); &#125; catch (ClassNotFoundException e) &#123; throw new RuntimeException(e); &#125; catch (InstantiationException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; return obj; &#125; 接着它将这个类的依赖注入进去，像这样 12345678910111213141516171819202122232425public static void setProperty(Object obj, String name, String value) &#123; Class&lt;? extends Object&gt; clazz = obj.getClass(); try &#123; String methodName = returnSetMthodName(name); Method[] ms = clazz.getMethods(); for (Method m : ms) &#123; if (m.getName().equals(methodName)) &#123; if (m.getParameterTypes().length == 1) &#123; Class&lt;?&gt; clazzParameterType = m.getParameterTypes()[0]; setFieldValue(clazzParameterType.getName(), value, m, obj); break; &#125; &#125; &#125; &#125; catch (SecurityException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalArgumentException e) &#123; throw new RuntimeException(e); &#125; catch (IllegalAccessException e) &#123; throw new RuntimeException(e); &#125; catch (InvocationTargetException e) &#123; throw new RuntimeException(e); &#125; &#125; 最后它将这个类的实例返回给我们，我们就可以用了。我们还是以Map为例看看它是怎么做的，我写的代码里面是创建一个HashMap并把该HashMap注入到需要注入的类中，像这样， 12345678910111213if (value instanceof Map) &#123; Iterator&lt;?&gt; entryIterator = ((Map&lt;?, ?&gt;) value).entrySet() .iterator(); Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); while (entryIterator.hasNext()) &#123; Entry&lt;?, ?&gt; entryMap = (Entry&lt;?, ?&gt;) entryIterator.next(); if (entryMap.getValue() instanceof String[]) &#123; map.put((String) entryMap.getKey(), getBean(((String[]) entryMap.getValue())[0])); &#125; &#125; BeanProcesser.setProperty(obj, property, map); &#125; 好了，这样我们就可以用Spring 给我们创建的类了，是不是也不是很难啊？当然Spring能做到的远不止这些，这个示例程序仅仅提供了Spring最核心的依赖注入功能中的一部分。本文参考了大量文章无法一一感谢，在这一起感谢，如果侵犯了你的版权深表歉意，很希望对大家有帮助！]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volatile小结]]></title>
    <url>%2F2017%2F03%2F03%2FVolatile%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[1）Java 中能创建 Volatile 数组吗？ 能，Java 中可以创建 volatile 类型数组，不过只是一个指向数组的引用，而不是整个数组。我的意思是，如果改变引用指向的数组，将会受到 volatile 的保护，但是如果多个线程同时改变数组的元素，volatile 标示符就不能起到之前的保护作用了。 2）volatile 能使得一个非原子操作变成原子操作吗？ 一个典型的例子是在类中有一个 long 类型的成员变量。如果你知道该成员变量会被多个线程访问，如计数器、价格等，你最好是将其设置为 volatile。为什么？因为 Java 中读取 long 类型变量不是原子的，需要分成两步，如果一个线程正在修改该 long 变量的值，另一个线程可能只能看到该值的一半（前 32 位）。但是对一个 volatile 型的 long 或 double 变量的读写是原子。 3）volatile 修饰符有过什么实践？ 一种实践是用 volatile 修饰 long 和 double 变量，使其能按原子类型来读写。double 和 long 都是64位宽，因此对这两种类型的读是分为两部分的，第一次读取第一个 32 位，然后再读剩下的 32 位，这个过程不是原子的，但 Java 中 volatile 型的 long 或 double 变量的读写是原子的。volatile 修复符的另一个作用是提供内存屏障（memory barrier），例如在分布式框架中的应用。简单的说，就是当你写一个 volatile 变量之前，Java 内存模型会插入一个写屏障（write barrier），读一个 volatile 变量之前，会插入一个读屏障（read barrier）。意思就是说，在你写一个 volatile 域时，能保证任何线程都能看到你写的值，同时，在写之前，也能保证任何数值的更新对所有线程是可见的，因为内存屏障会将其他所有写的值更新到缓存。 4）volatile 类型变量提供什么保证？ volatile 变量提供顺序和可见性保证，例如，JVM 或者 JIT为了获得更好的性能会对语句重排序，但是 volatile 类型变量即使在没有同步块的情况下赋值也不会与其他语句重排序。 volatile 提供 happens-before 的保证，确保一个线程的修改能对其他线程是可见的。某些情况下，volatile 还能提供原子性，如读 64 位数据类型，像 long 和 double 都不是原子的，但 volatile 类型的 double 和 long 就是原子的。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么volatile不能保证原子性而Atomic可以？]]></title>
    <url>%2F2017%2F03%2F02%2F%E4%B8%BA%E4%BB%80%E4%B9%88volatile%E4%B8%8D%E8%83%BD%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E8%80%8CAtomic%E5%8F%AF%E4%BB%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[在Java中long赋值不是原子操作，因为先写32位，再写后32位，分两步操作，而AtomicLong赋值是原子操作，为什么？为什么volatile能替代简单的锁，却不能保证原子性？这里面涉及volatile，是java中的一个我觉得这个词在Java规范中从未被解释清楚的神奇关键词，在Sun的JDK官方文档是这样形容volatile的： The Java programming language provides a second mechanism, volatile fields, that is more convenient than locking for some purposes. A field may be declared volatile, in which case the Java Memory Model ensures that all threads see a consistent value for the variable. 意思就是说，如果一个变量加了volatile关键字，就会告诉编译器和JVM的内存模型：这个变量是对所有线程共享的、可见的，每次jvm都会读取最新写入的值并使其最新值在所有CPU可见。volatile似乎是有时候可以代替简单的锁，似乎加了volatile关键字就省掉了锁。但又说volatile不能保证原子性（java程序员很熟悉这句话：volatile仅仅用来保证该变量对所有线程的可见性，但不保证原子性）。这不是互相矛盾吗？ 不要将volatile用在getAndOperate场合，仅仅set或者get的场景是适合volatile的 不要将volatile用在getAndOperate场合（这种场合不原子，需要再加锁），仅仅set或者get的场景是适合volatile的。 volatile没有原子性举例：AtomicInteger自增 例如你让一个volatile的integer自增（i++），其实要分成3步：1）读取volatile变量值到local； 2）增加变量的值；3）把local的值写回，让其它的线程可见。这3步的jvm指令为： 1234mov 0xc(%r10),%r8d ; Loadinc %r8d ; Incrementmov %r8d,0xc(%r10) ; Storelock addl $0x0,(%rsp) ; StoreLoad Barrier 注意最后一步是内存屏障。 什么是内存屏障（Memory Barrier）？ 内存屏障（memory barrier）是一个CPU指令。基本上，它是这样一条指令： a) 确保一些特定操作执行的顺序； b) 影响一些数据的可见性(可能是某些指令执行后的结果)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障，相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。 内存屏障（memory barrier）和volatile什么关系？上面的虚拟机指令里面有提到，如果你的字段是volatile，Java内存模型将在写操作后插入一个写屏障指令，在读操作前插入一个读屏障指令。这意味着如果你对一个volatile字段进行写操作，你必须知道：1、一旦你完成写入，任何访问这个字段的线程将会得到最新的值。2、在你写入前，会保证所有之前发生的事已经发生，并且任何更新过的数据值也是可见的，因为内存屏障会把之前的写入值都刷新到缓存。 volatile为什么没有原子性? 明白了内存屏障（memory barrier）这个CPU指令，回到前面的JVM指令：从Load到store到内存屏障，一共4步，其中最后一步jvm让这个最新的变量的值在所有线程可见，也就是最后一步让所有的CPU内核都获得了最新的值，但中间的几步（从Load到Store）是不安全的，中间如果其他的CPU修改了值将会丢失。下面的测试代码可以实际测试voaltile的自增没有原子性： 12345678910111213141516171819202122232425262728293031323334353637383940 private static volatile long _longVal = 0; private static class LoopVolatile implements Runnable &#123; public void run() &#123; long val = 0; while (val &lt; 10000000L) &#123; _longVal++; val++; &#125; &#125; &#125; private static class LoopVolatile2 implements Runnable &#123; public void run() &#123; long val = 0; while (val &lt; 10000000L) &#123; _longVal++; val++; &#125; &#125; &#125; private void testVolatile()&#123; Thread t1 = new Thread(new LoopVolatile()); t1.start(); Thread t2 = new Thread(new LoopVolatile2()); t2.start(); while (t1.isAlive() || t2.isAlive()) &#123; &#125; System.out.println("final val is: " + _longVal); &#125; Output:------------- final val is: 11223828final val is: 17567127final val is: 12912109 volatile没有原子性举例：singleton单例模式实现 这是一段线程不安全的singleton（单例模式）实现，尽管使用了volatile： 1234567891011121314public class wrongsingleton &#123; private static volatile wrongsingleton _instance = null; private wrongsingleton() &#123;&#125; public static wrongsingleton getInstance() &#123; if (_instance == null) &#123; _instance = new wrongsingleton(); &#125; return _instance; &#125;&#125; 下面的测试代码可以测试出是线程不安全的： 123456789101112131415161718192021222324252627282930313233public class wrongsingleton &#123; private static volatile wrongsingleton _instance = null; private wrongsingleton() &#123;&#125; public static wrongsingleton getInstance() &#123; if (_instance == null) &#123; _instance = new wrongsingleton(); System.out.println("--initialized once."); &#125; return _instance; &#125;&#125; private static void testInit()&#123; Thread t1 = new Thread(new LoopInit()); Thread t2 = new Thread(new LoopInit2()); Thread t3 = new Thread(new LoopInit()); Thread t4 = new Thread(new LoopInit2()); t1.start(); t2.start(); t3.start(); t4.start(); while (t1.isAlive() || t2.isAlive() || t3.isAlive()|| t4.isAlive()) &#123; &#125; &#125;输出：有时输出"--initialized once."一次，有时输出好几次 原因自然和上面的例子是一样的。因为volatile保证变量对线程的可见性，但不保证原子性。 附：正确线程安全的单例模式写法： 123456789@ThreadSafepublic class SafeLazyInitialization &#123; private static Resource resource; public synchronized static Resource getInstance() &#123; if (resource == null) resource = new Resource(); return resource; &#125; &#125; 另外一种写法： 12345@ThreadSafepublic class EagerInitialization &#123; private static Resource resource = new Resource(); public static Resource getResource() &#123; return resource; &#125; &#125; 延迟初始化的写法： 123456789@ThreadSafepublic class ResourceFactory &#123; private static class ResourceHolder &#123; public static Resource resource = new Resource(); &#125; public static Resource getResource() &#123; return ResourceHolder.resource ; &#125; &#125; 二次检查锁定/Double Checked Locking的写法（反模式） 12345678910111213141516public class SingletonDemo &#123; private static volatile SingletonDemo instance = null;//注意需要volatile private SingletonDemo() &#123; &#125; public static SingletonDemo getInstance() &#123; if (instance == null) &#123; //二次检查，比直接用独占锁效率高 synchronized (SingletonDemo .class)&#123; if (instance == null) &#123; instance = new SingletonDemo (); &#125; &#125; &#125; return instance; &#125;&#125; 为什么AtomicXXX具有原子性和可见性？ 就拿AtomicLong来说，它既解决了上述的volatile的原子性没有保证的问题，又具有可见性。它是如何做到的？CAS（比较并交换）指令。 其实AtomicLong的源码里也用到了volatile，但只是用来读取或写入，见源码： 1234567891011121314151617public class AtomicLong extends Number implements java.io.Serializable &#123; private volatile long value; /** * Creates a new AtomicLong with the given initial value. * * @param initialValue the initial value */ public AtomicLong(long initialValue) &#123; value = initialValue; &#125; /** * Creates a new AtomicLong with initial value &#123;@code 0&#125;. */ public AtomicLong() &#123; &#125; 其CAS源码核心代码为： 123456789int compare_and_swap (int* reg, int oldval, int newval) &#123; ATOMIC(); int old_reg_val = *reg; if (old_reg_val == oldval) *reg = newval; END_ATOMIC(); return old_reg_val;&#125; 虚拟机指令为： 1234mov 0xc(%r11),%eax ; Loadmov %eax,%r8d inc %r8d ; Incrementlock cmpxchg %r8d,0xc(%r11) ; Compare and exchange 因为CAS是基于乐观锁的，也就是说当写入的时候，如果寄存器旧值已经不等于现值，说明有其他CPU在修改，那就继续尝试。所以这就保证了操作的原子性。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库系统分层优化]]></title>
    <url>%2F2017%2F02%2F24%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%88%86%E5%B1%82%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[网上有丰富的数据库优化方案，但是大多都是零零碎碎，系统地介绍数据库优化的很少。笔者根据自己的经验，以及参考了其他高手的优化文章，整理一份系统的优化方案。 数据库优化的目的是提高DB的工作效率，减少响应时间。基于此，笔者认为应该从如下四个层次来优化数据库性能。 硬件层面优化 操作系统/DBMS层面优化 DB设计层面优化 程序设计层面的优化 硬件层面优化该层面的优化是最底层的，包括内存、CPU、磁盘/磁盘阵列等硬件的优化。虽然可优化的点并不多，但是在整个数据库优化中不可或缺。 操作系统/DBMS层面的优化包括DBMS的选择、缓存的设置、数据文件的存储位置及方法(连续存储/随机存储)、存储引擎的选择(MySQL里面会有多个引擎)、I/O优化(磁盘I/O、逻辑I/O)。该层面的优化内容相对不多，但是数据库优化的瓶颈一般都在这里。 DB设计层面优化该层面可优化的点很多，包括数据库范式、数据表结构、数据类型、视图、索引、表/字段冗余、表分割(水平分割及垂直分割、分类分割)、表触发器、命名等多方面，而且每个方面又有很多的知识点，这是数据库优化的基础。 程序设计层面优化这里由程序员控制层面的优化。包括SQL语句、存储过程、临时表、业务逻辑、算法设计、运算符、条件顺序、数据库函数。这层的知识点比较散，而且多。程序员应该下功夫的地方。]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[希尔排序]]></title>
    <url>%2F2017%2F02%2F20%2F%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。希尔排序是非稳定排序算法。希尔排序是基于插入排序的以下两点性质而提出改进方法的： 插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率 但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位原始的算法实现在最坏的情况下需要进行O(n2)的比较和交换。之后对算法进行了少量修改，可以使得性能提升至O(n log2 n)。这比最好的比较算法的O(n log n)要差一些。 希尔排序通过将比较的全部元素分为几个区域来提升插入排序的性能。这样可以让一个元素可以一次性地朝最终位置前进一大步。然后算法再取越来越小的步长进行排序，算法的最后一步就是普通的插入排序，但是到了这步，需排序的数据几乎是已排好的了（此时插入排序较快）。 假设有一个很小的数据在一个已按升序排好序的数组的末端。如果用复杂度为O(n2)的排序（冒泡排序或插入排序），可能会进行n次的比较和交换才能将该数据移至正确位置。而希尔排序会用较大的步长移动数据，所以小数据只需进行少数比较和交换即可到正确位置。 一个更好理解的希尔排序实现：将数组列在一个表中并对列排序（用插入排序）。重复这过程，不过每次用更长的列来进行。最后整个表就只有一列了。将数组转换至表是为了更好地理解这算法，算法本身仅仅对原数组进行排序（通过增加索引的步长，例如是用i += step_size而不是i++）。 例如，假设有这样一组数[ 13 14 94 33 82 25 59 94 65 23 45 27 73 25 39 10 ]，如果我们以步长为5开始进行排序，我们可以通过将这列表放在有5列的表中来更好地描述算法，这样他们就应该看起来是这样： 13 14 94 33 8225 59 94 65 2345 27 73 25 3910 然后我们对每列进行排序： 10 14 73 25 2313 27 94 33 3925 59 94 65 8245 将上述四行数字，依序接在一起时我们得到：[ 10 14 73 25 23 13 27 94 33 39 25 59 94 65 82 45 ].这时10已经移至正确位置了，然后再以3为步长进行排序： 10 14 7325 23 1327 94 3339 25 5994 65 8245 排序之后变为： 10 14 1325 23 3327 25 5939 65 7345 94 8294 最后以1步长进行排序（此时就是简单的插入排序了）。 步长的选择是希尔排序的重要部分。只要最终步长为1任何步长序列都可以工作。算法最开始以一定的步长进行排序。然后会继续以一定步长进行排序，最终算法以步长为1进行排序。当步长为1时，算法变为插入排序，这就保证了数据一定会被排序。 该算法最初建议步长选择为n/2并且对步长取半直到步长达到1。虽然这样取可以比O(n’2)类的算法（插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。 比如，如果一个数列以步长5进行了排序然后再以步长3进行排序，那么该数列不仅是以步长3有序，而且是以步长5有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。 实现：12345678910111213public static void shell_sort(int[] arr) &#123; int gap = 1, i, j, len = arr.length; int temp; while (gap &lt; len / 3) gap = gap * 3 + 1; // 1, 4, 13, 40, 121, ... for (; gap &gt; 0; gap /= 3) for (i = gap; i &lt; len; i++) &#123; temp = arr[i]; for (j = i - gap; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) arr[j + gap] = arr[j]; arr[j + gap] = temp; &#125;&#125;]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库30条军规解读]]></title>
    <url>%2F2017%2F02%2F18%2F58%E5%88%B0%E5%AE%B6%E6%95%B0%E6%8D%AE%E5%BA%9330%E6%9D%A1%E5%86%9B%E8%A7%84%E8%A7%A3%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[军规适用场景：并发量大、数据量大的互联网业务军规：介绍内容解读：讲解原因，解读比军规更重要 一、基础规范 （1）必须使用InnoDB存储引擎 解读：支持事务、行级锁、并发性能更好、CPU及内存缓存页优化使得资源利用率更高 （2）必须使用UTF8字符集 解读：万国码，无需转码，无乱码风险，节省空间 （3）数据表、数据字段必须加入中文注释 解读：N年后谁tm知道这个r1,r2,r3字段是干嘛的 （4）禁止使用存储过程、视图、触发器、Event 解读：高并发大数据的互联网业务，架构设计思路是“解放数据库CPU，将计算转移到服务层”，并发量大的情况下，这些功能很可能将数据库拖死，业务逻辑放到服务层具备更好的扩展性，能够轻易实现“增机器就加性能”。数据库擅长存储与索引，CPU计算还是上移吧 （5）禁止存储大文件或者大照片 解读：为何要让数据库做它不擅长的事情？大文件和照片存储在文件系统，数据库里存URI多好 二、命名规范 （6）只允许使用内网域名，而不是ip连接数据库 （7）线上环境、开发环境、测试环境数据库内网域名遵循命名规范 业务名称：xxx线上环境：dj.xxx.db开发环境：dj.xxx.rdb测试环境：dj.xxx.tdb从库在名称后加-s标识，备库在名称后加-ss标识线上从库：dj.xxx-s.db线上备库：dj.xxx-sss.db （8）库名、表名、字段名：小写，下划线风格，不超过32个字符，必须见名知意，禁止拼音英文混用 （9）表名t_xxx，非唯一索引名idx_xxx，唯一索引名uniq_xxx 三、表设计规范 （10）单实例表数目必须小于500 （11）单表列数目必须小于30 （12）表必须有主键，例如自增主键 解读：a）主键递增，数据行写入可以提高插入性能，可以避免page分裂，减少表碎片提升空间和内存的使用b）主键要选择较短的数据类型， Innodb引擎普通索引都会保存主键的值，较短的数据类型可以有效的减少索引的磁盘空间，提高索引的缓存效率c） 无主键的表删除，在row模式的主从架构，会导致备库夯住 （13）禁止使用外键，如果有外键完整性约束，需要应用程序控制 解读：外键会导致表与表之间耦合，update与delete操作都会涉及相关联的表，十分影响sql 的性能，甚至会造成死锁。高并发情况下容易造成数据库性能，大数据高并发业务场景数据库使用以性能优先 四、字段设计规范 （14）必须把字段定义为NOT NULL并且提供默认值 解读：a）null的列使索引/索引统计/值比较都更加复杂，对MySQL来说更难优化b）null 这种类型MySQL内部需要进行特殊处理，增加数据库处理记录的复杂性；同等条件下，表中有较多空字段的时候，数据库的处理性能会降低很多c）null值需要更多的存储空，无论是表还是索引中每行中的null的列都需要额外的空间来标识d）对null 的处理时候，只能采用is null或is not null，而不能采用=、in、&lt;、&lt;&gt;、!=、not in这些操作符号。如：where name!=’shenjian’，如果存在name为null值的记录，查询结果就不会包含name为null值的记录 （15）禁止使用TEXT、BLOB类型 解读：会浪费更多的磁盘和内存空间，非必要的大量的大字段查询会淘汰掉热数据，导致内存命中率急剧降低，影响数据库性能 （16）禁止使用小数存储货币 解读：使用整数吧，小数容易导致钱对不上 （17）必须使用varchar(20)存储手机号 解读：a）涉及到区号或者国家代号，可能出现+-()b）手机号会去做数学运算么？c）varchar可以支持模糊查询，例如：like“138%” （18）禁止使用ENUM，可使用TINYINT代替 解读：a）增加新的ENUM值要做DDL操作b）ENUM的内部实际存储就是整数，你以为自己定义的是字符串？ 五、索引设计规范 （19）单表索引建议控制在5个以内 （20）单索引字段数不允许超过5个 解读：字段超过5个时，实际已经起不到有效过滤数据的作用了 （21）禁止在更新十分频繁、区分度不高的属性上建立索引 解读：a）更新会变更B+树，更新频繁的字段建立索引会大大降低数据库性能b）“性别”这种区分度不大的属性，建立索引是没有什么意义的，不能有效过滤数据，性能与全表扫描类似 （22）建立组合索引，必须把区分度高的字段放在前面 解读：能够更加有效的过滤数据 六、SQL使用规范 （23）禁止使用SELECT *，只获取必要的字段，需要显示说明列属性 解读：a）读取不需要的列会增加CPU、IO、NET消耗b）不能有效的利用覆盖索引c）使用SELECT *容易在增加或者删除字段后出现程序BUG （24）禁止使用INSERT INTO t_xxx VALUES(xxx)，必须显示指定插入的列属性 解读：容易在增加或者删除字段后出现程序BUG （25）禁止使用属性隐式转换 解读：SELECT uid FROM t_user WHERE phone=13812345678 会导致全表扫描，而不能命中phone索引，猜猜为什么？（这个线上问题不止出现过一次） （26）禁止在WHERE条件的属性上使用函数或者表达式 解读：SELECT uid FROM t_user WHERE from_unixtime(day)&gt;=’2017-02-15’ 会导致全表扫描正确的写法是：SELECT uid FROM t_user WHERE day&gt;= unix_timestamp(‘2017-02-15 00:00:00’) （27）禁止负向查询，以及%开头的模糊查询 解读：a）负向查询条件：NOT、!=、&lt;&gt;、!&lt;、!&gt;、NOT IN、NOT LIKE等，会导致全表扫描b）%开头的模糊查询，会导致全表扫描 （28）禁止大表使用JOIN查询，禁止大表使用子查询 解读：会产生临时表，消耗较多内存与CPU，极大影响数据库性能 （29）禁止使用OR条件，必须改为IN查询 解读：旧版本Mysql的OR查询是不能命中索引的，即使能命中索引，为何要让数据库耗费更多的CPU帮助实施查询优化呢？ （30）应用程序必须捕获SQL异常，并有相应处理 总结：大数据量高并发的互联网业务，极大影响数据库性能的都不让用，不让用哟。==【完】==]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>军规</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache poi操作(适用于word 2007)]]></title>
    <url>%2F2017%2F02%2F18%2Fapache-poi%E6%93%8D%E4%BD%9C-%E9%80%82%E7%94%A8%E4%BA%8Eword-2007%2F</url>
    <content type="text"><![CDATA[适用于word 2007 poi 版本 3.7123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.io.FileOutputStream;import java.util.ArrayList;import java.util.HashMap;import java.util.Iterator;import java.util.List;import java.util.Map;import java.util.Map.Entry;import org.apache.poi.POIXMLDocument;import org.apache.poi.openxml4j.opc.OPCPackage;import org.apache.poi.xwpf.usermodel.XWPFDocument;import org.apache.poi.xwpf.usermodel.XWPFParagraph;import org.apache.poi.xwpf.usermodel.XWPFRun;import org.apache.poi.xwpf.usermodel.XWPFTable;import org.apache.poi.xwpf.usermodel.XWPFTableCell;import org.apache.poi.xwpf.usermodel.XWPFTableRow;/** * 适用于word 2007 poi 版本 3.7 */public class WordPoiUtil &#123; /** * 根据指定的参数值、模板，生成 word 文档 * * @param param * 需要替换的变量 * @param template * 模板 */ public static XWPFDocument generateWord(Map&lt;String, Object&gt; param, String template) &#123; XWPFDocument doc = null; try &#123; OPCPackage pack = POIXMLDocument.openPackage(template); doc = new XWPFDocument(pack); if (param != null &amp;&amp; param.size() &gt; 0) &#123; // 处理段落 List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs(); processParagraphs(paragraphList, param, doc); // 处理表格 Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator(); while (it.hasNext()) &#123; XWPFTable table = it.next(); List&lt;XWPFTableRow&gt; rows = table.getRows(); for (XWPFTableRow row : rows) &#123; List&lt;XWPFTableCell&gt; cells = row.getTableCells(); for (XWPFTableCell cell : cells) &#123; List&lt;XWPFParagraph&gt; paragraphListTable = cell .getParagraphs(); processParagraphs(paragraphListTable, param, doc); &#125; &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return doc; &#125; /** * 处理段落 * * @param paragraphList */ public static void processParagraphs(List&lt;XWPFParagraph&gt; paragraphList, Map&lt;String, Object&gt; param, XWPFDocument doc) &#123; if (paragraphList != null &amp;&amp; paragraphList.size() &gt; 0) &#123; for (XWPFParagraph paragraph : paragraphList) &#123; boolean addReplace = false; List&lt;XWPFRun&gt; runs = paragraph.getRuns(); //每个需要替换的key的run的位置的集合 List&lt;Integer&gt; replaceRuns = new ArrayList&lt;Integer&gt;(); //每个段落的所有的key run的集合 List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i&lt; runs.size();i++)&#123; String text = runs.get(i).getText(0); if(addReplace)&#123; replaceRuns.add(i); &#125; if(text != null &amp;&amp; text.contains("#"))&#123; addReplace = true; replaceRuns.add(i); &#125; if(text != null &amp;&amp; text.contains("&#125;"))&#123; addReplace = false; perReplaceRunList.add(replaceRuns); replaceRuns = new ArrayList&lt;Integer&gt;(); &#125; &#125; for(int i=0;i&lt;perReplaceRunList.size();i++)&#123; List&lt;Integer&gt; runsList = perReplaceRunList.get(i); System.out.println("=========================="); StringBuffer textSb = new StringBuffer(); for(int j = 0;j&lt;runsList.size();j++)&#123; System.out.println("============replace_runs"+runs.get(runsList.get(j)).getText(0)); textSb.append(runs.get(runsList.get(j)).getText(0)); &#125; String replaceStr = textSb.toString(); for(int j = 0; j&lt;runsList.size();j++)&#123; for (Entry&lt;String, Object&gt; entry : param.entrySet()) &#123; String key = entry.getKey(); if (replaceStr.indexOf(key) != -1) &#123; Object value = entry.getValue(); if (value instanceof String) &#123;// 文本替换 replaceStr = replaceStr.replace(key, value.toString()); &#125; &#125; &#125; &#125; System.out.println("==========="+replaceStr); for(int j = 0;j&lt;runsList.size();j++)&#123; if(j == 0)&#123; runs.get(runsList.get(j)).setText(replaceStr, 0); &#125;else&#123; runs.get(runsList.get(j)).setText("", 0); &#125; &#125; for(int j = 0;j&lt;runsList.size();j++)&#123; System.out.println("============转换后"+runs.get(runsList.get(j)).getText(0)); &#125; &#125; &#125; &#125; &#125; public static List&lt;String&gt; getReplaceFields(String template)&#123; List&lt;String&gt; replaceFields = new ArrayList&lt;String&gt;(); XWPFDocument doc = null; try &#123; OPCPackage pack = POIXMLDocument.openPackage(template); doc = new XWPFDocument(pack); // 处理段落 List&lt;XWPFParagraph&gt; paragraphList = doc.getParagraphs(); replaceFields.addAll(getFields(paragraphList)); // 处理表格 Iterator&lt;XWPFTable&gt; it = doc.getTablesIterator(); while (it.hasNext()) &#123; XWPFTable table = it.next(); List&lt;XWPFTableRow&gt; rows = table.getRows(); for (XWPFTableRow row : rows) &#123; List&lt;XWPFTableCell&gt; cells = row.getTableCells(); for (XWPFTableCell cell : cells) &#123; List&lt;XWPFParagraph&gt; paragraphListTable = cell .getParagraphs(); replaceFields.addAll(getFields(paragraphListTable)); &#125; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return replaceFields; &#125; /** * 获取段落的需要替换的字段 * @param paragraphList * @return */ public static List&lt;String&gt; getFields(List&lt;XWPFParagraph&gt; paragraphList) &#123; List&lt;String&gt; fieldList = new ArrayList&lt;String&gt;(); if (paragraphList != null &amp;&amp; paragraphList.size() &gt; 0) &#123; for (XWPFParagraph paragraph : paragraphList) &#123; boolean addReplace = false; List&lt;XWPFRun&gt; runs = paragraph.getRuns(); //每个需要替换的key的run的位置的集合 List&lt;Integer&gt; replaceRuns = new ArrayList&lt;Integer&gt;(); //每个段落的所有的key run的集合 List&lt;List&lt;Integer&gt;&gt; perReplaceRunList = new ArrayList&lt;List&lt;Integer&gt;&gt;(); for (int i = 0; i&lt; runs.size();i++)&#123; String text = runs.get(i).getText(0); if(addReplace)&#123; replaceRuns.add(i); &#125; if(text != null &amp;&amp; text.contains("#"))&#123; addReplace = true; replaceRuns.add(i); &#125; if(text != null &amp;&amp; text.contains("&#125;"))&#123; addReplace = false; perReplaceRunList.add(replaceRuns); replaceRuns = new ArrayList&lt;Integer&gt;(); &#125; &#125; for(int i=0;i&lt;perReplaceRunList.size();i++)&#123; List&lt;Integer&gt; runsList = perReplaceRunList.get(i); System.out.println("=========================="); StringBuffer textSb = new StringBuffer(); for(int j = 0;j&lt;runsList.size();j++)&#123; System.out.println("============replace_runs"+runs.get(runsList.get(j)).getText(0)); textSb.append(runs.get(runsList.get(j)).getText(0)); &#125; String replaceStr = textSb.toString().trim(); System.out.println("====replaceStr=" + replaceStr.substring(replaceStr.indexOf("#")+2,replaceStr.length()-1));// System.out.println(replaceStr.substring(2,replaceStr.length()-1)); fieldList.add(replaceStr.substring(replaceStr.indexOf("#")+2,replaceStr.length()-1)); &#125; &#125; &#125; return fieldList; &#125;&#125;]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[时间复杂度和空间复杂度详解]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%92%8C%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[没有挤公交来上班过，就不知道生活的压力有多大。 算法的时间复杂度和空间复杂度合称为算法的复杂度。1.时间复杂度（1）时间频度 一个算法执行所耗费的时间，从理论上是不能算出来的，必须上机运行测试才能知道。但我们不可能也没有必要对每个算法都上机测试，只需知道哪个算法花费的时间多，哪个算法花费的时间少就可以了。并且一个算法花费的时间与算法中语句的执行次数成正比例，哪个算法中语句执行次数多，它花费时间就多。一个算法中的语句执行次数称为语句频度或时间频度。记为T(n)。（2）时间复杂度 在刚才提到的时间频度中，n称为问题的规模，当n不断变化时，时间频度T(n)也会不断变化。但有时我们想知道它变化时呈现什么规律。为此，我们引入时间复杂度概念。 一般情况下，算法中基本操作重复执行的次数是问题规模n的某个函数，用T(n)表示，若有某个辅助函数f(n),使得当n趋近于无穷大时，T（n)/f(n)的极限值为不等于零的常数，则称f(n)是T(n)的同数量级函数。记作T(n)=Ｏ(f(n)),称Ｏ(f(n)) 为算法的渐进时间复杂度，简称时间复杂度。 时间频度不同，但时间复杂度可能相同。如：T(n)=n2+3n+4与T(n)=4n2+2n+1它们的频度不同，但时间复杂度相同，都为O(n2)。 按数量级递增排列，常见的时间复杂度有：常数阶O(1),对数阶O(log2n),线性阶O(n), 线性对数阶O(nlog2n),平方阶O(n2)，立方阶O(n3),…， k次方阶O(nk),指数阶O(2n)。随着问题规模n的不断增大，上述时间复杂度不断增大，算法的执行效率越低。 （3）最坏时间复杂度和平均时间复杂度 最坏情况下的时间复杂度称最坏时间复杂度。一般不特别说明，讨论的时间复杂度均是最坏情况下的时间复杂度。 这样做的原因是：最坏情况下的时间复杂度是算法在任何输入实例上运行时间的上界，这就保证了算法的运行时间不会比任何更长。 在最坏情况下的时间复杂度为T(n)=0(n)，它表示对于任何输入实例,该算法的运行时间不可能大于0(n)。 平均时间复杂度是指所有可能的输入实例均以等概率出现的情况下，算法的期望运行时间。 指数阶0(2n)，显然，时间复杂度为指数阶0(2n)的算法效率极低，当n值稍大时就无法应用。（4）求时间复杂度【1】如果算法的执行时间不随着问题规模n的增加而增长，即使算法中有上千条语句，其执行时间也不过是一个较大的常数。此类算法的时间复杂度是O(1)。 x=91; y=100;while(y&gt;0) if(x&gt;100) {x=x-10;y–;} else x++; 解答： T(n)=O(1)，这个程序看起来有点吓人，总共循环运行了1100次，但是我们看到n没有?没。这段程序的运行是和n无关的，就算它再循环一万年，我们也不管他，只是一个常数阶的函数 【2】当有若干个循环语句时，算法的时间复杂度是由嵌套层数最多的循环语句中最内层语句的频度f(n)决定的。 x=1;for(i=1;i&lt;=n;i++) for(j=1;j&lt;=i;j++) for(k=1;k&lt;=j;k++) x++; 该程序段中频度最大的语句是(5)，内循环的执行次数虽然与问题规模n没有直接关系，但是却与外层循环的变量取值有关，而最外层循环的次数直接与n有关，因此可以从内层循环向外层分析语句(5)的执行次数： 则该程序段的时间复杂度为T(n)=O(n3/6+低次项)=O(n3) 【3】算法的时间复杂度不仅仅依赖于问题的规模，还与输入实例的初始状态有关。在数值A[0..n-1]中查找给定值K的算法大致如下： i=n-1;while(i&gt;=0&amp;&amp;(A[i]!=k)) i–;return i; 此算法中的语句(3)的频度不仅与问题规模n有关，还与输入实例中A的各元素取值及K的取值有关: ①若A中没有与K相等的元素，则语句(3)的频度f(n)=n； ②若A的最后一个元素等于K,则语句(3)的频度f(n)是常数0。（5）时间复杂度评价性能有两个算法A1和A2求解同一问题，时间复杂度分别是T1(n)=100n2，T2(n)=5n3。（1）当输入量n＜20时，有T1(n)＞T2(n)，后者花费的时间较少。（2）随着问题规模n的增大，两个算法的时间开销之比5n3/100n2=n/20亦随着增大。即当问题规模较大时，算法A1比算法A2要有效地多。它们的渐近时间复杂度O(n2)和O(n3)从宏观上评价了这两个算法在时间方面的质量。在算法分析时，往往对算法的时间复杂度和渐近时间复杂度不予区分，而经常是将渐近时间复杂度T(n)=O(f(n))简称为时间复杂度，其中的f(n)一般是算法中频度最大的语句频度。 2.空间复杂度一个程序的空间复杂度是指运行完一个程序所需内存的大小。利用程序的空间复杂度，可以对程序的运行所需要的内存多少有个预先估计。一个程序执行时除了需要存储空间和存储本身所使用的指令、常数、变量和输入数据外，还需要一些对数据进行操作的工作单元和存储一些为现实计算所需信息的辅助空间。程序执行时所需存储空间包括以下两部分。 （1）固定部分。这部分空间的大小与输入/输出的数据的个数多少、数值无关。主要包括指令空间（即代码空间）、数据空间（常量、简单变量）等所占的空间。这部分属于静态空间。（2）可变空间，这部分空间的主要包括动态分配的空间，以及递归栈所需的空间等。这部分的空间大小与算法有关。一个算法所需的存储空间用f(n)表示。S(n)=O(f(n)) 其中n为问题的规模，S(n)表示空间复杂度。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>时间复杂度</tag>
        <tag>空间复杂度</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2016年总结]]></title>
    <url>%2F2017%2F02%2F18%2F2016%E5%B9%B4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[在2016这一年 技术长进了。 Java:从SSH框架转到SSM，并且见识了基于Spring boot的威力，补了一下Java基础，正在接触算法。 Linux:记住了越来的越多的Linux命令，能独立维护并处理部分服务问题了。 Python:终于算是入门了，入门了却没看到出门在哪里。 JS&amp;HTML&amp;CSS3:这似乎不是我该关注的问题，能独立解决UI上的问题已经够了。 完成了至少三个项目，从pc端到web端到微信端到hybridApp。 项目是最好的导师，边学边做，边学边用，虽然不能用到最好，但这确实是很有效的学习途径，先实现再优化。 有毅力和活力，天生乐观派。认定了的事情一定要去完成，本职工作必须要做到尽职尽责。 不足： 发现的自己实力还是离自己的期望的差了很多。 纠结综合症。 强迫症。 展望2017！ 有想法 想法一：继续补课 实习大半年后，发现在大学期间没有好好学习Java基础，也没有学的特别扎实！很多东西自己还不知道，需要补课！现在也算是个半吊子的Java程序员，虽然看了一遍的Java核心技术，但是还是要继续巩固，不同阶段相信有不同的理解，以后还会买更多的书回来，继续学习。 想法二：学习框架和算法 完成了基本的基础学习，开始着手框架，从Spring开始学起，了解框架底层原理，并且模仿造几个轮子。 大学只掌握了一些基础的数据结构知识，想要进大企业，算法也不能落下，不过这种东西不是可以快速见到成效的，所以静下心，慢慢来！ 想法三：改 现在的写的代码用一个字形容——乱。 SVN没有发挥它该有的作用，SVN上的代码都不是最新的。 缺少一个完整的项目管理软件，BUG没有任何追踪记录，解决了？！没解决？！进度走到哪里了？！后续是关注还是下放到下一个版本解决？！项目的开发进度完成了吗？！ 有计划 计划一:读书计划。 读完至少6本技术书籍，以下为计划书单： 1.《Java核心技术 卷一》 再读 2.《Java核心技术 卷二》 也可选择《java编程思想》 3.《Effective Java》 4.《深入理解Java虚拟机：JVM高级特性与最佳实践》 5.《大型网站技术架构 核心原理与案例分析》 6.《Java并发编程的艺术》 7.《算法第四版》 计划二：工作计划 1.2017年，继续坚持现有的工作状态。 2.加强自己的业务代码能力。 3.接触新项目（不同领域）。 4.自己做点外包。 （完）]]></content>
      <categories>
        <category>程序人生</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jdk1.8的HashMap和ConcurrentHashMap]]></title>
    <url>%2F2017%2F02%2F18%2Fjdk1-8%E7%9A%84HashMap%E5%92%8CConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[本文针对jdk1.8的ConcurrentHashMap 1.8的HashMap设计 1.1 整体概览 HashMap采用的是数组+链表+红黑树的形式。 数组是可以扩容的，链表也是转化为红黑树的，这2种方式都可以承载更多的数据。 用户可以设置的参数：初始总容量默认16，默认的加载因子0.75 初始的数组个数默认是16（用户不能设置的） 容量X加载因子=阈值 一旦目前容量超过该阈值，则执行扩容操作。 什么时候扩容？ 当前容量超过阈值 当链表中元素个数超过默认设定（8个），当数组的大小还未超过64的时候，此时进行数组的扩容，如果超过则将链表转化成红黑树 什么时候链表转化为红黑树？（上面已经提到了） 当数组大小已经超过64并且链表中的元素个数超过默认设定（8个）时，将链表转化为红黑树 目前形象的表示数组中的一个元素称为一个桶 1.2 put过程 根据key计算出hash值 hash值&amp;（数组长度-1）得到所在数组的index 如果该index位置的Node元素不存在，则直接创建一个新的Node 如果该index位置的Node元素是TreeNode类型即红黑树类型了，则直接按照红黑树的插入方式进行插入 如果该index位置的Node元素是非TreeNode类型则，则按照链表的形式进行插入操作 链表插入操作完成后，判断是否超过阈值TREEIFY_THRESHOLD（默认是8），超过则要么数组扩容要么链表转化成红黑树 判断当前总容量是否超出阈值，如果超出则执行扩容 源码如下： 下面来说说这个扩容的过程 1.3 扩容过程 按照2倍扩容的方式，那么就需要将之前的所有元素全部重新按照2倍桶的长度重新计算所在桶。这里为啥是2倍？ 因为2倍的话，更加容易计算他们所在的桶，并且各自不会相互干扰。如原桶长度是4，现在桶长度是8，那么 桶0中的元素会被分到桶0和桶4中 桶1中的元素会被分到桶1和桶5中 桶2中的元素会被分到桶2和桶6中 桶3中的元素会被分到桶3和桶7中 为啥是这样呢？ 桶0中的元素的hash值后2位必然是00，这些hash值可以根据后3位000或者100分成2类数据。他们分别&amp;（8-1）即&amp;111,则后3位为000的在桶0中，后3位为100的必然在桶4中。其他同理，也就是说桶4和桶0重新瓜分了原来桶0中的元素。 如果换成其他倍数，那么瓜分就比较混乱了。 这样在瓜分这些数据的时候，只需要先把这些数据分类，如上述桶0中分成000和100 2类，然后直接构成新的链表，分类完毕后，直接将新的链表挂在对应的桶下即可，源码如下： 上述 (e.hash &amp; oldCap) == 0 即可将原桶中的数据分成2类 上述是对于链表情况下的重新移动，而针对红黑树情况下： 则需要考虑分类之后是否还需要依然保持红黑树，如果个数少则直接使用链表即可。 1.4 get过程 get过程比较简单 根据key计算出hash值 hash值&amp;（数组长度-1）得到所在数组的index 如果要找的key就是上述数组index位置的元素，直接返回该元素的值 如果该数组index位置元素是TreeNode类型，则按照红黑树的查询方式来进行查找 如果该数组index位置元素非TreeNode类型，则按照链表的方式来进行遍历查询 源码如下： 1.7的ConcurrentHashMap设计 ConcurrentHashMap是线程安全，通过分段锁的方式提高了并发度。分段是一开始就确定的了，后期不能再进行扩容的。 其中的段Segment继承了重入锁ReentrantLock，有了锁的功能，同时含有类似HashMap中的数组加链表结构（这里没有使用红黑树） 虽然Segment的个数是不能扩容的，但是单个Segment里面的数组是可以扩容的。 2.1 整体概览 ConcurrentHashMap有3个参数： initialCapacity：初始总容量，默认16 loadFactor：加载因子，默认0.75 concurrencyLevel：并发级别，默认16 然后我们需要知道的是： segment的个数即ssize 取大于等于并发级别的最小的2的幂次。如concurrencyLevel=16，那么sszie=16,如concurrencyLevel=10，那么ssize=16 单个segment的初始容量cap c=initialCapacity/ssize,并且可能需要+1。如15/7=2，那么c要取3，如16/8=2，那么c取2 c可能是一个任意值，那么同上述一样，cap取的值就是大于等于c的最下2的幂次。最小值要求是2 单个segment的阈值threshold cap*loadFactor 所以默认情况下，segment的个数sszie=16,每个segment的初始容量cap=2，单个segment的阈值threshold=1 2.2 put过程 首先根据key计算出一个hash值，找到对应的Segment 调用Segment的lock方法，为后面的put操作加锁 根据key计算出hash值，找到Segment中数组中对应index的链表，并将该数据放置到该链表中 判断当前Segment包含元素的数量大于阈值，则Segment进行扩容 整体代码逻辑见如下源码： 其中上述Segment的put过程源码如下： 2.3 扩容过程 这个扩容是在Segment的锁的保护下进行扩容的，不需要关注并发问题。 这里的重点就是： 首先找到一个lastRun，lastRun之后的元素和lastRun是在同一个桶中，所以后面的不需要进行变动。 然后对开始到lastRun部分的元素，重新计算下设置到newTable中，每次都是将当前元素作为newTable的首元素，之前老的链表作为该首元素的next部分。 2.4 get过程 根据key计算出对应的segment 再根据key计算出对应segment中数组的index 最终遍历上述index位置的链表，查找出对应的key的value 源码如下： 1.8的ConcurrentHashMap设计 1.8的ConcurrentHashMap摒弃了1.7的segment设计，而是在1.8HashMap的基础上实现了线程安全的版本，即也是采用数组+链表+红黑树的形式。 数组可以扩容，链表可以转化为红黑树 3.1 整体概览 有一个重要的参数sizeCtl，代表数组的大小（但是还有其他取值及其含义，后面再详细说到） 用户可以设置一个初始容量initialCapacity给ConcurrentHashMap sizeCtl=大于（1.5倍initialCapacity+1）的最小的2的幂次。 即initialCapacity=20，则sizeCtl=32,如initialCapacity=24，则sizeCtl=64。 初始化的时候，会按照sizeCtl的大小创建出对应大小的数组 3.2 put过程 源码如下所示： 如果数组还未初始化，那么进行初始化，这里会通过一个CAS操作将sizeCtl设置为-1，设置成功的，可以进行初始化操作 根据key的hash值找到对应的桶，如果桶还不存在，那么通过一个CAS操作来设置桶的第一个元素，失败的继续执行下面的逻辑即向桶中插入或更新 如果找到的桶存在，但是桶中第一个元素的hash值是-1，说明此时该桶正在进行迁移操作，这一块会在下面的扩容中详细谈及。 如果找到的桶存在，那么要么是链表结构要么是红黑树结构，此时需要获取该桶的锁，在锁定的情况下执行链表或者红黑树的插入或更新 如果桶中第一个元素的hash值大于0，说明是链表结构，则对链表插入或者更新 如果桶中的第一个元素类型是TreeBin，说明是红黑树结构，则按照红黑树的方式进行插入或者更新 在锁的保护下插入或者更新完毕后，如果是链表结构，需要判断链表中元素的数量是否超过8（默认），一旦超过就要考虑进行数组扩容或者是链表转红黑树 下面就来重点看看这个扩容过程 3.3 扩容过程 一旦链表中的元素个数超过了8个，那么可以执行数组扩容或者链表转为红黑树，这里依据的策略跟HashMap依据的策略是一致的。 当数组长度还未达到64个时，优先数组的扩容，否则选择链表转为红黑树。 源码如下所示： 重点来看看这个扩容过程，即看下上述tryPresize方法，也可以看到上述是2倍扩容的方式 第一个执行的线程会首先设置sizeCtl属性为一个负值，然后执行transfer(tab, null)，其他晚进来的线程会检查当前扩容是否已经完成，没完成则帮助进行扩容，完成了则直接退出。 该ConcurrentHashMap的扩容操作可以允许多个线程并发执行，那么就要处理好任务的分配工作。每个线程获取一部分桶的迁移任务，如果当前线程的任务完成，查看是否还有未迁移的桶，若有则继续领取任务执行，若没有则退出。在退出时需要检查是否还有其他线程在参与迁移工作，如果有则自己什么也不做直接退出，如果没有了则执行最终的收尾工作。 问题1：当前线程如何感知其他线程也在参与迁移工作？ 靠sizeCtl的值，它初始值是一个负值=(rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)，每当一个线程参与进来执行迁移工作，则该值进行CAS自增，该线程的任务执行完毕要退出时对该值进行CAS自减操作，所以当sizeCtl的值等于上述初值则说明了此时未有其他线程还在执行迁移工作，可以去执行收尾工作了。见如下代码 问题2：任务按照何规则进行分片？ 上述stride即是每个分片的大小，目前有最低要求16，即每个分片至少需要16个桶。stride的计算依赖于CPU的核数，如果只有1个核，那么此时就不用分片，即stride=n。其他情况就是 (n &gt;&gt;&gt; 3) / NCPU。 问题3：如何记录目前已经分出去的任务？ ConcurrentHashMap含有一个属性transferIndex（初值为最后一个桶），表示从transferIndex开始到后面所有的桶的迁移任务已经被分配出去了。所以每次线程领取扩容任务，则需要对该属性进行CAS的减操作，即一般是transferIndex-stride。 问题4：每个线程如何处理分到的部分桶的迁移工作 第一个获取到分片的线程会创建一个新的数组，容量是之前的2倍。 遍历自己所分到的桶： 桶中元素不存在，则通过CAS操作设置桶中第一个元素为ForwardingNode，其Hash值为MOVED（-1）,同时该元素含有新的数组引用 此时若其他线程进行put操作，发现第一个元素的hash值为-1则代表正在进行扩容操作（并且表明该桶已经完成扩容操作了，可以直接在新的数组中重新进行hash和插入操作），该线程就可以去参与进去，或者没有任务则不用参与，此时可以去直接操作新的数组了 桶中元素存在且hash值为-1，则说明该桶已经被处理了（本不会出现多个线程任务重叠的情况，这里主要是该线程在执行完所有的任务后会再次进行检查，再次核对） 桶中为链表或者红黑树结构，则需要获取桶锁，防止其他线程对该桶进行put操作，然后处理方式同HashMap的处理方式一样，对桶中元素分为2类，分别代表当前桶中和要迁移到新桶中的元素。设置完毕后代表桶迁移工作已经完成，旧数组中该桶可以设置成ForwardingNode了 下面来看下详细的代码： 3.4 get过程 根据k计算出hash值，找到对应的数组index 如果该index位置无元素则直接返回null 如果该index位置有元素 如果第一个元素的hash值小于0，则该节点可能为ForwardingNode或者红黑树节点TreeBin 如果是ForwardingNode（表示当前正在进行扩容），使用新的数组来进行查找 如果是红黑树节点TreeBin，使用红黑树的查找方式来进行查找 如果第一个元素的hash大于等于0，则为链表结构，依次遍历即可找到对应的元素 详细代码如下 至此，ConcurrentHashMap主要的操作都粗略的介绍完毕了，其他一些操作靠各位自行去看了。 下面针对一些问题来进行解答 问题分析 4.1 ConcurrentHashMap读为什么不需要锁？ 我们通常使用读写锁来保护对一堆数据的读写操作。读时加读锁，写时加写锁。在什么样的情况下可以不需要读锁呢？ 如果对数据的读写是一个原子操作，那么此时是可以不需要读锁的。如ConcurrentHashMap对数据的读写，写操作是不需要分2次写的（没有中间状态），读操作也是不需要2次读取的。假如一个写操作需要分多次写，必然会有中间状态，如果读不加锁，那么可能就会读到中间状态，那就不对了。 假如ConcurrentHashMap提供put(key1,value1,key2,value2)，写入的时候必然会存在中间状态即key1写完成，但是key2还未写，此时如果读不加锁，那么就可能读到key1是新数据而key2是老数据的中间状态。 虽然ConcurrentHashMap的读不需要锁，但是需要保证能读到最新数据，所以必须加volatile。即数组的引用需要加volatile，同时一个Node节点中的val和next属性也必须要加volatile。 4.2 ConcurrentHashMap是否可以在无锁的情况下进行迁移？ 目前1.8的ConcurrentHashMap迁移是在锁定旧桶的前提下进行迁移的，然而并没有去锁定新桶。那么就可能提出如下问题： 在某个桶的迁移过程中，别的线程想要对该桶进行put操作怎么办？ 一旦某个桶在迁移过程中了，必然要获取该桶的锁，所以其他线程的put操作要被阻塞，一旦迁移完毕，该桶中第一个元素就会被设置成ForwardingNode节点，所以其他线程put时需要重新判断下桶中第一个元素是否被更改了，如果被改了重新获取重新执行逻辑，如下代码 某个桶已经迁移完成（其他桶还未完成），别的线程想要对该桶进行put操作怎么办？ 该线程会首先检查是否还有未分配的迁移任务，如果有则先去执行迁移任务，如果没有即全部任务已经分发出去了，那么此时该线程可以直接对新的桶进行插入操作（映射到的新桶必然已经完成了迁移，所以可以放心执行操作） 从上面看到我们在迁移的时候还是需要对旧桶锁定的，能否在无锁的情况下实现迁移？ 可以参考参考这篇论文Split-Ordered Lists: Lock-Free Extensible Hash Tables 一旦扩容就涉及到迁移桶中元素的操作，将一个桶中的元素迁移到另一个桶中的操作不是一个原子操作，所以需要在锁的保护下进行迁移。如果扩容操作是移动桶的指向，那么就可以通过一个CAS操作来完成扩容操作。上述Split-Ordered Lists就是把所有元素按照一定的顺序进行排列。该list被分成一段一段的，每一段都代表某个桶中的所有元素。每个桶中都有一个指向第一个元素的指针，如下图结构所示： 每一段其实也是分成2类的，如同前面所说的HashMap在扩容是分成2类的情况是一样的，此时Split-Ordered Lists在扩容时就只需要将新桶的指针指向这2类的分界点即可。 这一块之后再详细说明吧。 4.3 ConcurrentHashMap曾经的弱一致性 具体详见这篇针对老版本的ConcurrentHashMap的说明文章为什么ConcurrentHashMap是弱一致的 文中已经解释到：对数组的引用是volatile来修饰的，但是数组中的元素并不是。即读取数组的引用总是能读取到最新的值，但是读取数组中某一个元素的时候并不一定能读到最新的值。所以说是弱一致性的。 我觉得这个只需要稍微改动下就可以实现强一致性： 对于新加的key，通过写入到链表的末尾即可。因为一个元素的next属性是volatile的，可以保证写入后立马看的到，如下1.8的方式 或者对数组中元素的更新采用volatile写的方式，如下1.7的形式 但是现在1.7版本的ConcurrentHashMap对于数组中元素的写也是加了volatile的，如下代码 1.8的方式就是：直接将新加入的元素写入next属性（含有volatile修饰）中而不是修改桶中的第一个元素。 所以在1.7和1.8版本的ConcurrentHashMap中不再是弱一致性，写入的数据是可以立马本读到的。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cordova中与inBrowser的通讯]]></title>
    <url>%2F2017%2F02%2F18%2FBrowser%E7%9A%84%E9%80%9A%E8%AE%AF%E2%80%9D%2F</url>
    <content type="text"><![CDATA[为了把我的练琴记录仪改成多用户App，我需要做一个Weibo OAuth功能，因为练琴记录仪是Single Page App，我不愿意直接跳转到OAuth页面，那样会打断我的应用状态，于是我打算打开一个新窗口来完成OAuth。 这样一来，问题自然就转换为跨窗口通讯问题了。窗口间通讯毫无疑问首选是 window.postMessage ，在cordova当中，原生 window.open 是不能用的，官方给的方案是使用 cordova-plugin-inappbrowser 插件所提供的 cordova.InAppBrowser.open(url, target, options) 来取代 window.open ，这两者基本上API差不多一致。 但是IAB插件所返回的对象并不是真正的 window ，它没有 postMessage 功能，并且在IAB所打开的页面中，也没有 window.opener ，于是只能另辟蹊径，找点不靠谱的挫方法来试试了。 OAuth基本流程 OAuth的基本流程这里就不赘述了，简单描述一下 Client需要授权，把自己（由服务商分配的） client_id ——也称 app key 以及在服务商注册的 redirect_url 拼在一起，让用户去访问服务商的 authorize 地址。服务商会询问用户是否对这个 client_id 授权自己的账号，如果是，会跳转到 redirect_url?code=xxxxxx 。应用的服务端接收到 redirect_url 的访问，用URL参数中的 code 和自己的 client_id 以及 app secret （相当于密码）去请求服务商的 access_token 接口，得到 access_token ，这个就是此应用对于这个用户账号的访问凭条。redirect_url 页面根据应用自身需要把获得的 access_token 传回应用，完成授权过程。使用 window.open 时的流程 客户端 var win = window.open(oauth_url) 。完成OAuth授权，跳转到 redirect_url 。在 redirect_url 上，把 access_token 用 window.opener.postMessage 的方式发给应用。应用监听 win 的 onmessage 事件，一旦收到了 access_token 就完成授权，可以 win.close() 了。然后我先把它写成了一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344function crossWindowViaBrowser(url, target, opts, key, timeout) &#123; let defer = Promise.defer() let resolve = defer.resolve.bind(defer) let reject = defer.reject.bind(defer) let promise = defer.promise let timing let win = window.open(url, target, utils.buildOpenWindowOptions(opts)) let onMessage = e =&gt; &#123; let data = e.data || &#123;&#125; if (data.type === 'cross-window' &amp;&amp; data.key === key) &#123; parseResult(data.result, resolve, reject) &#125; &#125; // close（貌似）没有可用的事件，`win.addEventListener('close')`没用的样子 // `win.addEventListener`不好用的问题也可能是因为跨域，真是蛋疼啊 // 于是轮询`closed`属性吧 let pollingClosed = setInterval(() =&gt; &#123; if (win.closed) &#123; reject(new Error(ErrorType.CANCELED)) &#125; &#125;, POLLING_INTERVAL) window.addEventListener('message', onMessage, false) // 超时`reject` if (timeout &gt; 0) &#123; timing = setTimeout(() =&gt; &#123; reject(new Error(ErrorType.TIMEOUT)) &#125;, timeout) &#125; promise.finally(() =&gt; &#123; // clean up clearInterval(pollingClosed) clearTimeout(timing) window.removeEventListener('message', onMessage) win.close() &#125;) return promise&#125; 使用 cordova.InAppBrowser.open 时的流程 客户端 var win = cordova.InAppBrowser.open(oauth_url) 。客户端开始对 win.executeScript 并进行轮询，其内容是尝试读取 localStorage.getItem(key) 。redirect_url 页面把获取到的 access_token 写到 localStorage.setItem(key, access_token) 。客户端一旦轮询到 localStorage.getItem(key) 有值，就可以得到 access_token ，然后就可以 localStorage.removeItem(key) ，完成授权， win.close() 。然后我也单独写了一个函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253function crossWindowViaCordovaIAB(url, target, opts, key, timeout) &#123; let defer = Promise.defer() let resolve = defer.resolve.bind(defer) let reject = defer.reject.bind(defer) let promise = defer.promise let timing let win = cordova.InAppBrowser.open(url, target, utils.buildOpenWindowOptions(opts)) // cordova的InAppBrowser没有window.opener对象，只能使用轮询罢。。 const code = `(function() &#123; var key = '$&#123;key&#125;' var data = localStorage.getItem(key) if (data !== null) &#123; localStorage.removeItem(key) return data &#125; return false &#125;)()` let poll = () =&gt; &#123; win.executeScript(&#123; code: code &#125;, ret =&gt; &#123; if (ret[0] === false) &#123; // 等待 &#125; else &#123; clearInterval(pollingData) parseResult(ret[0], resolve, reject) &#125; &#125;) &#125; let pollingData = setInterval(poll, POLLING_INTERVAL) // 窗口关闭时`reject` // 正常流程上面`resolve`后才会`win.close()`，所以这里再`reject`也不会有影响 win.addEventListener('exit', e =&gt; &#123; reject(new Error(ErrorType.CANCELED)) &#125;) // 超时`reject` if (timeout &gt; 0) &#123; timing = setTimeout(() =&gt; &#123; reject(new Error(ErrorType.TIMEOUT)) &#125;, timeout) &#125; promise.finally(() =&gt; &#123; // clean up clearInterval(pollingData) clearTimeout(timing) win.close() &#125;) return promise&#125; 整合 1234567function crossWindow(...args) &#123; if (window.cordova !== undefined &amp;&amp; cordova.InAppBrowser !== undefined) &#123; return crossWindowViaCordovaIAB(...args) &#125; else &#123; return crossWindowViaBrowser(...args) &#125;&#125; 服务端 服务端的Redirect Page我是用PHP写的，涉及到上面的 cross-browser 的部分大概是： 12345678910111213141516&lt;script&gt;window.onload = function() &#123; var key = &lt;?= json_encode($key) ?&gt; var result = &lt;?= json_encode($output) ?&gt; localStorage.setItem(key, result) if (window.opener) &#123; window.opener.postMessage(&#123; type: 'cross-window', key: key, result: result &#125;, '*') &#125;&#125;&lt;/script&gt; 其中 $output 是对 access_token 接口 curl 得到的返回值，虽然微博给的返回值理论上说都是合法的JSON，但出于通用考虑我还是直接把它当字符串传递，让客户端自己在 parse 的时候进行 try/catch ，而且这样对 localStorage 也比较直接。]]></content>
      <categories>
        <category>移动开发</category>
      </categories>
      <tags>
        <tag>Cordova</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级for循环使用remove/add 问题]]></title>
    <url>%2F2017%2F02%2F18%2F%E9%AB%98%E7%BA%A7for%E5%BE%AA%E7%8E%AF%E4%BD%BF%E7%94%A8remove-add-%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[今天在高级for循环中用了一下remove发现报错，写了个demo测试看：1234567 List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add("1"); a.add("2"); for (String temp : a) &#123; if("1".equals(temp))&#123; a.remove(temp);&#125; &#125; 此时代码是没有问题的，运行正常；但是把”1”.equals(temp)换成”2”.equals(temp)之后，问题就出来了！ 123456789Exception in thread "main" java.util.ConcurrentModificationException at java.util.ArrayList$Itr.checkForComodification(ArrayList.java:901) at java.util.ArrayList$Itr.next(ArrayList.java:851) at main.exam.ForeachTest.main(ForeachTest.java:15) at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) at java.lang.reflect.Method.invoke(Method.java:497) at com.intellij.rt.execution.application.AppMain.main(AppMain.java:147) 报了这么一堆异常。 自己想了想画了个图： 看图就明白了，该list每当删除一个元素时，集合的size方法的值都会减小1,这将直接导致集合中元素的索引重新排序，进一步说，就是剩余所有元素的索引值都减1，正如上图所示，而for循环语句的局部变量i仍然在递增，这将导致删除操作发生跳跃。从而导致上述代码还有删除的问题。 所以不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。如下： 12345Iterator&lt;String&gt; it = a.iterator(); while(it.hasNext())&#123;String temp = it.next(); if(删除元素的条件)&#123; it.remove(); &#125;&#125;]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap面试题总结！]]></title>
    <url>%2F2017%2F02%2F18%2FHashMap%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93%EF%BC%81%2F</url>
    <content type="text"><![CDATA[HashTable和HashMap的区别有哪些？ HashMap和Hashtable都实现了Map接口，但决定用哪一个之前先要弄清楚它们之间的分别。主要的区别有：线程安全性，同步(synchronization)，以及速度。 理解HashMap是Hashtable的轻量级实现（非线程安全的实现，hashtable是非轻量级，线程安全的），都实现Map接口，主要区别在于：1、由于HashMap非线程安全，在只有一个线程访问的情况下，效率要高于HashTable 2、HashMap允许将null作为一个entry的key或者value，而Hashtable不允许。 3、HashMap把Hashtable的contains方法去掉了，改成containsValue和containsKey。因为contains方法容易让人引起误解。 4、Hashtable继承自陈旧的Dictionary类，而HashMap是Java1.2引进的Map 的一个实现。 5、Hashtable和HashMap扩容的方法不一样，HashTable中hash数组默认大小11，扩容方式是 old*2+1。HashMap中hash数组的默认大小是16，而且一定是2的指数，增加为原来的2倍，没有加1。 6、两者通过hash值散列到hash表的算法不一样，HashTbale是古老的除留余数法，直接使用hashcode，而后者是强制容量为2的幂，重新根据hashcode计算hash值，在使用hash 位与 （hash表长度 – 1），也等价取膜，但更加高效，取得的位置更加分散，偶数，奇数保证了都会分散到。前者就不能保证。 7、另一个区别是HashMap的迭代器(Iterator)是fail-fast迭代器，而Hashtable的enumerator迭代器不是fail-fast的。所以当有其它线程改变了HashMap的结构（增加或者移除元素），将会抛出ConcurrentModificationException，但迭代器本身的remove()方法移除元素则不会抛出ConcurrentModificationException异常。但这并不是一个一定发生的行为，要看JVM。这条同样也是Enumeration和Iterator的区别。 fail-fast和iterator迭代器相关。如果某个集合对象创建了Iterator或者ListIterator，然后其它的线程试图“结构上”更改集合对象，将会抛出ConcurrentModificationException异常。但其它线程可以通过set()方法更改集合对象是允许的，因为这并没有从“结构上”更改集合。但是假如已经从结构上进行了更改，再调用set()方法，将会抛出IllegalArgumentException异常。 结构上的更改指的是删除或者插入一个元素，这样会影响到map的结构。 该条说白了就是在使用迭代器的过程中有其他线程在结构上修改了map，那么将抛出ConcurrentModificationException，这就是所谓fail-fast策略。为什么HashMap是线程不安全的，实际会如何体现？ 第一，如果多个线程同时使用put方法添加元素 假设正好存在两个put的key发生了碰撞(hash值一样)，那么根据HashMap的实现，这两个key会添加到数组的同一个位置，这样最终就会发生其中一个线程的put的数据被覆盖。 第二，如果多个线程同时检测到元素个数超过数组大小*loadFactor 这样会发生多个线程同时对hash数组进行扩容，都在重新计算元素位置以及复制数据，但是最终只有一个线程扩容后的数组会赋给table，也就是说其他线程的都会丢失，并且各自线程put的数据也丢失。且会引起死循环的错误。 具体细节上的原因，可以参考：不正当使用HashMap导致cpu 100%的问题追究 能否让HashMap实现线程安全，如何做？ 1、直接使用Hashtable，但是当一个线程访问HashTable的同步方法时，其他线程如果也要访问同步方法，会被阻塞住。举个例子，当一个线程使用put方法时，另一个线程不但不可以使用put方法，连get方法都不可以，效率很低，现在基本不会选择它了。 2、HashMap可以通过下面的语句进行同步： 1Collections.synchronizeMap(hashMap); 3、直接使用JDK 5 之后的 ConcurrentHashMap，如果使用Java 5或以上的话，请使用ConcurrentHashMap。 Collections.synchronizeMap(hashMap);又是如何保证了HashMap线程安全？ 直接分析源码吧 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// synchronizedMap方法public static &lt;K,V&gt; Map&lt;K,V&gt; synchronizedMap(Map&lt;K,V&gt; m) &#123; return new SynchronizedMap&lt;&gt;(m); &#125;// SynchronizedMap类private static class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 1978198479659022715L; private final Map&lt;K,V&gt; m; // Backing Map final Object mutex; // Object on which to synchronize SynchronizedMap(Map&lt;K,V&gt; m) &#123; this.m = Objects.requireNonNull(m); mutex = this; &#125; SynchronizedMap(Map&lt;K,V&gt; m, Object mutex) &#123; this.m = m; this.mutex = mutex; &#125; public int size() &#123; synchronized (mutex) &#123;return m.size();&#125; &#125; public boolean isEmpty() &#123; synchronized (mutex) &#123;return m.isEmpty();&#125; &#125; public boolean containsKey(Object key) &#123; synchronized (mutex) &#123;return m.containsKey(key);&#125; &#125; public boolean containsValue(Object value) &#123; synchronized (mutex) &#123;return m.containsValue(value);&#125; &#125; public V get(Object key) &#123; synchronized (mutex) &#123;return m.get(key);&#125; &#125; public V put(K key, V value) &#123; synchronized (mutex) &#123;return m.put(key, value);&#125; &#125; public V remove(Object key) &#123; synchronized (mutex) &#123;return m.remove(key);&#125; &#125; // 省略其他方法 &#125; 从源码中看出 synchronizedMap()方法返回一个SynchronizedMap类的对象，而在SynchronizedMap类中使用了synchronized来保证对Map的操作是线程安全的，故效率其实也不高。 为什么HashTable的默认大小和HashMap不一样？ 前面分析了，Hashtable 的扩容方法是乘2再+1，不是简单的乘2，故hashtable保证了容量永远是奇数，结合之前分析hashmap的重算hash值的逻辑，就明白了，因为在数据分布在等差数据集合(如偶数)上时，如果公差与桶容量有公约数 n，则至少有(n-1)/n 数量的桶是利用不到的，故之前的hashmap 会在取模（使用位与运算代替）哈希前先做一次哈希运算，调整hash值。这里hashtable比较古老，直接使用了除留余数法，那么就需要设置容量起码不是偶数（除（近似）质数求余的分散效果好）。而JDK开发者选了11。 感觉针对Java的hashmap和hashtable面试，或者理解，到这里就可以了，具体就是多写代码实践。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈HashMap]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%B5%85%E8%B0%88HashMap%2F</url>
    <content type="text"><![CDATA[什么是Map? Map用于保存具有key-value映射关系的数据首先看图！可以看出Java 中有四种常见的Map实现——HashMap, TreeMap, Hashtable和LinkedHashMap：·HashMap就是一张hash表，键和值都没有排序。·TreeMap以红黑树结构为基础，键值可以设置按某种顺序排列。·LinkedHashMap保存了插入时的顺序。·Hashtable是同步的(而HashMap是不同步的)。所以如果在线程安全的环境下应该多使用HashMap，而不是Hashtable，因为Hashtable对同步有额外的开销。我们在这里简单的说说HashMap：(1)HashMap是基于哈希表实现的，每一个元素是一个key-value对，其内部通过单链表解决冲突问题，容量不足（超过了阀值）时，同样会自动增长。(2)HashMap是非线程安全的，只用于单线程环境下，多线程环境下可以采用concurrent并发包下的concurrentHashMap。(3)HashMap 实现了Serializable接口，因此它支持序列化。(4)HashMap还实现了Cloneable接口，故能被克隆。先从HashMap的存储结构说起：蓝色部分即代表哈希表本身（其实是一个数组），数组的每个元素都是一个单链表的头节点，链表是用来解决hash地址冲突的，如果不同的key映射到了数组的同一位置处，就将其放入单链表中保存。HashMap的构造方法中有两个很重要的参数：初始容量和加载因子 这两个参数是影响HashMap性能的重要参数，其中容量表示哈希表中槽的数量（即哈希数组的长度），初始容量是创建哈希表时的容量（默认为16），加载因子是哈希表当前key的数量和容量的比值，当哈希表中的条目数超出了加载因子与当前容量的乘积时，则要对该哈希表提前进行 resize 操作（即扩容）。如果加载因子越大，对空间的利用更充分，但是查找效率会降低（链表长度会越来越长）；如果加载因子太小，那么表中的数据将过于稀疏（很多空间还没用，就开始扩容了），严重浪费。 JDK开发者规定的默认加载因子为0.75，因为这是一个比较理想的值。另外，无论指定初始容量为多少，构造方法都会将实际容量设为不小于指定容量的2的幂次方，且最大值不能超过2的30次方。 我们来分析一下HashMap中用的最多的两个方法put和get的源码 get()： 12345678910111213141516171819202122232425// 获取key对应的value public V get(Object key) &#123; if (key == null) return getForNullKey(); // 获取key的hash值 int hash = hash(key.hashCode()); // 在“该hash值对应的链表”上查找“键值等于key”的元素 for (Entry&lt;K, V&gt; e = table[indexFor(hash, table.length)]; e != null; e = e.next) &#123; Object k; // 判断key是否相同 if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) return e.value; &#125; // 没找到则返回null return null; &#125; // 获取“key为null”的元素的值，HashMap将“key为null”的元素存储在table[0]位置，但不一定是该链表的第一个位置！ private V getForNullKey() &#123; for (Entry&lt;K, V&gt; e = table[0]; e != null; e = e.next) &#123; if (e.key == null) return e.value; &#125; return null; &#125; 首先，如果key为null，则直接从哈希表的第一个位置table[0]对应的链表上查找。记住，key为null的键值对永远都放在以table[0]为头结点的链表中，当然不一定是存放在头结点table[0]中。如果key不为null，则先求的key的hash值，根据hash值找到在table中的索引，在该索引对应的单链表中查找是否有键值对的key与目标key相等，有就返回对应的value，没有则返回null。 put()： 12345678910111213141516171819202122232425// 将“key-value”添加到HashMap中 public V put(K key, V value) &#123; // 若“key为null”，则将该键值对添加到table[0]中。 if (key == null) return putForNullKey(value); // 若“key不为null”，则计算该key的哈希值，然后将其添加到该哈希值对应的链表中。 int hash = hash(key.hashCode()); int i = indexFor(hash, table.length); for (Entry&lt;K, V&gt; e = table[i]; e != null; e = e.next) &#123; Object k; // 若“该key”对应的键值对已经存在，则用新的value取代旧的value。然后退出！ if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; V oldValue = e.value; e.value = value; e.recordAccess(this); return oldValue; &#125; &#125; // 若“该key”对应的键值对不存在，则将“key-value”添加到table中 modCount++; // 将key-value添加到table[i]处 addEntry(hash, key, value, i); return null; &#125; 如果key为null，则将其添加到table[0]对应的链表中，如果key不为null，则同样先求出key的hash值，根据hash值得出在table中的索引，而后遍历对应的单链表，如果单链表中存在与目标key相等的键值对，则将新的value覆盖旧的value，且将旧的value返回，如果找不到与目标key相等的键值对，或者该单链表为空，则将该键值对插入到单链表的头结点位置（每次新插入的节点都是放在头结点的位置），该操作是有addEntry方法实现的，它的源码如下： 1234567891011// 新增Entry。将“key-value”插入指定位置，bucketIndex是位置索引。 void addEntry(int hash, K key, V value, int bucketIndex) &#123; // 保存“bucketIndex”位置的值到“e”中 Entry&lt;K, V&gt; e = table[bucketIndex]; // 设置“bucketIndex”位置的元素为“新Entry”， // 设置“e”为“新Entry的下一个节点” table[bucketIndex] = new Entry&lt;K, V&gt;(hash, key, value, e); // 若HashMap的实际大小 不小于 “阈值”，则调整HashMap的大小 if (size++ &gt;= threshold) resize(2 * table.length); &#125; 注意这里倒数第三行的构造方法，将key-value键值对赋给table[bucketIndex]，并将其next指向元素e，这便将key-value放到了头结点中，并将之前的头结点接在了它的后面。该方法也说明，每次put键值对的时候，总是将新的该键值对放在table[bucketIndex]处（即头结点处）。两外注意最后两行代码，每次加入键值对时，都要判断当前已用的槽的数目是否大于等于阀值（容量*加载因子），如果大于等于，则进行扩容，将容量扩为原来容量的2倍。 接下来重点来分析下求hash值和索引值的方法，这两个方法便是HashMap设计的最为核心的部分，二者结合能保证哈希表中的元素尽可能均匀地散列。 由hash值找到对应索引的方法如下： 123static int indexFor(int h, int length) &#123; return h &amp; (length-1); &#125; 因为容量初始还是设定都会转化为2的幂次。故可以使用高效的位与运算替代模运算。 计算hash值的方法如下: 1234static int hash(int h) &#123; h ^= (h &gt;&gt;&gt; 20) ^ (h &gt;&gt;&gt; 12); return h ^ (h &gt;&gt;&gt; 7) ^ (h &gt;&gt;&gt; 4); &#125; JDK 的 HashMap 使用了一个 hash 方法对hash值使用位的操作，使hash值的计算效率很高。为什么这样做？主要是因为如果直接使用hashcode值，那么这是一个int值（8个16进制数，共32位），int值的范围正负21亿多，但是hash表没有那么长，一般比如初始16，自然散列地址需要对hash表长度取模运算，得到的余数才是地址下标。假设某个key的hashcode是0AAA0000，hash数组长默认16，如果不经过hash函数处理，该键值对会被存放在hash数组中下标为0处，因为0AAA0000 &amp; (16-1) = 0。过了一会儿又存储另外一个键值对，其key的hashcode是0BBB0000，得到数组下标依然是0，这就说明这是个实现得很差的hash算法，因为hashcode的1位全集中在前16位了，导致算出来的数组下标一直是0。于是明明key相差很大的键值对，却存放在了同一个链表里，导致以后查询起来比较慢（蜕化为了顺序查找）。故JDK的设计者使用hash函数的若干次的移位、异或操作，把hashcode的“1位”变得“松散”，非常巧妙。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx 基本入门(至今为止见过最好的 nginx 入门文章，没有之一。)]]></title>
    <url>%2F2017%2F02%2F18%2Fnginx-%E5%9F%BA%E6%9C%AC%E5%85%A5%E9%97%A8-%E8%87%B3%E4%BB%8A%E4%B8%BA%E6%AD%A2%E8%A7%81%E8%BF%87%E6%9C%80%E5%A5%BD%E7%9A%84-nginx-%E5%85%A5%E9%97%A8%E6%96%87%E7%AB%A0%EF%BC%8C%E6%B2%A1%E6%9C%89%E4%B9%8B%E4%B8%80%E3%80%82%2F</url>
    <content type="text"><![CDATA[本文转自StuQ 这篇教程简单介绍了 nginx 并且讲解了一些 nginx 可以解决的简单任务。这里，我们假设 nginx 已经安装在读者的机器上。如果没有，可以看一下如何安装 nginx。这篇教程主要讲解的是如果启用和停止 ngixn，和重新加载配置，描述配置文件的基本结构和怎样搭建一个 nginx 静态辅助器，怎样配置 nginx 作为一个代理服务器来。 nginx 有一个主进程和其他子进程。主进程的主要工作是加载和执行配置文件，并且驻留子进程。子进程用来作为实际的请求处理。nginx 采取基于事件的模型和 OS 依赖的机制，在多个子进程之间高效的分配请求。子进程的个数会直接写在配置文件中并且，对于给定的配置可以是固定的，或者根据可用的 CPU 核数自动的进行调整（参考子进程）。 nginx 和它模块的工作方式是在配置文件中写好的。默认情况下，这个配置文件通常命名为 nginx.conf 并且会放置在 /usr/local/nginx/conf，/etc/nginx，或者 /usr/local/etc/nginx。启用，停止和重载配置 运行可执行文件就可以开启 nginx，比如: 123// -c 为 nginx 的配置文件nginx -c/usr/local/nginx/conf/nginx.conf 如果，nginx 已经开启，那么它就可以通过使用 -s 参数的可执行命令控制。使用下列格式： 1nginx -s signal signal 可以为下列命令之一： stop — 直接关闭 nginx quit — 会在处理完当前正在的请求后退出，也叫优雅关闭 reload — 重新加载配置文件，相当于重启 reopen — 重新打开日志文件 比如，等待当前子进程处理完正在执行的请求后，结束 nginx 进程，可以使用下列命令： 1nginx -s quit 执行该命令的用户需要和启动的 nginx 的用户一致。 如果重载配置文件的命令没有传递给 nginx 或者 nginx 没有重启，那么配置文件的改动是不会被使用的。重载配置文件的命令可以使用： 1nginx -s reload 一旦主进程接收到重载配置文件的命令后，它会先检查配置文件语法的合法性，如果没有错误，则会重新加载配置文件。如果成功，则主进程会重新创建一个子进程并且发送关闭请求给以前的子进程。如果没有成功，主进程会回滚改动并且继续使用以前的配置。老的子进程在接受关闭的命令后，会停止接受新的请求并且继续处理当前的请求，直到处理完毕。之后，该子进程就直接退出了。 在 Unix 工具的帮助下，比如使用 kill 工具，该信号会被发送给 nginx 进程。在这种情况下，信号会被直接发送给带有进程 ID 的进程。nginx 的主进程的进程 ID 是写死在 nginx.pid 文件中的。该文件通常放在 /usr/local/nginx/logs 或者 /var/run 目录下。比如，如果主进程的 ID 是 1628，为了发送 QUIT 信号来使 nginx 优雅退出，可以执行：kill -s QUIT 1628 为了得到所有正在运行的 nginx 进程，我们可能会使用到 ps 工具，比如，像下列的方式： 123456789$ ps -ax | grep nginx// 结果为：（下面是单核 CPU 的情况） 516 pts/0 D+ 0:00 grep --color=auto nginx 1156 ? S 1:22 nginx: worker process27999 ? Ss 0:00 nginx: master process ./nginx 更多关于发送信号给 nginx，可以参考nginx 控制。配置文件结构 nginx 是由一些模块组成，我们一般在配置文件中使用一些具体的指令来控制它们。指令被分为简单指令和块级命令。一个简单的指令是由名字和参数组成，中间用空格分开，并以分号结尾。例如： 123// 简单指令root /data/www; 块级指令和简单指令一样有着类似的结构，但是末尾不是分号而是用 {和} 大括号包裹的额外指令集。如果一个块级指令的大括号里有其他指令，则它被叫做一个上下文（比如：events，Module ngx_http_core_module，server，和location）。 在配置文件中，没有放在任何上下文中的指令都是处在主上下文中。events 和 http 的指令是放在主上下文中，server 放在 http 中, location 放在 server 中。 以 # 开头的行，会被当做注释。 1234567891011121314151617181920212223242526272829# this is a commentevents &#123; worker_connections 4096; ## Default: 1024&#125;http &#123; server &#123; listen 80; server_name domain1.com www.domain1.com; access_log logs/domain1.access.log main; root html; location ~ \.php$ &#123; fastcgi_pass 127.0.0.1:1025; &#125; &#125;&#125; 静态服务器 一个重要的网络服务器的任务是处理文件（比如图片或者静态 HTML 文件）。这里，你会实践一个例子，文件会从不同的目录中映射（取决于请求）：/data/www（放置 HTML 文件）和 /data/images（放置图片）。这需要配置一下文件，将带有两个 location 的指令的 server 的块级命令放在 server 指令中。 首先，创建一个 /data/www 目录，然后放置一个事先写好内容的 index.html 文件。接着，创建一个 /data/images 目录，然后放置一些图片。 下一步，打开配置文件。默认的配置文件已经包含了一些关于 server 指令的样式，大多数情况下直接把他们给注释掉。现在，注释掉其他的区块，然后写一个新的 server 区块： 1234567http &#123; server &#123; &#125;&#125; 通常，该配置文件可能会包含多个 server 指令。这些 server 指令监听不同的端口和服务器名。一旦 nginx 决定哪个服务进程处理请求，它会根据在 server 块级指令中定义好的 location 指令的参数，来匹配请求头中指定的 URI。 将下列 location 指令添加到 server 指令中： 12345location / &#123; root /data/www;&#125; 该 location 指令相对于请求中的 URI 执行了 “/” 的前缀。为了匹配请求，URI 会被添加到 root 命令指定的路径后，即 /data/www，得到本地文件系统中请求文件的路径。如果，有几个 location 匹配到，那么 nginx 会选择最长的前缀。上面的 location 提供了长度为 1 的前缀，所以，仅当其他的 location 匹配失败后，该指令才会使用。 接着，添加第二个 location 区块： 12345location /images/ &#123; root /data;&#125; 它会匹配到以 /images/ 开头的请求（location / 也会匹配到该请求，只是前缀更短） server 块级命令的配置结果如下： 123456789101112131415server &#123; location / &#123; root /data/www; &#125; location /images/ &#123; root /data; &#125;&#125; 这已经是一个可用的服务器配置，它监听标准的 80 端口并且可以在本地上通过 http://localhost/ 访问。对于 URI 以 /images/ 开头的请求，服务器会从 /data/images 目录中，返回对应的文件。例如，nginx 会返回 /data/images/example.png 文件，当接收到 http://localhost/images/example.png 的请求响应时。如果该文件不存在，nginx 会返回一个 404 错误的响应。没有以 /images/ 开头的 URI 的请求，将会直接映射到 /data/www 目录中。比如，响应 http://localhost/some/example.html 的请求，nginx 会发送 /data/www/some/example.html 文件。 为了使用新的配置文件，如果还没开启 nginx 需要先开启，然后将重载信号发送给 nginx 的主进程，通过执行： 1nginx -s reload 如果你发现有些地方出了问题，你可以在 /usr/local/nginx/logs 或者 /var/log/nginx 目录下的 access.log 和 error.log 文件中，找到原因。搭建一个简易的代理服务 nginx 常常用来作为代理服务器，这代表着服务器接收请求，然后将它们传递给被代理服务器，得到请求的响应，再将它们发送给客户端。 我们将配置一个基本的代理服务器，它会处理本地图片文件的请求并返回其他的请求给被代理的服务器。在这个例子中，两个服务器都会定义在一个 nginx 实例中。 首先，通过在 nginx 配置文件中添加另一个 server 区块，来定义一个被代理的服务器，像下面的配置： 1234567891011server &#123; listen 8080; root /data/up1; location / &#123; &#125;&#125; 上面就是一个简单的服务器，它监听在 8080 端口（之前，listen 并没被定义，是因为默认监听的 80 端口）并且会映射所有的请求给 本地文件目录 /data/up1。创建该目录，然后添加 index.html 文件。注意，root 指令是放在 server 上下文中。当响应请求的 location 区块中，没有自己的 root 指令，上述的 root 指令才会被使用。 接着，使用前面章节中的 server 配置，然后将它改为一个代理服务配置。在第一个 location 区块中，放置已经添加被代理服务器的协议，名字和端口等参数的proxy_pass指令（在这里，就是 http://localhost:8080）: 123456789101112131415server &#123; location / &#123; proxy_pass http://localhost:8080; &#125; location /images/ &#123; root /data; &#125;&#125; 我们将修改第二个 location 区块，使他返回一些典型后缀的图片文件请求，现在它只会映射带有 /images/ 前缀的请求到 /data/images 目录下。修改后的 location 指令如下： 12345location ~ \.(gif|jpg|png)$&#123; root/data/images;&#125; 该参数是一个正则表达式，它会匹配所有以 .gif，.jpg 或者 .png 结尾的 URIs。一个正则表达式需要以 ~ 开头。匹配到的请求会被映射到 /data/images 目录下。 当 nginx 在选择 location 去响应一个请求时，它会先检测带有前缀的 location 指令，记住先是检测带有最长前缀的 location，然后检测正则表达式。如果有一个正则的匹配的规则，nginx 会选择该 location，否则，会选择之前缓存的规则。 最终，一个代理服务器的配置结果如下： 123456789101112131415server&#123; location/&#123; proxy_passhttp://localhost:8080/; &#125; location~\.(gif|jpg|png)$&#123; root/data/images; &#125;&#125; 该服务器会选择以 .gif，.jpg，或者 .png 结束的请求并且映射到 /data/images 目录（通过添加 URI 给 root 指令的参数），接着将其他所有的请求映射到上述被代理的服务器。 为了使用新的配置，像前几个章节描述的一样，需要向 nginx 发送重载信号。 这还有很多其他的指令，可以用于进一步配置代理连接。]]></content>
      <categories>
        <category>WebWebWeb</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java泛型总结]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E6%B3%9B%E5%9E%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[一. 我们为什么需要泛型？ 首先，我们看下下面这段简短的代码: 12345678910111213141516171819202122package CoreJava.day_5;import java.util.ArrayList;import java.util.List;/** * @author 李智 * @date 2016/12/15 */public class GenericTest &#123; public static void main(String[] args) &#123; List list = new ArrayList(); list.add("justdoit"); list.add("core"); list.add(100); for (int i = 0; i &lt; list.size(); i++) &#123; String name = (String) list.get(i); // 1 System.out.println("name:" + name); &#125; &#125;&#125; 我们定义一个List类型的集合，先向其中加入了两个字符串类型的值，随后加入一个Integer类型的值。这是完全允许的，因为此时list默认的类型为Object类型。在之后的循环中，由于忘记了之前在list中也加入了Integer类型的值或其他编码原因，很容易出现类似于//1中的错误。因为编译阶段正常，而运行时会出现“java.lang.ClassCastException”异常。因此，导致此类错误编码过程中不易发现。 在如上的编码过程中，我们发现主要存在两个问题： 1.当我们将一个对象放入集合中，集合不会记住此对象的类型，当再次从集合中取出此对象时，改对象的编译类型变成了Object类型，但其运行时类型任然为其本身类型。 2.因此，//1处取出集合元素时需要人为的强制类型转化到具体的目标类型，且很容易出现“java.lang.ClassCastException”异常。 那么有没有什么办法可以使集合能够记住集合内元素各类型，且能够达到只要编译时不出现问题，运行时就不会出现“java.lang.ClassCastException”异常呢？答案就是使用泛型。 二.什么是泛型？ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 这样说有点复杂，我们来看下上面那个例子采用泛型的写法: 1234567891011121314151617181920212223242526272829package CoreJava.day_5;import java.util.ArrayList;import java.util.List;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_2 &#123; public static void main(String[] args) &#123; /* List list = new ArrayList(); list.add("justdoit"); list.add("core"); list.add(100); */ List&lt;String&gt; list = new ArrayList&lt;String&gt;(); list.add("justdoit"); list.add("core"); //list.add(100); // 1 提示编译错误 for (int i = 0; i &lt; list.size(); i++) &#123; String name = list.get(i); // 2 System.out.println("name:" + name); &#125; &#125;&#125; 采用泛型写法后，在//1处想加入一个Integer类型的对象时会出现编译错误，通过List&lt; String&gt;，直接限定了list集合中只能含有String类型的元素，从而在//2处无须进行强制类型转换，因为此时，集合能够记住元素的类型信息，编译器已经能够确认它是String类型了。 结合上面的泛型定义，我们知道在List&lt; String&gt;中，String是类型实参，也就是说，相应的List接口中肯定含有类型形参。且get()方法的返回结果也直接是此形参类型（也就是对应的传入的类型实参）。下面就来看看List接口的的具体定义： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123; int size(); boolean isEmpty(); boolean contains(Object o); Iterator&lt;E&gt; iterator(); Object[] toArray(); &lt;T&gt; T[] toArray(T[] a); boolean add(E e); boolean remove(Object o); boolean containsAll(Collection&lt;?&gt; c); boolean addAll(Collection&lt;? extends E&gt; c); boolean addAll(int index, Collection&lt;? extends E&gt; c); boolean removeAll(Collection&lt;?&gt; c); boolean retainAll(Collection&lt;?&gt; c); void clear(); boolean equals(Object o); int hashCode(); E get(int index); E set(int index, E element); void add(int index, E element); E remove(int index); int indexOf(Object o); int lastIndexOf(Object o); ListIterator&lt;E&gt; listIterator(); ListIterator&lt;E&gt; listIterator(int index); List&lt;E&gt; subList(int fromIndex, int toIndex);&#125; 我们可以看到，在List接口中采用泛型化定义之后，&lt; E&gt;中的E表示类型形参，可以接收具体的类型实参，并且此接口定义中，凡是出现E的地方均表示相同的接受自外部的类型实参。 自然的，ArrayList作为List接口的实现类，其定义形式是: 123456789101112131415161718public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; public E get(int index) &#123; rangeCheck(index); checkForComodification(); return ArrayList.this.elementData(offset + index); &#125; //...省略掉其他具体的定义过程&#125; 由此，我们可以从源代码角度明白了为什么//1处加入Integer类型对象编译错误，且//2处get()到的类型直接就是String类型了。 三.自定义泛型接口、泛型类和泛型方法 从上面的内容中，大家已经明白了泛型的具体运作过程。也知道了接口、类和方法也都可以使用泛型去定义，以及相应的使用。是的，在具体使用时，可以分为泛型接口、泛型类和泛型方法。 自定义泛型接口、泛型类和泛型方法与上述Java源码中的List、ArrayList类似。如下，我们看一个最简单的泛型类和方法定义： 1234567891011121314151617181920212223242526272829303132package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_3 &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("core"); System.out.println("name:" + name.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; this.data = data; &#125; public T getData() &#123; return data; &#125;&#125; 在泛型接口、泛型类和泛型方法的定义过程中，我们常见的如T、E、K、V等形式的参数常用于表示泛型形参，由于接收来自外部使用时候传入的类型实参。那么对于不同传入的类型实参，生成的相应对象实例的类型是不是一样的呢？ 123456789101112131415161718package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_4 &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("core"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); System.out.println("name class:" + name.getClass()); // CoreJava.day_5.Box System.out.println("age class:" + age.getClass()); // CoreJava.day_5.Box System.out.println(name.getClass() == age.getClass()); // true &#125;&#125; 由此，我们发现，在使用泛型类时，虽然传入了不同的泛型实参，但并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，即还是原来的最基本的类型（本实例中为Box），当然，在逻辑上我们可以理解成多个不同的泛型类型。 究其原因，在于Java中的泛型这一概念提出的目的，导致其只是作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦出，也就是说，成功编译过后的class文件中是不包含任何泛型信息的。泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 四.类型通配符 接着上面的结论，我们知道，Box&lt; Number&gt;和Box&lt; Integer&gt;实际上都是Box类型，现在需要继续探讨一个问题，那么在逻辑上，类似于Box&lt; Number&gt;和Box&lt; Integer&gt;是否可以看成具有父子关系的泛型类型呢？ 为了弄清这个问题，我们继续看下下面这个例子: 12345678910111213141516171819202122232425package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_6 &#123; public static void main(String[] args) &#123; Box&lt;Number&gt; name = new Box&lt;Number&gt;(99); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); getData(name); //The method getData(Box&lt;Number&gt;) in the type GenericTest is //not applicable for the arguments (Box&lt;Integer&gt;) getData(age); // 1 &#125; public static void getData(Box&lt;Number&gt; data) &#123; System.out.println("data :" + data.getData()); &#125;&#125; 我们发现，在代码//1处出现了错误提示信息：The method getData(Box&lt; Number&gt;) in the t ype GenericTest is not applicable for the arguments (Box&lt; Integer&gt;)。显然，通过提示信息，我们知道Box&lt; Number&gt;在逻辑上不能视为Box&lt; Integer&gt;的父类。那么，原因是什么呢？ 123456789101112131415161718192021222324252627282930313233343536373839404142package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_5 &#123; public static void main(String[] args) &#123; Box&lt;Integer&gt; a = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; b = a; // 1 Box&lt;Float&gt; f = new Box&lt;Float&gt;(3.14f); b.setData(f); // 2 &#125; public static void getData(Box&lt;Number&gt; data) &#123; System.out.println("data :" + data.getData()); &#125;&#125;class Box&lt;T&gt; &#123; private T data; public Box() &#123; &#125; public Box(T data) &#123; setData(data); &#125; public T getData() &#123; return data; &#125; public void setData(T data) &#123; this.data = data; &#125;&#125; 这个例子中，显然//1和//2处肯定会出现错误提示的。在此我们可以使用反证法来进行说明。 假设Box&lt; Number&gt;在逻辑上可以视为Box&lt; Integer&gt;的父类，那么//1和//2处将不会有错误提示了，那么问题就出来了，通过getData()方法取出数据时到底是什么类型呢？Integer? Float? 还是Number？且由于在编程过程中的顺序不可控性，导致在必要的时候必须要进行类型判断，且进行强制类型转换。显然，这与泛型的理念矛盾，因此，在逻辑上Box&lt; Number&gt;不能视为Box&lt; Integer&gt;的父类。 好，那我们回过头来继续看“类型通配符”中的第一个例子，我们知道其具体的错误提示的深层次原因了。那么如何解决呢？总不能再定义一个新的函数吧。这和Java中的多态理念显然是违背的，因此，我们需要一个在逻辑上可以用来表示同时是Box&lt; Integer&gt;和Box&lt; Number&gt;的父类的一个引用类型，由此，类型通配符应运而生。 类型通配符一般是使用 ? 代替具体的类型实参。注意了，此处是类型实参，而不是类型形参！且Box&lt;?&gt;在逻辑上是Box&lt; Integer&gt;、Box&lt; Number&gt;…等所有Box&lt;具体类型实参&gt;的父类。由此，我们依然可以定义泛型方法，来完成此类需求。 1234567891011121314151617181920212223package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_7 &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("core"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println("data :" + data.getData()); &#125;&#125; 有时候，我们还可能听到类型通配符上限和类型通配符下限。具体有是怎么样的呢？ 在上面的例子中，如果需要定义一个功能类似于getData()的方法，但对类型实参又有进一步的限制：只能是Number类及其子类。此时，需要用到类型通配符上限。 12345678910111213141516171819202122232425262728293031package CoreJava.day_5;/** * @author 李智 * @date 2016/12/15 */public class GenericTest_8 &#123; public static void main(String[] args) &#123; Box&lt;String&gt; name = new Box&lt;String&gt;("core"); Box&lt;Integer&gt; age = new Box&lt;Integer&gt;(712); Box&lt;Number&gt; number = new Box&lt;Number&gt;(314); getData(name); getData(age); getData(number); //getUpperNumberData(name); // 1 getUpperNumberData(age); // 2 getUpperNumberData(number); // 3 &#125; public static void getData(Box&lt;?&gt; data) &#123; System.out.println("data :" + data.getData()); &#125; public static void getUpperNumberData(Box&lt;? extends Number&gt; data) &#123; System.out.println("data :" + data.getData()); &#125;&#125; 此时，显然，在代码//1处调用将出现错误提示，而//2 //3处调用正常。 类型通配符上限通过形如Box&lt; ? extends Number&gt;形式定义，相对应的，类型通配符下限为Box&lt; ? super Number&gt;形式，其含义与类型通配符上限正好相反，在此不作过多阐述了。五.话外篇本文中的例子主要是为了阐述泛型中的一些思想而简单举出的，并不一定有着实际的可用性。另外，一提到泛型，相信大家用到最多的就是在集合中，其实，在实际的编程过程中，自己可以使用泛型去简化开发，且能很好的保证代码质量。并且还要注意的一点是，Java中没有所谓的泛型数组一说。对于泛型，最主要的还是需要理解其背后的思想和目的。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>泛型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 8 最佳技巧]]></title>
    <url>%2F2017%2F02%2F18%2FJava-8-%E6%9C%80%E4%BD%B3%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[翻译文章转自一叶知秋 在过去的几年中，我一直使用Java 8 进行了很多的编码工作，用于开发 新应用 和 迁移遗留应用 ，我觉得是时候写一些有用的”最佳实践”。我个人不喜欢”最佳实践”这个术语，因为它意味着“一刀切”的解决方案，当然编码工作是不会这样的–这是因为我们开发人员会想出适合我们的方案。但我发现我对Java8特别的喜欢，它让我的生活更轻松一点，所以我想就此话题展开讨论。Optional Optional是一个被严重低估的功能, 它消除了很多困扰着我们的 NullPointerExceptions。它在代码边界（包括你调用和提供 API）处理上特别有用，因为它允许你和你调用的代码说明程序运行的期望结果。 然而，如果没有必要的思考和设计，那么就会导致一个小变化而影响大量的类，也会导致可读性变差。这里有一些关于如何高效使用Optional的提示。Optional 应该只用于返回类型 …不能是参数和属性. 阅读 这个博客 了解怎样使用 Optional。 幸运的是, IntelliJ IDEA 在打开 inspection 功能的情况下会检查你是否遵循了这些建议。 可选值应该在使用的地方进行处理.IntelliJ IDEA 的建议可以防止你不恰当的使用Optional, 所以你应该立即处理你发现的不恰当使用Optional。(根据自己的理解翻译) 你不应该简单的调用 get()Optional的目的是为了表示此值有可能为空，且让你有能力来应付这种情况。因此，在使用值之前进行检查是非常重要的。在某些情况下简单的调用get()而没有先使用isPresent()进行检查是一样会导致空指针问题。幸运的是，IntelliJ IDEA 任然会检查出这个问题并警告你。 有可能是一个更优雅的方式 isPresent() 与 get() 结合 使用的技巧 … …但还有更优雅的解决方案。你可以使用 orElse方法来使得当它为null时给出一个代替的值。 …或者使用 orElseGet方法来处理上述相同情况。这个例子和上面的看起来好像一样，但本例是可以调用 supplier 接口的 实现 ,，因此如果它是一个高开销的方法，可以使用 lambda 表达式来获得更好的性能。 使用Lambda表达式 Lambda 表达式 是 Java 8 的卖点之一.。即使你还没有使用过Java 8， 到目前你也可能有一些基本的了解。但在Java编程中还是一种新的方式，它也不是明显的”最佳实践” 。 这里有一些我遵循的指南。 保持简短 函数式程序员更愿意使用较长的lambda 表达式，但我们这些仅仅使用Java很多年的程序员来说更容易保持lambda 表达式的短小。你甚至更喜欢把它们限制在一行，更容易把较长的表达式 重构 到一个方法中。 把它们变成一个方法引用， 方法引用看起来有一点陌生，但却值得这样做，因为在某些情况有助于提高可读性，后面我再谈可读性。 明确的(作者应该想要表达的是: 参数命名规范，要有意义；有更好的翻译请修正) lambda 表达式中类型信息已经丢失了，因此你会发现包含类型信息的参数会更有用。 如你所见，这样会比较麻烦。因此我更喜欢给参数一个更有意义的命名。当然，你做与否， IntelliJ IDEA 都会让你看到参数的类型信息。 即使是在函数式接口的lambda 表达式中: 针对 Lambda 表达式进行设计 我认为lambda表达式有点像 泛型 – 泛型,我们经常使用它们 (例如, 给 List&lt;&gt; 添加类型信息 )，但不常见的是我们把一个方法或类泛型化 (如: Person&lt;’T&gt; )。同样的, 它就像我们使用通过lambdas包装的 Streams API，但对我们来说更罕见的是创建一个需要 lambda 表达式参数的方法。 IntelliJ IDEA 可以帮助你引入一个函数化的参数 这里让你可以使用 Lambda 表达式而非对象来 创建一个参数 。这个功能的好处在于其建议使用一个已有的 函数接口 来匹配这个规范。 这个将引导我们 使用已有的函数接口 当开发者越来越熟悉 Java 8 代码时，我们会知道使用例如 Supplier 和 Consumer 这样的接口会发生什么，但是单独再创建一个 ErrorMessageCreator 会让我们很诧异并且很浪费时间。你可以翻阅 function package 来查看系统本身已经给我们准备了什么。 为函数接口添加 @FunctionalInterface 注解 如果你真的需要创建自己的函数接口，那么就需要用这个 @FunctionalInterface 注解。这个注解似乎没多大用处，但是 IntelliJ IDEA 会在接口不满足这个注解要求的情况下予以提示。例如你没有指定要继承的方法： 指定太多的方法： 在类中使用注解而不是在接口： Lambda 表达式可用于任意只包含单个抽象方法的接口中，但是不能用于满足该要求的抽象类。看似不符合逻辑，但实际要求必须如此。 Streams Stream API 是Java 8的另一大卖点, 我认为到现在为止，我们仍然不知道这会对我们的编码方式有多大改变．但我发现这是一个好坏参半的功能。 流式风格 就我个人而言，更喜欢使用流式风格．当然你不必也这么做, 但我发现它帮助了我： ·一眼就能看出有哪些操作，它的执行顺序是什么·更方便调试（虽然IntelliJ IDEA提供了 在包含lambda表达式的行上设置断点的能力 ，为了更方便调试，把它拆分到不同的行上）* 在测试的时候允许取消一个操作·在调试或测试是，可以很方便的插入peek() 在我看来这样写很简洁。但是使用这种方法并没有给我们节省多少代码行。你可能需要调整代码格式化设置让代码看起来更加清晰。 使用方法引用 是的，你需要一点时间来适应这个奇怪的语法。但如果使用恰当，真的可以提升代码的可读性，看看下面代码： 以及使用 Objects 类的辅助方法： 后面一段代码更加的明确可读。IntelliJ IDEA 通常会知道怎么将一个 Lambda 表达式进行折叠。 当对集合进行元素迭代时，尽可能的使用 Streams API …或者用新的集合方法，例如 forEach . IntelliJ IDEA 会建议你这么做： 一般来说使用 Streams API 比起循环和 if 语句组合来得更加直观，例如： IntelliJ IDEA 会建议这样的写法进行重构： 我做过的性能测试显示这种重构带来的结果比较奇怪，难以预测，有时候好，有时候坏，有时候没区别。一如既往的，如果你的应用对性能问题非常在意，请认真的进行衡量。 遍历数组时请用 for 循环 然后，使用 Java 8 并不意味着你一定要使用流 API 以及集合的新方法。IntelliJ IDEA 会建议一些做法改用流的方式重构，但你不一定非得接受 (记住 inspections can be suppressed 或者 turned off ). 特别是对一个原始类型的小数组时，使用 for 循环的性能是最好的，而且代码更具可读性（至少对 Streams API 的新手来说是这样）： 任何的技巧和提示都不是一成不变的，你应该自己决定哪里需要使用 Streams API ，而哪里还用循环操作。 最后 我每天都在发现一些新的东西，有时候我的偏好会有所变化。例如我过去会讨厌方法的引用。非常期待倾听你的建议。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Logger级别]]></title>
    <url>%2F2017%2F02%2F18%2FLogger%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[日志记录器(Logger)是日志处理的核心组件。log4j具有5种正常级别(Level)。日志记录器(Logger)的可用级别Level (不包括自定义级别 Level)， 以下内容就是摘自log4j API (http://jakarta.apache.org/log4j/docs/api/index.html):static Level DEBUGDEBUG Level指出细粒度信息事件对调试应用程序是非常有帮助的。static Level INFOINFO level表明 消息在粗粒度级别上突出强调应用程序的运行过程。static Level WARNWARN level表明会出现潜在错误的情形。static Level ERRORERROR level指出虽然发生错误事件，但仍然不影响系统的继续运行。static Level FATALFATAL level指出每个严重的错误事件将会导致应用程序的退出。另外，还有两个可用的特别的日志记录级别: (以下描述来自log4j API http://jakarta.apache.org/log4j/docs/api/index.html):static Level ALLALL Level是最低等级的，用于打开所有日志记录。static Level OFFOFF Level是最高等级的，用于关闭所有日志记录。日志记录器（Logger）的行为是分等级的。如下表所示：分为OFF、FATAL、ERROR、WARN、INFO、DEBUG、ALL或者您定义的级别。Log4j建议只使用四个级别，优先级从高到低分别是 ERROR、WARN、INFO、DEBUG。通过在这里定义的级别，您可以控制到应用程序中相应级别的日志信息的开关。比如在这里定义了INFO级别，则应用程序中所有DEBUG级别的日志信息将不被打印出来，也是说大于等于的级别的日志才输出。 日志记录的级别有继承性，子类会记录父类的所有的日志级别。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Logger</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java接口是常量存放的最佳地点吗？]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E6%8E%A5%E5%8F%A3%E6%98%AF%E5%B8%B8%E9%87%8F%E5%AD%98%E6%94%BE%E7%9A%84%E6%9C%80%E4%BD%B3%E5%9C%B0%E7%82%B9%E5%90%97%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[今天偶然看到接口中不能包含实例域或静态方法，但是却可以包含常量。其实在之前，就知道这么回事，但是一直只是当做知道而已，现在回过头来巩固基础，觉得有必要多想想。首先，由于java的接口中声明的字段在编译时会自动加上static final的修饰符，即声明为常量。因而接口通常是存放常量的最佳地点，因为这样可以省去很多修饰符嘛，然而在java的实际应用时却会产生一些问题。 问题的起因个人觉得有两个:第一，是我们所使用的常量并不是一成不变的，而是相对于变量不能赋值改变。例如我们在一个项目初期定义常量π＝3.14，而由于计算精度的提高我们可能会重新定义π＝3.14159，此时整个项目对此常量的引用都应该做出改变。第二，java是动态语言。与c++之类的静态语言不同,java对一些字段的引用可以在运行期动态进行，这种灵活性是java这样的动态语言的一大优势。也就使得我们在java项目中有时部分内容的改变不用重新编译整个项目，而只需编译改变的部分重新发布就可以改变整个应用。 例如，有一个interface A，一个class B，代码如下： 123456789public interface A&#123; String name = "bright";&#125;public class B&#123; public static void main(String[] args)&#123; System.out.println("Class A's name = " + A.name); &#125;&#125; 编译A和B。运行，输入java B，显然结果如下：1Class A's name = bright 我们现在修改A如下：123public interface A&#123; String name = "bright sea";&#125; 编译A后重新运行B，输入java B，注意：结果如下1Class A's name = bright 为什么不是”Class A’s name = bright sea”？让我们使用jdk提供的反编译工具javap反编译B.class看个究竟，输入：javap -c B ，结果如下： 1234567891011121314Compiled from B.javapublic class B extends java.lang.Object &#123; public B(); public static void main(java.lang.String[]);&#125;Method B() 0 aload_0 1 invokespecial #1 &lt;Method java.lang.Object()&gt; 4 returnMethod void main(java.lang.String[]) 0 getstatic #2 &lt;Field java.io.PrintStream out&gt; 3 ldc #3 &lt;String "Class A's name = bright"&gt; 5 invokevirtual #4 &lt;Method void println(java.lang.String)&gt; 8 return 注意到标号3的代码了吗？由于引用了一个static final 的字段，编译器已经将interface A中name的内容编译进了class B中，而不是对interface A中的name的引用。因此除非我们重新编译class B，interface A中name发生的变化无法在class B中反映。如果这样去做那么java的动态优势就消失殆尽。 解决方案，有两种解决方法。第一种方法是不再使用常量，将所需字段放入class中声明，并去掉final修饰符。但这种方法存在一定的风险，由于不再是常量着因而在系统运行时有可能被其他类修改其值而发生错误，也就违背了我们设置它为常量的初衷，因而不推荐使用。第二种方法，将常量放入class中声明，使用class方法来得到此常量的值。为了保持对此常量引用的简单性，我们可以使用一个静态方法。我们将A.java和B.java修改如下：123456789101112public class A&#123; private static final String name = "bright"; public static String getName()&#123; return name; &#125;&#125;public class B&#123; public static void main(String[] args)&#123; System.out.println("Class A's name = " + A.getName()); &#125;&#125; 同样我们编译A和B。运行class B，输入java B，显然结果如下：Class A’s name = bright现在我们修改A如下：123456public class A&#123; private static final String name = "bright"; public static String getName()&#123; return name; &#125;&#125; 我们再次编译A后重新运行B，输入java B：结果如下1Class A's name = bright sea 终于得到了我们想要的结果，我们可以再次反编译B看看class B的改变，输入javap -c B,结果如下：123456789101112131415161718192021Compiled from B.javapublic class B extends java.lang.Object &#123; public B(); public static void main(java.lang.String[]);&#125;Method B() 0 aload_0 1 invokespecial #1 &lt;Method java.lang.Object()&gt; 4 returnMethod void main(java.lang.String[]) 0 getstatic #2 &lt;Field java.io.PrintStream out&gt; 3 new #3 &lt;Class java.lang.StringBuffer&gt; 6 dup 7 invokespecial #4 &lt;Method java.lang.StringBuffer()&gt; 10 ldc #5 &lt;String "Class A's name = "&gt; 12 invokevirtual #6 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt; 15 invokestatic #7 &lt;Method java.lang.String getName()&gt; 18 invokevirtual #6 &lt;Method java.lang.StringBuffer append(java.lang.String)&gt; 21 invokevirtual #8 &lt;Method java.lang.String toString()&gt; 24 invokevirtual #9 &lt;Method void println(java.lang.String)&gt; 27 return 注意标号10至15行的代码，class B中已经变为对A class的getName()方法的引用，当常量name的值改变时我们只需对class A中的常量做修改并重新编译，无需编译整个项目工程我们就能改变整个应用对此常量的引用，即保持了java动态优势又保持了我们使用常量的初衷，因而方法二是一个最佳解决方案。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>接口</tag>
        <tag>常量</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习总结（五）]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用反射实例对象 使用反射机制，我们可以在运行时动态加载类并且实例化对象，操作对象的方法、改变类成员的值，甚至还可以改变私有（private）成员的值。 我们可以用 Class 的 newInstance() 方法来实例化一个对象，实例化的对象是以 Object 传回的，例如：12Class c = Class.forName(className);Object obj = c.newInstance(); 下面范例动态加载list接口的类： 123456789101112131415161718192021222324252627282930package CoreJava.day_2;import java.util.List;/** * @author 李智 * @date 2016/12/5 */public class NewInstanceDemo &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); List list = (List) c.newInstance(); for (int i = 0; i &lt; 5; i++) &#123; list.add("element " + i); &#125; for (Object o : list.toArray()) &#123; System.out.println(o); &#125; &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定的类"); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出： 123456java CoreJava.day_2.NewInstanceDemo java.util.ArrayListelement 0element 1element 2element 3element 4 实际上如果想要使用反射来动态加载类，通常是对对象的接口或类别都一无所知，也就无法像上面对 newInstance() 传回的对象进行接口转换。 如果加载的类中具备无参数的构造方法，则可以无参数的 newInstance() 来构造一个不指定初始化的引用，如果要在动态加载及生成对象时指定对象的引用，则要先指定参数类型、取得 Constructor 对象、使用 Constructor 的 newInstance() 并指定参数。 可以用一个例子来说明，先定义一个student类: 123456789101112131415161718192021222324252627282930313233343536373839package CoreJava.day_2;/** * @author 李智 * @date 2016/12/05 */public class Student &#123; private String name; private int score; public Student() &#123; name = "N/A"; &#125; public Student(String name, int score) &#123; this.name = name; this.score = score; &#125; public void setName(String name) &#123; this.name = name; &#125; public void setScore(int score) &#123; this.score = score; &#125; public String getName() &#123; return name; &#125; public int getScore() &#123; return score; &#125; public String toString() &#123; return name + ":" + score; &#125;&#125; 我们可以用 Class.forName() 来加载 Student ，并使用第二个有参数的构造方法来构造Student 实例： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package CoreJava.day_2;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationTargetException;/** * @author 李智 * @date 2016/12/5 */public class NewInstanceDemo2 &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); // 指定参数 Class[] params = new Class[2]; // 第一个是String params[0] = String.class; // 第二个是int params[1] = Integer.TYPE; // 取得对应的构造方法 Constructor constructor = c.getConstructor(params); // 指定引用内容 Object[] argObjs = new Object[2]; argObjs[0] = "caterpillar"; argObjs[1] = new Integer(90); // 给定引用并初始化 Object obj = constructor.newInstance(argObjs); // toString()查看 System.out.println(obj); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到类"); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; System.out.println("没有所指定的方法"); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出： 12java NewInstanceDemo2 CoreJava.day_2.Studentcaterpillar:90 调用方法 使用反射可以取回类上方法的对象代表，方法的物件代表是 java.lang.reflect.Method 的实例，我们可以使用它的 invoke() 方法来动态调用指定的方法，例如调用上面 Student 上的 setName() 等方法： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051package CoreJava.day_2;import java.lang.reflect.InvocationTargetException;import java.lang.reflect.Method;/** * @author 李智 * @date 2016/12/5 */public class InvokeMethodDemo &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); // 使用无参构造方法实例对象 Object targetObj = c.newInstance(); // 设置参数类型 Class[] param1 = &#123;String.class&#125;; // 根据参数取回方法 Method setNameMethod = c.getMethod("setName", param1); // 设置引用 Object[] argObjs1 = &#123;"caterpillar"&#125;; // 给引用调用指定对象的方法方法 setNameMethod.invoke(targetObj, argObjs1); Class[] param2 = &#123;Integer.TYPE&#125;; Method setScoreMethod = c.getMethod("setScore", param2); Object[] argObjs2 = &#123;new Integer(90)&#125;; setScoreMethod.invoke(targetObj, argObjs2); // 显示类描述 System.out.println(targetObj); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到类"); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchMethodException e) &#123; System.out.println("没有这个方法"); &#125; catch (IllegalArgumentException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; catch (InvocationTargetException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 我们可以指定加载 Student 类并生成实例，接着可以动态调用 setName() 和 setScore() 方法，由于调用setName() 和 setScore() 所设置的参数是 “caterpillar” 和90。 在很少的情況下，我们需要突破 Java 的存取限制来调用受保护的（protected）或私有（private）的方法（例如我们拿到一个组件（Component），但我们没法修改它的原始码来改变某个私有方法的权限，而我们又一定要调用某个私有方法），这时我们可以使用反射机制來达到目的，一个存取私有方法的例子如下： 1234Method privateMethod = c.getDeclaredMethod("somePrivateMethod", new Class[0]);privateMethod.setAccessible(true);privateMethod.invoke(targetObj, argObjs); 使用反射来动态调用方法的实例例子之一是在 JavaBean 的设定，例如在 JSP/Servlet 中，可以根据使用者的请求名和 JavaBean 的属性自动对比，将请求值设置到指定的 JavaBean 上，并自动根据参数类型转换。 下面是一个map的小例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091package CoreJava.day_2;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Map;/** * @author 李智 * @date 2016/12/5 */public class CommandUtil &#123; public static Object getCommand(Map requestMap, String commandClass) throws Exception &#123; Class c = Class.forName(commandClass); Object o = c.newInstance(); return updateCommand(requestMap, o); &#125; // 使用reflection自动找出要更新的属性 public static Object updateCommand( Map requestMap, Object command) throws Exception &#123; Method[] methods = command.getClass().getDeclaredMethods(); for (int i = 0; i &lt; methods.length; i++) &#123; // 略过private、protected成员 // 且找出必须是set开头的方法 if (!Modifier.isPrivate(methods[i].getModifiers()) &amp;&amp; !Modifier.isProtected(methods[i].getModifiers()) &amp;&amp; methods[i].getName().startsWith("set")) &#123; // 取得不包括set方法 String name = methods[i].getName() .substring(3) .toLowerCase(); // 如果setter名称键值对相同 // 调用对应的setter并给值 if (requestMap.containsKey(name)) &#123; String param = (String) requestMap.get(name); Object[] values = findOutParamValues( param, methods[i]); methods[i].invoke(command, values); &#125; &#125; &#125; return command; &#125; // 转换对应类型 private static Object[] findOutParamValues( String param, Method method) &#123; Class[] params = method.getParameterTypes(); Object[] objs = new Object[params.length]; for (int i = 0; i &lt; params.length; i++) &#123; if (params[i] == String.class) &#123; objs[i] = param; &#125; else if (params[i] == Short.TYPE) &#123; short number = Short.parseShort(param); objs[i] = new Short(number); &#125; else if (params[i] == Integer.TYPE) &#123; int number = Integer.parseInt(param); objs[i] = new Integer(number); &#125; else if (params[i] == Long.TYPE) &#123; long number = Long.parseLong(param); objs[i] = new Long(number); &#125; else if (params[i] == Float.TYPE) &#123; float number = Float.parseFloat(param); objs[i] = new Float(number); &#125; else if (params[i] == Double.TYPE) &#123; double number = Double.parseDouble(param); objs[i] = new Double(number); &#125; else if (params[i] == Boolean.TYPE) &#123; boolean bool = Boolean.parseBoolean(param); objs[i] = new Boolean(bool); &#125; &#125; return objs; &#125; public static void main(String[] args) throws Exception &#123; Map&lt;String, String&gt; request = new HashMap&lt;String, String&gt;(); request.put("name", "caterpillar"); request.put("score", "90"); Object obj = CommandUtil.getCommand(request, args[0]); System.out.println(obj); &#125;&#125; CommandUtil 可以自动根据方法上的参数类型，将Map 中的value转换成相应的类型，目前它可以转换基本类型和 String。 输出： 12java CommandUtilDemo CoreJava.day_2.Studentcaterpillar:90 当然也可以修改成员变量，尽管直接读取类的成员属性（Field）是不被鼓励的，但我们仍是可以直接存取公共的（public）成员属性的，而我们甚至也可以通过反射机制来读取私用成员变量，以一个例子来说明： 1234567891011121314package CoreJava.day_2;/** * @author 李智 * @date 2016/12/5 */public class TestField &#123; public int testInt; public String testString; public String toString() &#123; return testInt + ":" + testString; &#125;&#125; 然后利用反射机制动态的读取成员变量： 123456789101112131415161718192021222324252627282930313233343536package CoreJava.day_2;import java.lang.reflect.Field;/** * @author 李智 * @date 2016/12/5 */public class AssignFieldDemo &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); Object targetObj = c.newInstance(); Field testInt = c.getField("testInt"); testInt.setInt(targetObj, 99); Field testString = c.getField("testString"); testString.set(targetObj, "caterpillar"); System.out.println(targetObj); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("没有指定类"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定的类"); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125; catch (NoSuchFieldException e) &#123; System.out.println("找不到指定的成员变量"); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 输出： 12java AssignFieldDemo CoreJava.day_2.TestField99:caterpillar 如果有必要的话，也可以通过反射机制来读取私有的成员变量，例如： 123Field privateField = c.getDeclaredField("privateField"); privateField.setAccessible(true);privateField.setInt(targetObj, 99); 数组在 Java 中数组也是一个对象，也会有一个 Class 实例来表示它，我们用几个基本类型和String来进行测试： 123456789101112131415161718192021222324252627package CoreJava.day_2;/** * @author 李智 * @date 2016/12/5 */public class ArrayDemo &#123; public static void main(String[] args) &#123; short[] sArr = new short[5]; int[] iArr = new int[5]; long[] lArr = new long[5]; float[] fArr = new float[5]; double[] dArr = new double[5]; byte[] bArr = new byte[5]; boolean[] zArr = new boolean[5]; String[] strArr = new String[5]; System.out.println("short 数组：" + sArr.getClass()); System.out.println("int 数组：" + iArr.getClass()); System.out.println("long 数组：" + lArr.getClass()); System.out.println("float 数组：" + fArr.getClass()); System.out.println("double 数组：" + dArr.getClass()); System.out.println("byte 数组：" + bArr.getClass()); System.out.println("boolean 数组：" + zArr.getClass()); System.out.println("String 数组：" + strArr.getClass()); &#125;&#125; 输出： 12345678910short 数组：class [Sint 数组：class [Ilong 数组：class [Jfloat 数组：class [Fdouble 数组：class [Dbyte 数组：class [Bboolean 数组：class [ZString 数组：class [Ljava.lang.String;Process finished with exit code 0 要使用反射机制动态生成数组的话，也可以这样： 12345678910111213141516171819202122232425262728package CoreJava.day_2;import java.lang.reflect.Array;/** * @author 李智 * @date 2016/12/5 */public class NewArrayDemo &#123; public static void main(String[] args) &#123; Class c = String.class; Object objArr = Array.newInstance(c, 5); for (int i = 0; i &lt; 5; i++) &#123; Array.set(objArr, i, i + ""); &#125; for (int i = 0; i &lt; 5; i++) &#123; System.out.print(Array.get(objArr, i) + " "); &#125; System.out.println(); String[] strs = (String[]) objArr; for (String s : strs) &#123; System.out.print(s + " "); &#125; &#125;&#125; Array.newInstance() 的第一个参数是指定参数类型，而第二个参数是用来指定数组长度的，结果如下： 120 1 2 3 40 1 2 3 4 如果是二维数组，也是一样的： 1234567891011121314151617181920212223242526272829303132package CoreJava.day_2;import java.lang.reflect.Array;/** * @author 李智 * @date 2016/12/5 */public class NewArrayDemo2 &#123; public static void main(String[] args) &#123; Class c = String.class; // 打算建立一个3*4数组 int[] dim = new int[]&#123;3, 4&#125;; Object objArr = Array.newInstance(c, dim); for (int i = 0; i &lt; 3; i++) &#123; Object row = Array.get(objArr, i); for (int j = 0; j &lt; 4; j++) &#123; Array.set(row, j, "" + (i + 1) * (j + 1)); &#125; &#125; for (int i = 0; i &lt; 3; i++) &#123; Object row = Array.get(objArr, i); for (int j = 0; j &lt; 4; j++) &#123; System.out.print(Array.get(row, j) + " "); &#125; System.out.println(); &#125; &#125;&#125; 输出结果： 1231 2 3 42 4 6 83 6 9 12 如果想要知道数组元素的类型，可以在取得数组的 Class 实例之后，使用 Class 实例的 getComponentType() 方法，所取回的是元素的 Class 实例，例如： 12int[] iArr = new int[5];System.out.println(iArr.getClass().getComponentType()); 对反射的总结差不多就写到这里了，查阅了很多资料，网络上写的也是参差不齐的，在手写的几十个demo支撑下，得出的一点关于反射的东西，肯定不能说全部正确，但是还是可以提供一些帮助的 -。-]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习总结（四）]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[类加载器 Java在需要使用类的时候，才会将类加载，Java的类加载是由类加载器（Class loader）来完成的。当我们在命令模式下执行java xxx指令后，Java执行程序会尝试找到jre安装的所在目录，然后找到jvm.dll（假设在jre目录下的bin\client下），接着启动jvm并进行初始化操作，接着会产生bootstrap loader，bootstrap loader则会加载 extended loader，并设定 extended loader的parent为bootstrap loader，接着bootstrap loader会加载system loader，并将system loader的parent设为 extended loader。bootstrap loader通常是由c写的， extended loader是由Java写的，实际这个对应着sun.misc.Launcher\$ExtClassLoader（Launcher 中的内部类）；system loader 是由 Java写的，实际对应sun.misc. Launcher\$AppClassLoader（Launcher 中的内部类）。 流程如下图： Bootstrap Loader 会查找系统参数 sun.boot.class.path 中指定位置的类，假设是 JRE classes 下之文件，或 lib 目录下 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“sun.boot.class.path”) 来显示 sun.boot.class.path 中指定的路劲，例如在我的终端显示的是以下的路劲： 1/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/resources.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/rt.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/sunrsasign.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/jsse.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/jce.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/charsets.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/jfr.jar:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/classes Extended Loader（sun.misc.Launcher$ExtClassLoader）是由 Java 写的，会查找系统参数java.ext.dirs 中指定位置的类，假设是 JRE 目录下的 lib\ext\classes 目录下的 .class 文件，或 lib\ext 目录下的 .jar 文件中（例如 rt.jar）的类并加载，我们可以使用 System.getProperty(“java.ext.dirs”) 来显示指定的路劲: 1/Users/lizhi/Library/Java/Extensions:/Library/Java/JavaVirtualMachines/jdk1.8.0_65.jdk/Contents/Home/jre/lib/ext:/Library/Java/Extensions:/Network/Library/Java/Extensions:/System/Library/Java/Extensions:/usr/lib/java System Loader（sun.misc.Launcher$AppClassLoader）是由 Java 写的，会查找系统参 java.class.path 中指定位置的类，也就是 Classpath 所指定的路径，假设是目前工作路径下的 .class 文件，我们可以使用 System.getProperty(“java.class.path”) 来显示 java.class.path 中指定的路径，在使用 java 执行程序时，我们也可以加上 -cp 來覆盖原有的 Classpath 设置，例如： 1java –cp ./classes SomeClass Bootstrap Loader 会在 JVM 启动之后生成，之后它会加载 Extended Loader 并将其 parent 设为 Bootstrap Loader，然后Bootstrap Loader 再加载 System Loader 并将其 parent 设为 ExtClassLoader，接着System Loader 开始加载我们指定的类，在加载类时，每个类加载器会先将加载类的任务讲给他的parent，如果 parent 找不到，才由自己负责加载，所以在加载类时，会以 Bootstrap Loader→Extended Loader→System Loader 的顺序开查找类，如果都找不到，就会抛出 NoClassDefFoundError。 类加载器在 Java 中是以 java.lang.ClassLoader 形式存在，每一个类被加载后，都会有一个 Class 的实例来代表，而每个 Class 的实例都会记得自己是由哪个 ClassLoader 加载的，可以由 Class 的 getClassLoader() 取得加载该类的 ClassLoader，而从 ClassLoader 的 getParent() 方法可以取得自己的 parent。 123456789101112131415161718192021package CoreJava.day_2;/** * @author 李智 * @date 2016/12/5 */public class SomeClass &#123; public static void main(String[] args) &#123; // 建立SomeClass实例 SomeClass some = new SomeClass(); // 取得SomeClass的Class实例 Class c = some.getClass(); // 取得ClassLoader ClassLoader loader = c.getClassLoader(); System.out.println(loader); // 取得父ClassLoader System.out.println(loader.getParent()); // 再取得父ClassLoader System.out.println(loader.getParent().getParent()); &#125;&#125; 输出： 12345sun.misc.Launcher$AppClassLoader@60e53b93sun.misc.Launcher$ExtClassLoader@66d3c617nullProcess finished with exit code 0 CoreJava.day_2.SomeClass 是个自定义类，我们在目前的目录下执行程序，首先 AppClassLoader 会将加载类的任务交給 ExtClassLoader，而 ExtClassLoader 将会把加载类的任务交给 Bootstrap Loader，由于Bootstrap Loader 在它的路径（sun.boot.class.path）下找不到类，所以由 ExtClassLoader 来尝试查找，而 ExtClassLoader 在它的路径设置（java.ext.dirs）下也找不到类，所以由 AppClassLoader 来尝试查找，AppClassLoader 最后在 Classpath（java.class.path）设置下找到指定的类并加载。 在输出中可以看到，加载 SomeClass 的 ClassLoader 是 AppClassLoader，而 AppClassLoader 的 parent 是 ExtClassLoader，而 ExtClassLoader 的 parent 是 null，null 并不是表示 ExtClassLoader 没有设置 parent，而是因为 Bootstrap Loader 通常由 C 写的，在 Java 中并没有一个类来表示它，所以才会显示为null。 如果把 SomeClass 的 .class 文件移至 JRE 目录下的 lib\ext\classes下，并重新（任何目录下）执行程序，我们可以看到： 123nullException in thread "main" java.lang.NullPointerException at CoreJava.day_2.SomeClass.main(SomeClass.java:13) 由于 SomeClass 这次可以在 Bootstrap Loader 的设置路径下找到，所以会由 Bootstrap Loader 来加载 SomeClass 类，Bootstrap Loader 通常由 C 写的，在 Java 中没有一个实际类来表示，所以显示为 null，因为表示为null，所以再由 null 上尝试调用 getParent() 方法就会抛出 NullPointerException 异常。 取得 ClassLoader 的实例之后，我们可以使用它的 loadClass() 方法来加载类，使用 loadClass() 方法加载类时，不会执行静态代码块，静态代码块的执行会等到真正使用类时来建立实例：1234567891011package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class TestClass2 &#123; static &#123; System.out.println("[执行静态代码块]"); &#125;&#125; 1234567891011121314151617181920212223package CoreJava.day_2;/** * @author 李智 * @date 2016/12/5 */public class ForNameDemoV3 &#123; public static void main(String[] args) &#123; try &#123; System.out.println("加载TestClass2"); ClassLoader loader = ForNameDemoV3.class.getClassLoader(); Class c = loader.loadClass("CoreJava.day_2.TestClass2"); System.out.println("TestClass2声明"); TestClass2 test = null; System.out.println("TestClass2实例对象"); test = new TestClass2(); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定的类"); &#125; &#125;&#125; 输出： 123456加载TestClass2TestClass2声明TestClass2实例对象[执行静态代码块]Process finished with exit code 0 可以看出，loadClass() 不会在加载类时执行静态代码块，而会在使用类new对象时才执行静态代码块代码。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习总结（三）]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Class对象表示所加载的类，取得Class对象后，我们就可以愉快的取得与类相关的信息了，就像包（package,package也是类名的一部分哦~），构造方法，方法，属性等信息，而每一个信息，也会有相应的类别形态，比如包对应的是 java.lang.Package，构造方法对应的是java.lang.reflect.Constructor，成员方法对应的是 java.lang.reflect.Method，属性对应的是 java.lang.reflect.Field等。先来个简单的例子吧，获取一下包名： 12345678910111213141516171819package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class ClassInfoDemo &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); Package p = c.getPackage(); System.out.println(p.getName()); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("没有指定类"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定类"); &#125; &#125;&#125; 输出： 12java ClassInfoDemo java.util.ArrayListjava.util 用相应的方法，我们可以分别取得 Field、Constructor、Method等对象。 下面是一个我之前写的可以获取某些类信息的一个demo： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package CoreJava.day_2;import java.lang.reflect.Constructor;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.Scanner;/** * @author 李智 * @date 2016/12/1 */public class ReflectTest &#123; public static void main(String[] args) &#123; String name; if (args.length &gt; 0) &#123; name = args[0]; &#125; else &#123; Scanner in = new Scanner(System.in); System.out.println("输入类名:(例如:java.util.Date)"); name = in.next(); &#125; try &#123; Class c1 = Class.forName(name); Class superc1 = c1.getSuperclass(); String modifiers = Modifier.toString(c1.getModifiers()); if (modifiers.length() &gt; 0) &#123; System.out.print(modifiers + ""); &#125; System.out.print("class " + name); if (superc1 != null &amp;&amp; superc1 != Object.class) &#123; System.out.print(" extends" + superc1.getName()); &#125; System.out.print("\n&#123;\n"); printConstructors(c1); System.out.println(); printMethods(c1); System.out.println(); printFields(c1); System.out.println("&#125;"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; System.exit(0); &#125; public static void printConstructors(Class c1) &#123; Constructor[] constructors = c1.getDeclaredConstructors(); for (Constructor c : constructors) &#123; String name = c.getName(); System.out.print(""); String modifers = Modifier.toString(c.getModifiers()); if (modifers.length() &gt; 0) &#123; System.out.print(modifers + " "); &#125; System.out.print(name + "("); Class[] paramTypes = c.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) &#123; System.out.print(","); &#125; System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printMethods(Class c1) &#123; Method[] methods = c1.getDeclaredMethods(); for (Method m : methods) &#123; Class retType = m.getReturnType(); String name = m.getName(); System.out.print(" "); String modifiers = Modifier.toString(m.getModifiers()); if (modifiers.length() &gt; 0) &#123; System.out.print(modifiers + " "); &#125; System.out.print(retType.getName() + " " + "("); Class[] paramTypes = m.getParameterTypes(); for (int j = 0; j &lt; paramTypes.length; j++) &#123; if (j &gt; 0) &#123; System.out.print(","); &#125; System.out.print(paramTypes[j].getName()); &#125; System.out.println(");"); &#125; &#125; public static void printFields(Class c1) &#123; Field[] fields = c1.getDeclaredFields(); for (Field f : fields) &#123; Class type = f.getType(); String name = f.getName(); System.out.print(" "); String modifiers = Modifier.toString(f.getModifiers()); if (modifiers.length() &gt; 0) &#123; System.out.print(modifiers + " "); &#125; System.out.println(type.getName() + " " + name + ";"); &#125; &#125;&#125; 输出： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465输入类名:(例如:java.util.Date)java.util.Datepublicclass java.util.Date&#123;public java.util.Date(java.lang.String);public java.util.Date(int,int,int,int,int,int);public java.util.Date(int,int,int,int,int);public java.util.Date();public java.util.Date(long);public java.util.Date(int,int,int); public boolean (java.lang.Object); public java.lang.String (); public int (); public java.lang.Object (); public int (java.util.Date); public volatile int (java.lang.Object); private void (java.io.ObjectInputStream); private void (java.io.ObjectOutputStream); private final sun.util.calendar.BaseCalendar$Date (); private final sun.util.calendar.BaseCalendar$Date (sun.util.calendar.BaseCalendar$Date); public static long (java.lang.String); public boolean (java.util.Date); public boolean (java.util.Date); public int (); public void (int); public int (); public void (int); public void (int); public int (); public int (); public void (int); public int (); public void (int); public int (); public void (int); private final long (); static final long (java.util.Date); private static final java.lang.StringBuilder (java.lang.StringBuilder,java.lang.String); public java.lang.String (); public java.lang.String (); public int (); private final sun.util.calendar.BaseCalendar$Date (); private static final sun.util.calendar.BaseCalendar (sun.util.calendar.BaseCalendar$Date); private static final sun.util.calendar.BaseCalendar (long); private static final sun.util.calendar.BaseCalendar (int); private static final synchronized sun.util.calendar.BaseCalendar (); public java.time.Instant (); public static long (int,int,int,int,int,int); public static java.util.Date (java.time.Instant); public int (); public void (long); public long (); private static final sun.util.calendar.BaseCalendar gcal; private static sun.util.calendar.BaseCalendar jcal; private transient long fastTime; private transient sun.util.calendar.BaseCalendar$Date cdate; private static int defaultCenturyStart; private static final long serialVersionUID; private static final [Ljava.lang.String; wtb; private static final [I ttb;&#125;Process finished with exit code 0 输入一个类（完整的类名），即可打印该类的略为完整信息。当然还有一些不知道的，可以查看API来完成。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习总结（二）]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[使用 Class.forName() 加载类 在一些应用中，我们无法事先知道使用者将会加载什么类，而必须让使用者指定类名类加载类，我们就可以用Class的静态forName()方法来实现动态加载类，如下：1234567891011121314151617181920212223242526package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class ForNameDemo &#123; public static void main(String[] args) &#123; try &#123; Class c = Class.forName(args[0]); System.out.println("类名：" + c.getName()); System.out.println("是否为接口：" + c.isInterface()); System.out.println("是否为基本类型：" + c.isPrimitive()); System.out.println("是否为数组：" + c.isArray()); System.out.println("父类名：" + c.getSuperclass().getName()); &#125; catch (ArrayIndexOutOfBoundsException e) &#123; System.out.println("没有指定的类名"); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定类"); &#125; &#125;&#125; 输出: 123456java ForNameDemo java.util.String类名：java.util.Scanner是否为接口：false是否为基本类型：false是否为数组：false父类名：java.lang.Object Class的静态方法forName()方法有两个版本，上面所示的是指定类名版本，还一个版本可以让我们指定类名，加载时是否执行静态代码块，指定类的加载器（Class loader）: 1static Class forName(String name, boolean initialize, ClassLoader loader) 上一篇写到过，假设在加载类的时候，如果类中有定义静态代码块则会执行它，我们可以使用forName的第二个版本，将initialize设为false，如果在加载类时并不会马上执行静态代码块的代码，而会在使用类实例对象时才执行静态代码块，我们可以做一下测试： 1234567891011package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class TestClass2 &#123; static &#123; System.out.println("[执行静态代码块]"); &#125;&#125; 在这里我们只定义了静态代码块显示一段信息，来观察静态代码块何时被执行。先用第一个版本来测试： 12345678910111213141516171819202122package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class ForNameDemoV1 &#123; public static void main(String[] args) &#123; try &#123; System.out.println("加载TestClass2"); Class c = Class.forName("TestClass2"); System.out.println("TestClass2声明"); TestClass2 test = null; System.out.println("TestClass2实例对象"); test = new TestClass2(); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定的类"); &#125; &#125;&#125; 输出： 123456加载TestClass2[执行静态代码块]TestClass2声明TestClass2实例对象Process finished with exit code 0 可以从结果看出，第一个版本的forName()方法在加载类之后，会马上执行静态代码块，再看看第二种结果怎么样： 12345678910111213141516171819202122232425package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class ForNameDemoV2 &#123; public static void main(String[] args) &#123; try &#123; System.out.println("加载TestClass2"); Class c = Class.forName( "CoreJava.day_2.TestClass2", false, // 加载类时不执行静态代码块代码 Thread.currentThread().getContextClassLoader()); System.out.println("TestClass2声明"); TestClass2 test = null; System.out.println("TestClass2实例对象"); test = new TestClass2(); &#125; catch (ClassNotFoundException e) &#123; System.out.println("找不到指定的类"); &#125; &#125;&#125; 输出：123456加载TestClass2TestClass2声明TestClass2实例对象[执行静态代码块]Process finished with exit code 0 由于在第二个版本的forName()方法中，把initialize设为了false，所以加载类时并不会马上执行静态代码块，而会在类实例对象时才去执行静态代码块代码，第二个版本的forName()方法需要一个类加载器（Class loader）。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java反射学习总结（一)]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E5%8F%8D%E5%B0%84%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93%EF%BC%88%E4%B8%80%2F</url>
    <content type="text"><![CDATA[Java提供的反射机制允许我们在运行时期动态加载类，检测和修改它本身状态或行为，要举反射机制的一个实例的话，就是在整合开发环境中所提供的方法提示或者类的检查工具，另外像jsp中的javabean自动收集请求也用到了反射，还有我们经常用的框架也可以看到反射机制的使用，这样可以达到动态加载使用者自己定义的类的目的。在我们拿到一个类时，即使对它一无所知，但是其实他本身就包括了很多信息，Java在需要使用某个类时才会将类加载，并在jvm中以一个java.lang.Class的实例存在，从Class实例开始，我们可以获取类的信息。 Class类的加载 Java在真正需要使用一个类的时候才会进行加载，而不是在程序启动时加载所有的类，因为大多数人都只使用到应用程序的部分资源，在需要某些功能时在加载某些资源，这样可以让系统的资源运用更有效率。 一个java.lang.Class代表了Java程序中运行时加载类或者接口的实例，也可以用来表达enum（枚举），annotation（注解），数组，基本数据类型；Class类没有public构造方法，Class是由jvm自动生成的，每当一个类被加载时，jvm就会自动生成一个Class实例。 我们还可以通过Object的getClass()方法来取得每一个对象对应Class实例，或者通过”class”常量，在取得Class实例之后，操作Class实例上的一些方法来取得类的基本信息，例如： 12345678910111213141516171819202122package CoreJava.day_2;/** * @author 李智 * @date 2016/12/3 */public class ClassDemo &#123; public static void main(String[] args) &#123; String name = "justdoitlee"; Class stringClass = name.getClass(); System.out.println("类名称：" + stringClass.getName()); System.out.println("是否为接口：" + stringClass.isInterface()); System.out.println("是否为基本数据类型：" + stringClass.isPrimitive()); System.out.println("是否为数组：" + stringClass.isArray()); System.out.println("父类名称：" + stringClass.getSuperclass().getName()); &#125;&#125; 执行结果： 1234567类名称：java.lang.String是否为借口：false是否为基本数据类型：false是否为数组：false父类名称：java.lang.ObjectProcess finished with exit code 0 这里简单的的使用 getClass() 方法来取得 String 类的 Class 实例，并从中得到 String 的一些基本信息。 当然，我们也可以直接使用下面的方式来取得String类的Class对象： 1Class stringClass = String.class; Java在真正需要类时才会加载这个类，所谓的真正需要通常指的是要使用指定的类生成对象时，或者使用指定要加载的类时，例如使用Class.forName()加载类，或者使用ClassLoader的loadClass()加载类，声明类并不会导致类的加载，可以使用一个小测试来验证。 1234567891011package CoreJava.day_2;/** * @author 李智 * @date 2016/12/3 */public class TestClass &#123; static &#123; System.out.println("类被加载"); &#125;&#125; 在上面我们定义了一个静态代码块，假设在类第一次被加载时会执行静态代码块（说假设是因为，可以设置加载类时不执行静态代码块，使Class生成对象时才执行静态代码块），看输出信息可以看出类何时被加载(如下LoadClassTest)。 1234567891011121314package CoreJava.day_2;/** * @author 李智 * @date 2016/12/3 */public class LoadClassTest &#123; public static void main(String[] args) &#123; TestClass test = null; System.out.println("声明TestClass"); test = new TestClass(); System.out.println("生成TestClass实例"); &#125;&#125; 输出： 12345声明TestClass类被加载生成TestClass实例Process finished with exit code 0 从执行结果可以看出，声明类并不会导致TestClass被加载，而是在使用new生成对象时才会被加载类。 Class的信息是在编译时期就被加入至.class文件的，这是Java执行时期被辨别（RTTI，Run-Time Type Information或Run-Time Type Identification）的一种方式，在编译时期编译器会先检查对应的.class文件，而执行时期jvm在使用类时，会先检查对应的Class是否已经被加载，如果没有加载，则会寻找对应的,class文件并加载，一个类在jvm中只会有一个Class实例，每个类的实例都会记得自己是由哪个Class实例所生成，我们可以使用getClass()或.class来取得Class实例。 另外，在Java中，数组对象也有对应的Class实例，这个对象是由具有相同元素与维度的数组所共用，而基本类型像是 boolean, byte, char, short, int, long, float, double 以及关键字 void（以前都不知道有这个呢！！），也都具有对应的Class对象，我们还可以用类常量（Class literal）来获取这些对象。 123456789101112131415161718package CoreJava.day_2;/** * @author 李智 * @date 2016/12/4 */public class ClassDemo2 &#123; public static void main(String[] args) &#123; System.out.println(boolean.class); System.out.println(void.class); int[] iarr = new int[10]; System.out.println(iarr.getClass().toString()); double[] darr = new double[10]; System.out.println(darr.getClass().toString()); &#125;&#125; 输出： 123456booleanvoidclass [Iclass [DProcess finished with exit code 0 在Java中 数组确实是以对象的形式存在的，其对应的类都是有jvm自动生成的，当我们是用toString()来显示数组对象的描述时，[表示为数组类型，并且加上一个类型代表字，上面的I表示是一个Int的数组，d是一个double数组。 这里就先讲一下Class类的加载吧，后面的再总结。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们为什么要用Spring，SpringMVC]]></title>
    <url>%2F2017%2F02%2F18%2F%E6%88%91%E4%BB%AC%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8Spring%EF%BC%8CSpringMVC%2F</url>
    <content type="text"><![CDATA[今天被公司派到别的公司谈项目，刚去就先被面试了一波（原来是把我外包到别的公司做项目了 -。-），面试时候问了我一个问题，很简单，就是问我java开发web项目为什么要用spring,springmvc？好吧，当时我人直接懵逼了，什么鬼问我这个！！不就是可以省去很多功夫让我们踏踏实实写业务代码嘛? 当时就随便回答了一些，回到公司仔细想想，发现还有挺多可以想，可以讲的。我想起了之前项目的控制层从struts2转到springmvc，我就在想为什么我们现在做javaweb开发，要用struts2或者springMVC这样的框架，而不是使用servlet加jsp这样的技术呢？特别是现在我们web的前端页面都是使用freemaker这样的模板语言进行开发，抛弃了jsp，这样的选择又会给我们javaweb开发带来什么样的好处，延着这个问题的思路，我又发现新的疑问，为什么现在很多java企业级开发都会去选择spring框架，spring框架给我们开发的应用带来了什么？这么一想我人更加糊涂了，很难找带让自己完全信服的答案。最终我发现，这些我认为“用”的很熟悉技术，其实还有很多让我陌生不解的地方，这些陌生和不解的地方也正是我是否能更高层次使用它们的关键。 首先，软件里有很多优秀的框架，有一种类型的框架，它的特点是建立在一个现有技术的基础上，提供和现有技术一样业务功能的技术框架，这个新的技术框架比原技术更加易用，更加健壮同时功能更加强大，例如常用的jQuery，以及上面提到的spring和springMVC（其实是一个啦），深究这些框架都是很复杂的，但是它们的优点其实只有一个：就是让使用者只关心核心业务的开发，框架帮你屏蔽原有技术跟业务开发无关的各类技术问题。像jQuery，springMVC这类框架之所以优秀，就是它们在这点上做的太好了，以至于很多使用它的程序员都已经不清楚原有技术的真实面目，因此我们要将springmvc理解的更好，使用的更加熟练和深入，这里我们就要跳出springmvc的技术，到springmvc技术的源头servlet，仔细研究下servlet的特点，只有这样我们才能把springmvc框架学的更好（所以才那么多人看springmvc的源码学习吧）。 先讲讲servlet吧，servlet的作用就是是接收浏览器传给服务端的请求（request），并将服务端处理完的响应（response）返回给用户的浏览器，浏览器和服务端之间通过http协议进行沟通，其过程是浏览器根据用户的选择将相关信息按http协议报文的规范组装请求的http报文，报文通过网络传输到指定的服务器，服务器通过特定的web容器接收这个报文信息，例如：tomcat，jetty，jboss这样的web容器，web容器会将http报文解析出来，如果是用户请求，最终解析出来的报文信息会用一个request对象存储起来，服务端使用这个request做完相应的处理后，服务端程序将结果信息封装到response对象里，然后将response对象交给web容器，web容器则把这个response对象转变为http协议的报文，并将报文回传给浏览器，浏览器最后解析这个响应报文，将最终结果展示给用户。 而Web容器创造了servlet接口，servlet接口就是开发人员自己实现业务逻辑的地方，程序员开发servlet就好比做填空题，而填空题的语境或者说上下文提示就是由request和response对象，但是javaEE规范里的servlet接口很简单，就三个方法init，service和destory，但是这个接口太笼统了，所以规范里还提供了一个HttpServlet类，这个类根据http请求类型提供了doGet，doPost等方法，servlet接口最大的特点就是根据http协议的特点进行定义，因此做servlet开发时候如果使用者对http协议特点不是特别熟悉，都会碰到或多或少令人迷惑的问题，特别是碰到一些复杂特殊的请求时候：例如文件上传，返回特殊的文件格式到浏览器，这时候使用servlet开发就不是很方便了，servlet开发还有个问题可能大家常常被忽视，就是请求的数据的类型转化，http协议传输都是文本形式，到了web容器解析后也是文本类型，如果碰到货币，数字，日期这样的类型需要我们根据实际情况进行转化，如果页面传送的信息非常多，我们就不得不做大量类型转化，这种工作没有什么技术含量，是个体力活而且很容易导致程序错误。 servlet另一个作用就是构造response对象，让页面获得正确的响应，其实现代的浏览器是一个多媒体工具，文字，图片，视屏等等东西都可以在浏览器里显示，资源的不同就会导致http响应报文的差别，如果我们使用servlet开发就要根据资源的不同在java程序里用硬编码的形式处理，这样的程序很难复用，而且如果程序员对某种资源的处理理解不到位，就会导致问题的出现。 而在SpringMVC 中，控制器Controller 负责处理由DispatcherServlet 分发的请求，它把用户请求的数据经过业务处理层处理之后封装成一个Model ，然后再把该Model 返回给对应的View 进行展示。在SpringMVC 中提供了一个非常简便的定义Controller 的方法，你无需继承特定的类或实现特定的接口，只需使用@Controller 标记一个类是Controller ，然后使用@RequestMapping 和@RequestParam 等一些注解用以定义URL 请求和Controller 方法之间的映射，这样的Controller 就能被外界访问到。此外Controller 不会直接依赖于HttpServletRequest 和HttpServletResponse 等HttpServlet 对象，它们可以通过Controller 的方法参数灵活的获取到。 servlet里还有两个重要的技术：监听器和过滤器，对于监听器在web开发里使用的场景比较少，都是一些十分特别的情况才会使用，大部分web开发里可以忽略它的使用，我们用的最多的监听器可能就是对ServletContext创建和销毁的监听器，ServletContext是整个web应用的全局对象，它和Web应用的生命周期绑定在一起，因此使用这个监听器对Web应用的全局信息进行初始化和销毁操作，例如spring容器的初始化操作。而过滤器方面，使用SpringMVC拦截器和Struts2一样，Spring MVC也可以使用拦截器对请求进行拦截处理，用户可以自定义拦截器来实现特定的功能，自定义的拦截器必须实现HandlerInterceptor接口。 下面再谈谈springspring技术可以说是java企业开发里最重要的技术，不过真的理解spring的作用和意义还真是一件麻烦的事情，很多人对spring理解其实都是停留在使用阶段（例如：声明式事务很好用等等），当今的spring技术生态环境里可谓是蔚为壮观，spring已经包罗万象，它的内容之多完全不亚于它的本源java语言了，而spring这么大的框都是建立在ioc和aop技术之上，只有深入理解了这两个技术我们才能明白为什么spring这个框能装的下那么多东西了。 首先是ioc，ioc技术第一个解释叫做控制反转，它还有个解释就是依赖注入，这两个名字很难从字面理解，但是当你理解它的原理后就会发现它们的描述是何等准确。Ioc技术的本质就是构建对象的技术换句话说就是将一个类实例化成对象的技术，在java里实例化类通过new关键字进行的，每次new一个类都会产生一个新的实例对象，这么做视乎很浪费，有时这种浪费还挺危险，因为在程序开发时候我们常常只需要某个类永远只能产生一个的实例对象这个时候就得使用单例模式，此外在设计模式里还可以通过工厂方式产生对象，使用过spring的人看到上面的文字就知道了，spring里bean的定义就和上面的内容一一对应，scope属性single产生单例对象，prototype产生新对象，bean还可以通过工厂方式产生对象，可以说spring的bean就是制造对象的工具。面向对象编程里对象相当于显示生活中的一个实体，例如我们有个对象作用是完成打猎的操作，那么打猎这个对象内部包含两个辅助对象：人和枪，只有人和枪赋予了打猎这个对象，那么打猎对象才能完成打猎的操作，但是构建一个人和枪的对象并不是看起来那么简单，这里以枪为例，要创造一把枪我们需要金属，需要机床，需要子弹，而机床和子弹又是两个新对象，这些对象一个个相互嵌套相互关联，大伙试想下如果我们在java代码里构建一个枪的对象那是何其的复杂，假如我们要构造的不是简单的枪对象而是更加复杂的航空母舰，那么构造这个对象的成本之高是让人难以想象的，怎么来消除这种对象相互嵌套相互依赖的关系了？spring提供了一种方式，这种方式就是spring提供一个容器，我们在xml文件里定义各个对象的依赖关系，由容器完成对象的构建，当我们java代码里需要使用某个实例的时候就可以从容器里获取，那么对象的构建操作就被spring容器接管，所以它被称为控制反转，控制反转的意思就是本来属于java程序里构建对象的功能交由容器接管，依赖注入就是当程序要使用某个对象时候，容器会把它注入到程序里，这就叫做依赖注入。在java开发里我们想使用某个类提供的功能，有两种方式，一种就是构造一个新的类，新的类继承该类，另一种方式则是将某个类定义在新类里，那么两个类之间就建立一种关联关系，spring的ioc容器就是实现了这种关联关系（记住不是继承关系哦），那么某个类要被赋予到新类有哪些办法了？一般只有两种：一种就是通过构造函数，一种就是通过setXXX方式，这也是spring容器使用到了两种标准的注入方式。 不管是上面说的继承方式，还是关联方式其实都是增强目标对象能力的开发手段，在设计模式里有一种代理模式，代理模式将继承模式和关联模式结合在一起使用，代理模式就是继承模式和关联模式的综合体，不过这个综合体的作用倒不是解决对象注入的问题，而是为具体操作对象找到一个保姆或者是秘书，这就和小说里的二号首长一样，这个二号首长对外代表了具体的实例对象，实例对象的入口和出口都是通过这个二号首长，因为具体的实例对象是一号首长，一号首长是要干大事的，所以一些事务性，重复性的工作例如泡茶，安排车子，这样的工作是不用劳烦一号首长的大驾，而是二号首长帮忙解决的，这就是aop的思想，aop解决程序开发里事务性，和核心业务无关的问题，但这些问题对于业务场景的实现是很有必要的，在实际开发里aop也是节省代码的一种方式。 Spring的核心技术的作用本质就是一个 沟通机制，spring总是尽全力的让沟通的双方信息畅通，同时降低双方的沟通成本，在现实机构里一个善于沟通的人肯定是该公司的领导，很会沟通的领导能调动起各种资源的积极性，善于沟通的领导就会做到海纳百川，让各种不同人追随他，所以当今的spring就是一个大框，什么都可以往里装。 Spring很像银行，它不能直接创造物质财富，但是一切资源都要通过它进行流通，它能控制经济发展的走向，回到程序的世界，spring的作用是被标榜为程序之间的解耦，spring能降低不同模块之间的耦合度，原因就是在程序开发里不同模块之间信息的沟通是通过对象传递完成的，而对象能否顺利传递就是要合理的构建好对象，而管理好对象的构建方式就能管理好对象传递，这就是spring给系统架构设计带来的好处。 写啊写，找啊找，抄啊抄，结果搞了这么多。。。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java的静态/动态绑定]]></title>
    <url>%2F2017%2F02%2F18%2FJava%E7%9A%84%E9%9D%99%E6%80%81-%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[今天看到《Java核心技术I》书上的动态绑定，意思就是当子类和父类存在同一个方法，子类重写了父类的方法，程序在运行时调用方法是调用父类的方法还是子类的重写方法呢？程序会在运行的时候自动选择调用某个方法（根据方法表）。看完这里不由自主的想到，有动态肯定也就有静态吧，于是去求助了下google，首先看了下什么是绑定:绑定指的是一个方法的调用与方法所在的类(方法主体)关联起来。对java来说，绑定分为静态绑定和动态绑定；或者叫做前期绑定和后期绑定。然后我们分别看看两者之间含义以及差别动态绑定：在运行时根据具体对象的类型进行绑定。若一种语言实现了后期绑定，同时必须提供一些机制，可在运行期间判断对象的类型，并分别调用适当的方法。也就是说，编译器此时依然不知道对象的类型，但方法调用机制能自己去调查，找到正确的方法主体。不同的语言对后期绑定的实现方法是有所区别的。但我们至少可以这样认为：它们都要在对象中安插某些特殊类型的信息。 动态绑定的过程：虚拟机提取对象的实际类型的方法表；–&gt;虚拟机搜索方法签名；–&gt;调用方法。 静态绑定：在程序执行前方法已经被绑定（也就是说在编译过程中就已经知道这个方法到底是哪个类中的方法），此时由编译器或其它连接程序实现。针对java，可以简单的理解为程序编译期的绑定；这里要特别说明一点，java当中的方法只有final，static，private和构造方法是前期绑定。 差别：其实上述解释可以看出很多东西了。（1）静态绑定发生在编译时期，动态绑定发生在运行时（2）使用private或static或final修饰的变量或者方法，使用静态绑定。而虚方法（可以被子类重写的方法）则会根据运行时的对象进行动态绑定。（3）静态绑定使用类信息来完成，而动态绑定则需要使用对象信息来完成。（4）重载(Overload)的方法使用静态绑定完成，而重写(Override)的方法则使用动态绑定完成。 下面开始代码测试： 123456789101112131415public class Test &#123; public static void main(String[] args) &#123; String str = new String(); Lee lee = new Lee(); lee.say(str); &#125; static class Lee &#123; public void say(Object obj) &#123; System.out.println("这是个Object"); &#125; public void say(String str) &#123; System.out.println("这是个String"); &#125; &#125;&#125; 执行结果：12$ java Test这是个String 在上面的代码中，lee方法存在两个重载的实现，一个是接收Object类型的对象作为参数，另一个则是接收String类型的对象作为参数。而str是一个String对象，所有接收String类型参数的call方法会被调用。而这里的绑定就是在编译时期根据参数类型进行的静态绑定。 接着我们反编译验证一下: 123456789101112131415161718192021222324javap -c Test Compiled from "Test.java"public class CoreJava.day_2.Test &#123; public CoreJava.day_2.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class java/lang/String 3: dup 4: invokespecial #3 // Method java/lang/String."&lt;init&gt;":()V 7: astore_1 8: new #4 // class CoreJava/day_2/Test$Lee 11: dup 12: invokespecial #5 // Method CoreJava/day_2/Test$Lee."&lt;init&gt;":()V 15: astore_2 16: aload_2 17: aload_1 18: invokevirtual #6 // Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V 21: return&#125; 看到了这一行18: invokevirtual #6 // Method CoreJava/day_2/Test$Lee.call:(Ljava/lang/String;)V确实是发生了静态绑定，确定了调用了接收String对象作为参数的say方法。 现在可以改写一下： 1234567891011121314151617181920public class Test&#123; public static void main(String[] args) &#123; String str = new String(); Lee lee = new SecLee(); lee.say(str); &#125; static class Lee &#123; public void say(String str) &#123; System.out.println("这是个String"); &#125; &#125; static class SecLee extends Lee &#123; @Override public void say(String str) &#123; System.out.println("这是第二李的String"); &#125; &#125;&#125; 结果为： 12$ java Test这是第二李的String 上面，用SecLee继承了Lee，并且重写了say方法。我们声明了一个Lee类型的变量lee，但是这个变量指向的是他的子类SecLee。根据结果可以看出，其调用了SecLee的say方法实现，而不是Lee的say方法。这一结果的产生的原因是因为在运行时发生了动态绑定，在绑定过程中需要确定调用哪个版本的say方法实现。 再看看反编译的结果： 12345678910111213141516171819202122232425javap -c Test警告: 二进制文件Test包含CoreJava.day_2.TestCompiled from "Test.java"public class CoreJava.day_2.Test &#123; public CoreJava.day_2.Test(); Code: 0: aload_0 1: invokespecial #1 // Method java/lang/Object."&lt;init&gt;":()V 4: return public static void main(java.lang.String[]); Code: 0: new #2 // class java/lang/String 3: dup 4: invokespecial #3 // Method java/lang/String."&lt;init&gt;":()V 7: astore_1 8: new #4 // class CoreJava/day_2/Test$SecLee 11: dup 12: invokespecial #5 // Method CoreJava/day_2/Test$SecLee."&lt;init&gt;":()V 15: astore_2 16: aload_2 17: aload_1 18: invokevirtual #6 // Method CoreJava/day_2/Test$Lee.say:(Ljava/lang/String;)V 21: return&#125; 正如上面的结果，18: invokevirtual #6 // Method CoreJava/day_2/Test Lee.say:(Ljava/lang/String;)V这里是TestLee.say而非Test$SecLee.say，因为编译期无法确定调用子类还是父类的实现，所以只能丢给运行时的动态绑定来处理。 既然重写测试了，那我们再试试重载： 下面的例子更复杂！Lee类中存在say方法的两种重载，更复杂的是SecLee集成Lee并且重写了这两个方法。其实这种情况是上面两种情况的复合情况。下面的代码首先会发生静态绑定，确定调用参数为String对象的say方法，然后在运行时进行动态绑定确定执行子类还是父类的say实现。 1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; String str = new String(); Lee lee = new SecLee(); lee.say(str); &#125; static class Lee &#123; public void say(Object obj) &#123; System.out.println("这是Object"); &#125; public void say(String str) &#123; System.out.println("这是String"); &#125; &#125; static class SecLee extends Lee &#123; @Override public void say(Object obj) &#123; System.out.println("这是第二李的Object"); &#125; @Override public void say(String str) &#123; System.out.println("这是第二李的String"); &#125; &#125;&#125; 结果: 12$ java Test这是第二李的String 结果在意料之中，就不多说了。 那么问题来了，非动态绑定不可么？其实某些方法的绑定也可以由静态绑定实现，比如说： 12345public static void main(String[] args) &#123; String str = new String(); final Lee lee = new SecLee(); lee.say(str);&#125; 可以看出，这里lee持有SecLee的对象并且lee变量为final，立即执行了say方法，编译器理论上通过足够的分析代码，是可以知道应该调用SecLee的say方法。 结论：由于动态绑定需要在运行时确定执行哪个版本的方法实现或者变量，比起静态绑定起来要耗时，所以正如书上所说的，有些程序员认为，除非有足够的理由使用多态性，应该把所有的方法都声明为final，private或者static进行修饰。我觉得这个有点偏激了，具体使用仁者见仁，智者见智吧。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>静态动态绑定</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql 如何插入一列自增序号]]></title>
    <url>%2F2017%2F02%2F18%2Fmysql-%E5%A6%82%E4%BD%95%E6%8F%92%E5%85%A5%E4%B8%80%E5%88%97%E8%87%AA%E5%A2%9E%E5%BA%8F%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[今天看到朋友问的一个问题，“mysql 加一列 叫序号 然后序号自增 怎么搞？”,由于他主要用的是oracle，所以不太了解mysql的用法，然后我就告诉他用rownum就好了，但是他说用了这个没得到效果。我想了一下 没啥啊。他说他就想在查询结果中加一个序号列 实现自增，于是我自己建了张表实验一下。 只给了id和name两个字段，方便测试。 随便插入了几条数据（设置了utf-8的格式输入中文就直接???了 不知道怎么回事，估计是数据库编码有点问题，先用英文凑合一下。） 1select @rd := @rd+1 as rownum, b.name from (select @rd:=0, name from test) b 取出name属性，然后给变量rd自增1赋给rownum，看结果： 然后，然后就这么成了 -。- 用变量累加，插入有自增字段的临时表中、如果有唯一标识的字段，也可以用查询解决。]]></content>
      <categories>
        <category>数据库那点事</category>
      </categories>
      <tags>
        <tag>mysql</tag>
        <tag>自增序号</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于Ajax的cache参数的测试]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%85%B3%E4%BA%8EAjax%E7%9A%84cache%E5%8F%82%E6%95%B0%E7%9A%84%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;其实这次做这个测试是因为和同学谈论@requestbody时引发的一个笑话，我之前一直以为ajax中的dataType: &#39;json&#39;是传输去后台的数据格式，后来分分钟被打脸，查了一下百度，才知道原来dataType: &#39;json&#39;是期望返回的数据类型，由此才发现原来ajax并没有平常用的那么简单。首先我们来看一下什么是Ajax：AJAX = 异步 JavaScript 和 XML。AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必需重载整个网页面。有很多使用 AJAX 的应用程序案例：新浪微博、Google 地图、开心网等等。(以上来自w3cschool) 在看这些资料的过程中，一个参数引起了我的注意：cache 这个cache有true和false两个方向，显式的要求如果当前请求有缓存的话，直接使用缓存。如果该属性设置为 false，则每次都会向服务器请求。由此我做了下面的测试： 首先创建一个servlet，用来接收客户端发来的请求 AjaxServlet.java 1234567891011121314151617public class AjaxServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println("进入了servlet!"); resp.setContentType("text/html;charset=UTF-8"); PrintWriter out = resp.getWriter(); int a = 1; out.print(a); out.flush(); out.close(); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doGet(req, resp); &#125;&#125; 这里做出了标记，如果请求进来了，控制台会输出”进入了servlet” 然后创建一个Jsp用来发出请求：ajaxTest.jsp 1234567891011121314151617181920212223&lt;%@ page contentType="text/html;charset=UTF-8" language="java" %&gt;&lt;% String path = request.getContextPath(); %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;button id="ajaxBtn" value="点我试试~"&gt;点我试试~&lt;/button&gt;&lt;/body&gt;&lt;script src="jquery.js"&gt;&lt;/script&gt;&lt;script&gt; $("#ajaxBtn").click(function () &#123; $.ajax(&#123; url: "&lt;%=path%&gt;/AjaxServlet", type: 'get', cache: true, success: function (data) &#123; alert(data); &#125; &#125;); &#125;)&lt;/script&gt;&lt;/html&gt; 这里点击这个按钮可以出发一个get请求，我们把cache设置为了true，这样会在浏览器缓存中加载请求信息。 可以看出第一次成功进入了servlet，前台也alert出了这个返回的值。 接着我们点击第二次，发现居然还是进入了servlet!!!!!这是怎么回事呢？ 没办法只能继续踏上百度谷歌之路，经过查找发现，在IE浏览器下，可以实现这个功能，点击两次，第二次就不再进入servlet了。不过，并不鼓励使用cache:true,因为ajax是实时获取数据的，所以不太适合从缓存中加载信息，我想也正是因为这个原因，谷歌 safari浏览器实现不了这个功能吧，那么问题来了为什么ie还可以这么坚挺？（日常吐槽）。 附：ajax其他参数参数：url: 要求为String类型的参数，（默认为当前页地址）发送请求的地址。type: 要求为String类型的参数，请求方式（post或get）默认为get。注意其他http请求方法，例如put和delete也可以使用，但仅部分浏览器支持。timeout: 要求为Number类型的参数，设置请求超时时间（毫秒）。此设置将覆盖$.ajaxSetup()方法的全局设置。async：要求为Boolean类型的参数，默认设置为true，所有请求均为异步请求。如果需要发送同步请求，请将此选项设置为false。注意，同步请求将锁住浏览器，用户其他操作必须等待请求完成才可以执行。cache：要求为Boolean类型的参数，默认为true（当dataType为script时，默认为false）。设置为false将不会从浏览器缓存中加载请求信息。data: 要求为Object或String类型的参数，发送到服务器的数据。如果已经不是字符串，将自动转换为字符串格式。get请求中将附加在url后。防止这种自动转换，可以查看processData选项。对象必须为key/value格 式，例如{foo1:”bar1”,foo2:”bar2”}转换为&amp;foo1=bar1&amp;foo2=bar2。如果是数组，JQuery将自动为不同值对应同一个名称。例如{foo:[“bar1”,”bar2”]}转换为&amp;foo=bar1&amp;foo=bar2。dataType: 要求为String类型的参数，预期服务器返回的数据类型。如果不指定，JQuery将自动根据http包mime信息返回responseXML或responseText，并作为回调函数参数传递。 可用的类型如下： xml：返回XML文档，可用JQuery处理。 html：返回纯文本HTML信息；包含的script标签会在插入DOM时执行。 script：返回纯文本JavaScript代码。不会自动缓存结果。除非设置了cache参数。注意在远程请求时（不在同一个域下），所有post请求都将转为get请求。 json：返回JSON数据。 jsonp：JSONP格式。使用SONP形式调用函数时，例如myurl?callback=?，JQuery将自动替换后一个“?”为正确的函数名，以执行回调函数。 text：返回纯文本字符串。beforeSend：要求为Function类型的参数，发送请求前可以修改XMLHttpRequest对象的函数，例如添加自定义。 HTTP头。在beforeSend中如果返回false可以取消本次ajax请求。XMLHttpRequest对象是惟一的参数。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>Ajax</tag>
        <tag>cache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM常量池及字符串==比较分析]]></title>
    <url>%2F2017%2F02%2F18%2FJVM%E5%B8%B8%E9%87%8F%E6%B1%A0%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%AF%94%E8%BE%83%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[java中的常量池技术，是为了方便快捷地创建某些对象而出现的，当需要一个对象时，就可以从池中取一个出来（如果池中没有的话就创建一个），这样在我们需要重复创建相等变量节省了很多时间。&nbsp;&nbsp;常量池其实也就是一个内存空间，不同于使用new关键字创建的对象所在的堆空间。String类是java中用的比较多的类，同样为了创建String对象的方便，该类也实现了常量池的技术。在讲述常量池之前，我们有必要先说说JVM运行时数据区的内存模型。JVM运行时数据区的内存模型由五部分组成:1.方法区2.堆3.JAVA栈4.PC寄存器5.本地方法栈 例如对于s = "haha"``` ,它的虚拟机指令：1234```0: ldc #16; //String haha 2: astore_1 3: return 从上面的ldc指令的执行过程可以得出：s的值是来自被拘留String对象（由解析该入口的进程产生）的引用，即可以理解为是从被拘留String对象的引用复制而来的，故我个人的理解是s的值是存在栈当中。上面是对于s值得分析，接着是对于”haha”值的分析,我们知道，对于String s = “haha” 其中”haha”值在JAVA程序编译期就确定下来了的。简单一点说，就是haha的值在程序编译成class文件后，就在class文件中生成了。执行JAVA程序的过程中，第一步是class文件生 成，然后被JVM装载到内存执行。那么JVM装载这个class到内存中，其中的haha这个值，在内存中是怎么为其开辟空间并存储在哪个区域中呢？ &nbsp;&nbsp;首先我们不妨先来了解一下JVM常量池这个结构,这里我查询了一些资料,在资料中这样描述常量池:虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）和对其他类型，字段和方法的符号引用。对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的，对于String类型，有一张固定长度的CONSTANT_String_info表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。 下面讲讲八种基本类型的包装类和对象池 Java中基本类型的包装类的大部分都实现了常量池技术，这些类是 Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外 Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值小于等于127时才可使用对象池，也即对象不负责创建和管理大于127的这些类的对象。一些对应的测试代码：123456789101112131415161718192021public class Test &#123; public static void main(String[] args) &#123;//5种整形的包装类Byte,Short,Integer,Long,Character的对象，//在值小于127时可以使用常量池 Integer i1 = 127; Integer i2 = 127; Sstem.out.println(i1 == i2); //输出true //值大于127时，不会从常量池中取对象 Integer i3 = 128; Integer i4 = 128; System.out.println(i3 == i4); //输出false //Boolean类也实现了常量池技术 Boolean bool1 = true; Boolean bool2 = true; System.out.println(bool1 == bool2); //输出true //浮点类型的包装类没有实现常量池技术 Double d1 = 1.0; Double d2 = 1.0; System.out.println(d1 == d2); //输出false &#125;&#125; 对Integer对象的代码补充1234567public static Integer valueOf(int i) &#123; final int offset = 128; if (i &gt;= -128 &amp;&amp; i &lt;= 127) &#123; return IntegerCache.cache[i + offset]; &#125; return new Integer(i); &#125; 当你直接给一个Integer对象一个int值的时候，其实它调用了valueOf方法，然后你赋的这个值很特别，是128，那么没有进行cache方法，相当于new了两个新对象。所以问题中定义a、b的两句代码就类似于： 123Integer a = new Integer(128);Integer b = new Integer(128); 这个时候再问你，输出结果是什么？你就知道是false了。如果把这个数换成127，再执行： 1234567Integer a = 127;Integer b = 127;System.out.println(a == b);结果就是：true 进行对象比较时最好还是使用equals，便于按照自己的目的进行控制。这里引出equals()和= =,equals比较的是字符串字面值即比较内容,==比较引用。 看一下IntegerCache这个类里面的内容：1234567891011private static class IntegerCache &#123; private IntegerCache() &#123; &#125; static final Integer cache[] = new Integer[-(-128) + 127 + 1]; static &#123; for (int i = 0; i &lt; cache.length; i++) cache[i] = new Integer(i - 128); &#125; &#125; 由于cache[]在IntegerCache类中是静态数组，也就是只需要初始化一次，即static{……}部分，所以，如果Integer 对象初始化时是-128~127的范围，就不需要再重新定义申请空间，都是同一个对象—在IntegerCache.cache中，这样可以在一定程度上提高效率。 针对String方面的补充 在同包同类下,引用自同一String对象.在同包不同类下,引用自同一String对象.在不同包不同类下,依然引用自同一String对象.在编译成.class时能够识别为同一字符串的,自动优化成常量,所以也引用自同一String对象.在运行时创建的字符串具有独立的内存地址,所以不引用自同一String对象.String的intern()方法会查找在常量池中是否存在一份equal相等的字符串,如果有则返回一个引用,没有则添加自己的字符串进入常量池，注意：只是字符串部分。 所以这时会存在2份拷贝，常量池的部分被String类私有并管理，自己的那份按对象生命周期继续使用。 在介绍完JVM常量池的相关概念后，接着谈开始提到的”haha”的值的内存分布的位置。对于haha的值，实际上是在class文件被JVM装载到内存 当中并被引擎在解析ldc指令并执行ldc指令之前，JVM就已经为haha这个字符串在常量池的CONSTANT_String_info表中分配了空 间来存储haha这个值。既然haha这个字符串常量存储在常量池中，根据《深入JAVA虚拟机》书中描述：常量池是属于类型信息的一部分，类型信息也就 是每一个被转载的类型，这个类型反映到JVM内存模型中是对应存在于JVM内存模型的方法区中，也就是这个类型信息中的常量池概念是存在于在方法区中，而 方法区是在JVM内存模型中的堆中由JVM来分配的。所以，haha的值是应该是存在堆空间中的。 而对于s = new String("haha")``` ,它的JVM指令：12 0: new #16; //class String3: dup4: ldc #18; //String haha6: invokespecial #20; //Methodjava/lang/String.””:(Ljava/lang/String;)V9: astore_110: return123456789&lt;br&gt;通过上面6个指令，可以看出，String s = new String("haha");中的haha存储在堆空间中，而s则是在操作数栈中。 上面是对s和haha值的内存情况的分析和理解；那对于String s = new String("haha");语句,到底创建了几个对象呢? 我的理解：这里"haha"本身就是常量池中的一个对象，而在运行时执行new String()时，将常量池中的对象复制一份放到堆中，并且把堆中的这个对象的引用交给s持有。所以这条语句就创建了2个String对象。如下图所示：&lt;br&gt;&lt;img src="http://static.open-open.com/lib/uploadImg/20121021/20121021191840_830.jpg"&gt;**String 常量池问题的几个例子：**&lt;br&gt;【1】 String a = “a1”;String b = “a” + 1;System.out.println((a == b)); //result = trueString a = “atrue”;String b = “a” + “true”;System.out.println((a == b)); //result = trueString a = “a3.4”;String b = “a” + 3.4;System.out.println((a == b)); //result = true123分析：JVM对于字符串常量的"+"号连接，将程序编译期，JVM就将常量字符串的"+"连接优化为连接后的值，拿"a" + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。&lt;br&gt;【2】 String a = “ab”;String bb = “b”;String b = “a” + bb;System.out.println((a == b)); //result = false123分析：JVM对于字符串引用，由于在字符串的"+"连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即"a" + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。【3】 String a = “ab”;final String bb = “b”;String b = “a” + bb;System.out.println((a == b)); //result = true123分析：和[3]中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或 嵌入到它的字节码流中。所以此时的"a" + bb和"a" + "b"效果是一样的。故上面程序的结果为true。【4】 String a = “ab”;final String bb = getBB();String b = “a” + bb;System.out.println((a == b)); //result = falseprivate static String getBB() {return “b”;}1234分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和"a"来动态连接并分配地址为b，故上面程序的结果为false。通过上面4个例子可以得出得知：&lt;br&gt; String s = “a” + “b” + “c”;等价于String s = “abc” 这个就不一样了，最终结果等于:StringBuffer temp = new StringBuffer();temp.append(a).append(b).append(c);String s = temp.toString();1由上面的分析结果，可就不难推断出String 采用连接运算符（+）效率低下原因分析，形如这样的代码： public static void main(String args[]) { String s = null; for (int i = 0; i &lt; 100; i++) { s += “a”; } }1234每做一次 + 就产生个StringBuilder对象，然后append后就扔掉。下次循环再到达时重新产生个StringBuilder对象，然后 append 字符串，如此循环直至结束。 如果我们直接采用 StringBuilder 对象进行 append 的话，我们可以节省 N - 1 次创建和销毁对象的时间。所以对于在循环中要进行字符串连接的应用，一般都是用StringBuffer或StringBulider对象来进行 append操作。最后贴一个String对象的intern方法理解和分析，这是今天在群里看到的一个题目，也可以说是这篇博客的印子吧： public class Test { private static String a = “ab”; public static void main(String[] args) { String s1 = “a”; String s2 = “b”; String s = s1 + s2; System.out.println(s == a);//false System.out.println(s.intern() == a);//true }}```]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>字符串</tag>
        <tag>常量池</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于多线程的饥饿和公平]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%85%B3%E4%BA%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%A5%A5%E9%A5%BF%E5%92%8C%E5%85%AC%E5%B9%B3%2F</url>
    <content type="text"><![CDATA[偶然学习到多线程，看到多线程的饥饿和公平，觉得可以写点什么。什么是饥饿什么是公平呢？如果一个线程因为CPU运行时间全部被其他线程抢走而得不到CPU运行时间，这种状态被称之为“饥饿”。而该线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。解决饥饿的方案被称之为“公平性”，即所有线程均能公平地获得运行机会。&nbsp;&nbsp;首先我们要知道，什么原因导致了“饥饿”？在Java方面我觉的分为了三种情况:&nbsp;&nbsp;①.线程中高优先级的吞噬所有的低优先级的CPU时间。&nbsp;&nbsp;你能为每个线程设置独自的线程优先级，优先级越高的线程获得的CPU时间越多，线程优先级值设置在1到10之间，而这些优先级值所表示行为的准确解释则依赖于你的应用运行平台。所以对大多数应用来说，你最好是不要改变其优先级值。&nbsp;&nbsp;②线程被永久堵塞在一个等待进入同步块的状态&nbsp;&nbsp;Java的同步代码区也是一个导致饥饿的因素。Java的同步代码区对哪个线程允许进入的次序没有任何保障。这就意味着理论上存在一个试图进入该同步区的线程处于被永久堵塞的风险，因为其他线程总是能持续地先于它获得访问，这即是“饥饿”问题，而一个线程被“饥饿致死”正是因为它得不到CPU运行时间的机会。&nbsp;&nbsp;③.线程被永久堵塞在一个等待进入同步块的状态&nbsp;&nbsp;如果多个线程处在wait()方法执行上，而对其调用notify()不会保证哪一个线程会获得唤醒，任何线程都有可能处于继续等待的状态。因此存在这样一个风险：一个等待线程从来得不到唤醒，因为其他等待线程总是能被获得唤醒。 &nbsp;&nbsp;如何在Java中实现公平？无论哪里都不可能实现100%公平，所以我们只能提出比较好的方案来达到目的，首先可以通过同步结构来实现公平性的提高。先来一段简单的代码：12345public class Synchronizer&#123; public synchronized void doSynchronized()&#123; //需要运行很长时间的某些代码 &#125; &#125; &nbsp;&nbsp;如果有多个线程调用了doSynchronized()方法，在第一个获得访问的线程未完成前，其他线程将一直处于阻塞状态，而且在这种多线程被阻塞的场景下，接下来将是哪个线程获得访问是没有保障的。&nbsp;&nbsp;现在我们使用锁方式替代同步块来试试:12345678public class Synchronizer&#123; Lock lock = new Lock(); public void doSynchronized() throws InterruptedException&#123; this.lock.lock(); //当前线程锁住lock对象 //时间临界区 this.lock.unlock(); //当前线程释放lock对象上的锁 &#125; &#125; &nbsp;&nbsp;我们可以注意到doSynchronized()不再声明为synchronized，而是用lock.lock()和lock.unlock()来替代。下面是用Lock类做的一个实现:12345678910111213141516171819202122public class Lock&#123; private boolean isLocked = false; //是否加过锁的信号 private Thread lockingThread = null; //进行加锁的线程 public synchronized void lock() throws InterruptedException&#123; while(isLocked)&#123; //如果lock对象已被其他线程加锁了（线程已经退出了本lock()方法） wait(); //当前线程阻塞，它释放锁对象上的锁，其他线程可以再进入本lock() &#125; isLocked = true; //如果没加锁，则当前线程对锁对象加锁 lockingThread = Thread.currentThread(); &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; //如果调用lock()加锁的不是当前线程 throw new IllegalMonitorStateException( "所调用线程尚未锁定"); &#125; isLocked = false; //释放锁，标记为未加锁 lockingThread = null; notify(); //通知阻塞在锁对象上的线程队列，唤醒其中某一个线程 &#125; &#125; &nbsp;&nbsp;注意到上面对Lock的实现，如果存在多线程并发访问lock()，这些线程将阻塞在对lock()方法的访问上。另外，如果isLocked=true时，表示锁已被锁上，这些线程将阻塞在while(isLocked)循环的wait()调用里面。要注意的是，当线程正在等待进入lock() 时，可以调用wait()释放其锁实例对应的同步锁，使得其他多个线程可以进入lock()方法，并调用wait()方法。&nbsp;&nbsp;我们回头看doSynchronized()方法，可以看到在lock()和unlock()之间：一段代码将长时间运行，和进入lock()并调用wait()来比较的话。这意味着大部分时间用在等待进入锁和进入临界区的过程是用在wait()的等待中，而不是被阻塞在试图进入lock()方法中。&nbsp;&nbsp;由于同步块不会对等待进入的多个线程谁能获得访问做任何保障，同样当调用notify()时，wait()也不会做保障一定能唤醒线程。因此这个版本的Lock类和doSynchronized()那个版本就保障公平性而言，没有任何区别。&nbsp;&nbsp;但我们能改变这种情况。当前的Lock类版本调用自己的wait()方法，如果每个线程在不同的对象上调用wait()，那么只有一个线程会在该对象上调用wait()，Lock类可以决定哪个对象能对其调用notify()，因此能做到有效的选择唤醒哪个线程。&nbsp;&nbsp;下面看看如何把Lock类转变为公平锁FairLock。&nbsp;&nbsp;新的实现和之前的Lock类中的同步和wait()/notify()将会稍有不同。每一个调用lock()的线程都会进入一个队列，当解锁后，只有队列里的第一个线程被允许锁住FairLock实例，所有其它的线程都将处于等待状态，直到他们处于队列头部。12345678910111213141516171819202122232425262728293031323334353637383940414243public class FairLock &#123; private boolean isLocked = false; //是否加锁的信号 private Thread lockingThread = null; //加锁的线程 private List&lt;QueueObject&gt; waitingThreads = new ArrayList&lt;QueueObject&gt;(); //信号量队列 public void lock() throws InterruptedException&#123; //多个线程可同时进入 QueueObject queueObject = new QueueObject(); //局部对象，线程安全 boolean isLockedForThisThread = true; //是否为当前线程加锁 synchronized(this)&#123; //将当前线程（用信号量）推入队列 waitingThreads.add(queueObject); &#125; while(isLockedForThisThread)&#123; synchronized(this)&#123; //加锁操作需要同步 //锁状态依然被检查和设置，以避免出现滑漏条件 isLockedForThisThread = isLocked || waitingThreads.get(0) != queueObject; if(!isLockedForThisThread)&#123; //如果对象未加锁且队列头部是当前线程 isLocked = true; //加锁 waitingThreads.remove(queueObject); //从队列中移除当前线程 lockingThread = Thread.currentThread(); return; &#125; &#125; try&#123; //放在同步块之外，避免monitor嵌套锁死 queueObject.doWait(); //监视器对象（持有信号量isNotified）等待 &#125;catch(InterruptedException e)&#123; synchronized(this) &#123; waitingThreads.remove(queueObject); &#125; throw e; &#125; &#125; &#125; public synchronized void unlock()&#123; if(this.lockingThread != Thread.currentThread())&#123; //加锁的不是当前线程 throw new IllegalMonitorStateException( "该线程尚未锁"); &#125; isLocked = false; //解锁 lockingThread = null; if(waitingThreads.size() &gt; 0)&#123; //唤醒第一个线程 waitingThreads.get(0).doNotify(); &#125; &#125; &#125; 1234567891011121314151617181920public class QueueObject &#123; private boolean isNotified = false; public synchronized void doWait() throws InterruptedException &#123; while(!isNotified)&#123; this.wait(); &#125; this.isNotified = false; &#125; public synchronized void doNotify() &#123; this.isNotified = true; this.notify(); &#125; public boolean equals(Object o) &#123; return this == o; &#125; &#125; &nbsp;&nbsp;首先注意到lock()方法不再声明为synchronized，取而代之的是对必需同步的代码，在synchronized中进行嵌套。&nbsp;&nbsp;FairLock新创建了一个QueueObject的实例，并对每个调用lock()的线程都将其QueueObject实例推入队列。调用unlock()的线程将从队列头部获取QueueObject，并对其调用doNotify()，以唤醒在该对象上等待的线程。通过这种方式，在同一时间仅有一个等待线程获得唤醒，而不是所有的等待线程。这也是实现FairLock公平性的核心所在。&nbsp;&nbsp;请注意，在同一个同步块中，锁状态依然被检查和设置，以避免出现滑漏条件。&nbsp;&nbsp;还需注意到，QueueObject实际是一个semaphore。doWait()和doNotify()方法在QueueObject中保存着信号。这样做以避免一个线程在调用queueObject.doWait()之前被另一个调用unlock()并随之调用queueObject.doNotify()的线程重入，从而导致信号丢失。queueObject.doWait()调用放置在synchronized(this)块之外，以避免被monitor嵌套锁死，所以另外的线程可以进入unlock()来解锁，只要当没有线程在lock方法的synchronized(this)块中执行即可。&nbsp;&nbsp;最后，注意到queueObject.doWait()在try – catch块中是怎样调用的。在InterruptedException抛出的情况下，线程得以离开lock()，并需让它从队列中移除。性能考虑&nbsp;&nbsp;如果比较Lock和FairLock类，你会注意到在FairLock类中lock()和unlock()还有更多需要深入的地方。这些额外的代码会导致FairLock的同步机制实现比Lock要稍微慢些。究竟存在多少影响，还依赖于应用在FairLock临界区执行的时长。执行时长越大，FairLock带来的负担影响就越小，当然这也和代码执行的频繁度相关。]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>多线程</tag>
        <tag>饥饿</tag>
        <tag>公平</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实验插入b站h5播放器]]></title>
    <url>%2F2017%2F02%2F18%2F%E5%AE%9E%E9%AA%8C%E6%8F%92%E5%85%A5b%E7%AB%99h5%E6%92%AD%E6%94%BE%E5%99%A8%2F</url>
    <content type="text"><![CDATA[Hexo 插 B 站的播放器很简单，在 md 文档中插个 iframe 标签就行，aid 和 cid 值需要手动填写，播放器大小可以自己调节： B 站每个视频都有对应的 aid 和 cid 值，在视频网页的源代码中可以找到 1&lt;iframe src="https://www.bilibili.com/html/html5player.html?aid=3521416&amp;cid=6041635" width="960" height="600" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen&gt;&lt;/iframe&gt;]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>小插件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM虚拟机关于“不使用的对象手动赋值为null”的理解]]></title>
    <url>%2F2017%2F02%2F18%2FJVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%B3%E4%BA%8E%E2%80%9C%E4%B8%8D%E4%BD%BF%E7%94%A8%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%89%8B%E5%8A%A8%E8%B5%8B%E5%80%BC%E4%B8%BAnull%E2%80%9D%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[今天逛博客,看到了一个关于一个对象有没有必要手动赋值为null的问题，捋了捋思路，决定写个测试代码来实践一下。百说不如一用，直接上代码:12345678public class Test1 &#123; public static void main(String[] args) &#123; byte[] bytes = new byte[64 * 1024 * 1024];//作用就是向内存中填充一个10MB的对象 System.gc();//手动执行GC操作 &#125;&#125; 运行程序前，可以将JVM参数设置为如下:-verbose:gc-XX:+PrintGCDetails控制台部分输出结果如下:12[GC (System.gc()) [PSYoungGen: 3932K-&gt;744K(76288K)] 69468K-&gt;66288K(251392K), 0.0016500 secs] [Times: user=0.00 sys=0.03, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(76288K)] [ParOldGen: 65544K-&gt;66145K(175104K)] 66288K-&gt;66145K(251392K), [Metaspace: 3169K-&gt;3169K(1056768K)], 0.0101306 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 根据ParOldGen: 65544K-&gt;66145K(175104K)可以看出，bytes对象并没有因为没有使用而被gc回收。1234567891011121314public class Test2 &#123; /** * -verbose:GC * -XX:+PrintGCDetails * @param args */ public static void main(String[] args) &#123; &#123; byte[] bytes = new byte[64 * 1024 * 1024]; &#125; System.gc(); &#125;&#125; 控制台输出结果如下:1234567891011[GC (System.gc()) [PSYoungGen: 3932K-&gt;776K(76288K)] 69468K-&gt;66320K(251392K), 0.0013737 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 65544K-&gt;66145K(175104K)] 66320K-&gt;66145K(251392K), [Metaspace: 3169K-&gt;3169K(1056768K)], 0.0063873 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] Heap PSYoungGen total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000) eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000) from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000) to space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000) ParOldGen total 175104K, used 66145K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000) object space 175104K, 37% used [0x00000006c1e00000,0x00000006c5e987b8,0x00000006cc900000) Metaspace used 3176K, capacity 4494K, committed 4864K, reserved 1056768K class space used 346K, capacity 386K, committed 512K, reserved 1048576K 可以看出，根据gc日志[ParOldGen: 65544K-&gt;66145K(175104K)] ，gc依然没有回收bytes对象，哪怕已经不在方法区了，我们再次修改代码。123456789101112131415public class Test3 &#123; /** * -verbose:GC * -XX:+PrintGCDetails * @param args */ public static void main(String[] args) &#123; &#123; byte[] bytes = new byte[64 * 1024 * 1024]; &#125; int i = 1; System.gc(); &#125;&#125; gc日志输出如下:1234567891011[GC (System.gc()) [PSYoungGen: 3932K-&gt;776K(76288K)] 69468K-&gt;66320K(251392K), 0.0014193 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(76288K)] [ParOldGen: 65544K-&gt;609K(175104K)] 66320K-&gt;609K(251392K), [Metaspace: 3169K-&gt;3169K(1056768K)], 0.0076485 secs] [Times: user=0.02 sys=0.00, real=0.01 secs] Heap PSYoungGen total 76288K, used 655K [0x000000076b500000, 0x0000000770a00000, 0x00000007c0000000) eden space 65536K, 1% used [0x000000076b500000,0x000000076b5a3ee8,0x000000076f500000) from space 10752K, 0% used [0x000000076f500000,0x000000076f500000,0x000000076ff80000) to space 10752K, 0% used [0x000000076ff80000,0x000000076ff80000,0x0000000770a00000) ParOldGen total 175104K, used 609K [0x00000006c1e00000, 0x00000006cc900000, 0x000000076b500000) object space 175104K, 0% used [0x00000006c1e00000,0x00000006c1e987a8,0x00000006cc900000) Metaspace used 3176K, capacity 4494K, committed 4864K, reserved 1056768K class space used 346K, capacity 386K, committed 512K, reserved 1048576K 见证奇迹的时候到，[ParOldGen: 65544K-&gt;609K(175104K)]，竟然被回收了！这是为什么？当创建bytes对象的时候，那是因为当我们创建bytes对象的时候，局部变量表中当然有bytes的引用，哪怕我们没有使用，但GC roots依然存在着和bytes对象的关联。根据test2和代码test3，我们大概可以猜到如果不操作局部变量表，那么GC roots依然会保留，所以test2依然没有回收，但是到了test3，就回收了。好吧，再来一个无用的测试，我们手动赋值为null看看结果。1234567891011121314public class TestMain &#123; /** * -verbose:GC * -XX:+PrintGCDetails * @param args */ public static void main(String[] args) &#123; byte[] bytes = new byte[64 * 1024 * 1024]; //do something bytes = null; System.gc(); &#125;&#125; 其实都能想到，果然被gc干掉了……当然这只是一个实验，总结性的话就不说了，反正我也说不来，不过实践出真理！]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Jvm</tag>
        <tag>对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[黑车司机发车器Java版]]></title>
    <url>%2F2017%2F02%2F18%2F%E9%BB%91%E8%BD%A6%E5%8F%B8%E6%9C%BA%E5%8F%91%E8%BD%A6%E5%99%A8Java%E7%89%88%2F</url>
    <content type="text"><![CDATA[既然是发的黑车，磁力链接那套就不必仔细研究了，磁力链接其实类似于这样（下面的这个是真车）： magnet:?xt=urn:btih:3AEA94481B0A406C66083F14C6F42635C14562C2 说白了就是随机填充 40 个字母或数字，不过有一定几率会发出真车。 代码实现：1234567891011121314151617181920212223242526 public class OldDriver &#123; public static void main(String[] args) &#123; java.util.Scanner input = new java.util.Scanner(System.in); System.out.println("黑车司机虚假磁力链接发车器"); System.out.print("输入需要发的黑车数量："); int ljs = input.nextInt(); for (int i=1;i&lt;=ljs;i++)&#123; System.out.println("magnet:?xt=urn:btih:"+CLSC());/*调用 CLSC 函数，获取 40 个随机生成的字符串（CLSC指 磁力生成）*/ &#125; &#125; public static String CLSC()&#123; String cllj = ""; String randomchar; String chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"; for (int i=0;i&lt;40;i++)&#123; int RandomNumber = (int)(Math.random()*35);/*随机生成一个范围在 [0,35] 的数字*/ randomchar = "" + chars.charAt(RandomNumber);/*随机选择一个字符，字符位置由上一步随机数字决定*/ cllj = cllj+randomchar;/*将随机字符附到 cllj 字符串上，重复 40 次*/ &#125; return cllj; &#125;&#125; 运行效果：1234567黑车司机虚假磁力链接发车器输入需要发的黑车数量：5magnet:?xt=urn:btih:126XT8JCPZ6ZWV1Q77OSOAD2P2UOWOAZEIGNN0UHmagnet:?xt=urn:btih:VEKIXXTDDC6STSZN2IS1IQSW6RHJ6ZGC7NEGYIAJmagnet:?xt=urn:btih:G8Z7O3AIGY2C1PRRNJEZ6Q1VY3HGZQ34E2MOQUWRmagnet:?xt=urn:btih:MRXYGZUFONLDPN5G4E5EDCWMWLI00PB8ZVK6IIKQmagnet:?xt=urn:btih:3WQ1IYXW0MD3Z32DT80NCJBLTAJ0FC837TB2HW2M]]></content>
      <categories>
        <category>Java二三事</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>黑车</tag>
        <tag>种子</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo]]></title>
    <url>%2F2017%2F02%2F17%2FHello-Hexo%2F</url>
    <content type="text"><![CDATA[本博客由 Hexo 强力驱动，托管于 Github ，支持 https 。 早就有自己建博客的念头了，先前在把csdn和简书作为博客，写了有大半年吧，后来学生计划买了个云服务器，用ghost搭建了一个博客，但是太简洁了！！ 于是昨天天花了大半天的时间终于搞好了这个博客。 之后会将简书上的文章搬运过来，Markdown 语法的文章复制一下就行，富文本写的，还得转成 Markdown 语法。（csdn的Markdown复制十分好用！） 博客与csdn将同步更新，两边的留言都会认真回复，反正有(mei)的(you)是(nv)时(peng)间(you)]]></content>
      <categories>
        <category>蜜汁开始</category>
      </categories>
      <tags>
        <tag>迁移</tag>
      </tags>
  </entry>
</search>
